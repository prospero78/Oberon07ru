(*
   Copyright 2013 Krotov Anton

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*)

ÃŒƒ”À‹ RTL;

»ÃœŒ–“ sys := SYSTEM,
   Ï¿ÔË := ÏÓ‰¿œ»;

“»œ€

  IntArray = Ã¿——»¬ 2048 »« ÷≈ÀŒ≈;
  STRING = Ã¿——»¬ 2048 »« —»Ã¬;
  PROC = œ–Œ÷≈ƒ”–¿;

œ≈–≈Ã

  SelfName, rtab: ÷≈ÀŒ≈;
  CloseProc: PROC;

œ–Œ÷≈ƒ”–¿ [stdcall] _halt*(n: ÷≈ÀŒ≈);
   BEGIN
     Ï¿ÔË.ExitProcess(n)
   END _halt;

œ–Œ÷≈ƒ”–¿ [stdcall] _newrec*(size, t: ÷≈ÀŒ≈; VAR ptr: ÷≈ÀŒ≈);
   BEGIN
     ptr := Ï¿ÔË.œ‡ÏˇÚ¸_œÓÎÛ˜ËÚ¸(size);
     IF ptr # 0 THEN
       sys.PUT(ptr, t);
       INC(ptr, 4)
     END
   END _newrec;

œ–Œ÷≈ƒ”–¿ [stdcall] _disprec*(VAR ptr: ÷≈ÀŒ≈);
   BEGIN
     IF ptr # 0 THEN
       DEC(ptr, 4);
       ptr := Ï¿ÔË.œ‡ÏˇÚ¸_ŒÒ‚Ó·Ó‰ËÚ¸(ptr)
     END
   END _disprec;

œ–Œ÷≈ƒ”–¿ [stdcall] _rset*(y, x: ÷≈ÀŒ≈);
   BEGIN
     sys.CODE("8B45088B4D0C3BC87F0A83F91F760B83F81F760633C0C9C2080083F9007D0233C983F81F7E05B81F000000BA000000802BC8F7D9D3FA83E81F8BC8F7D9D3EA8BC2C9C20800")
   END _rset;

œ–Œ÷≈ƒ”–¿ [stdcall] _inset*(y, x: ÷≈ÀŒ≈);
   BEGIN
     sys.CODE("8B45088B4D0C83F91F7709D3E883E001C9C20800C933C0C20800")
   END _inset;

œ–Œ÷≈ƒ”–¿ [stdcall] _checktype*(table, t, r: ÷≈ÀŒ≈);
   BEGIN
     table := rtab;
     sys.CODE("8B450C8B4D1085C975076A0158C9C20C008B51FC8B4D083BD0740D85D27409C1E20203D18B12EBEF33C93BC20F94C18BC1C9C20C00")
   END _checktype;

œ–Œ÷≈ƒ”–¿ [stdcall] _savearr*(size, source, dest: ÷≈ÀŒ≈);
   BEGIN
     sys.CODE("9CFC8BD78BC68B7D108B750C8B4D08F3A48BFA8BF09D")
   END _savearr;

œ–Œ÷≈ƒ”–¿ [stdcall] _saverec*(dyn, stat, size, source, dest: ÷≈ÀŒ≈): BOOLEAN;
   VAR res: BOOLEAN;
   BEGIN
     res := dyn = stat;
     IF res THEN
       _savearr(size, source, dest)
     END
     RETURN res
   END _saverec;

œ–Œ÷≈ƒ”–¿ [stdcall] _arrayidx*(Dim: ÷≈ÀŒ≈; VAR Arr: IntArray; bsize, idx, c: ÷≈ÀŒ≈);
   VAR i, m: INTEGER;
   BEGIN
     m := bsize * idx;
     FOR i := 4 TO Dim + 2 DO
       m := m * Arr[i]
     END;
     IF (Arr[3] > idx) & (idx >= 0) THEN
       Arr[3] := c + m
     ELSE
       Arr[3] := 0
     END
   END _arrayidx;

œ–Œ÷≈ƒ”–¿ [stdcall] _arrayidx1*(VAR Arr: IntArray; bsize, idx, c: ÷≈ÀŒ≈);
   BEGIN
     IF (Arr[3] > idx) & (idx >= 0) THEN
       Arr[3] := bsize * idx + c
     ELSE
       Arr[3] := 0
     END
   END _arrayidx1;

œ–Œ÷≈ƒ”–¿ [stdcall] _arrayrot*(m, n: ÷≈ÀŒ≈; VAR Arr: IntArray);
   VAR i, j, t: ÷≈ÀŒ≈;
   BEGIN
     FOR i := 1 TO n DO
       t := Arr[0];
       FOR j := 0 TO m + n - 1 DO
         Arr[j] := Arr[j + 1]
       END;
       Arr[m + n] := t
     END
   END _arrayrot;

œ–Œ÷≈ƒ”–¿ Min(a, b: INTEGER): ÷≈ÀŒ≈;
   VAR res: ÷≈ÀŒ≈;
   BEGIN
     IF a < b THEN
       res := a
     ELSE
       res := b
     END
     RETURN res
   END Min;

œ–Œ÷≈ƒ”–¿ [stdcall] _length*(s: ARRAY OF CHAR): ÷≈ÀŒ≈;
   BEGIN
     sys.CODE("8B4508");     //  mov     eax, [ebp + 08h]
     sys.CODE("8B4D0C");     //  mov     ecx, [ebp + 0Ch]
     sys.CODE("48");         //  dec     eax
                             //  L1:
     sys.CODE("40");         //  inc     eax
     sys.CODE("803800");     //  cmp     byte ptr [eax], 0
     sys.CODE("7403");       //  jz      L2
     sys.CODE("E2F8");       //  loop    L1
     sys.CODE("40");         //  inc     eax
                             //  L2:
     sys.CODE("2B4508");     //  sub     eax, [ebp + 08h]
     sys.CODE("C9");         //  leave
     sys.CODE("C20800");     //  ret     08h
     RETURN 0
   END _length;

œ–Œ÷≈ƒ”–¿ [stdcall] _strcopy*(b, blen, a, alen: ÷≈ÀŒ≈);
   BEGIN
     _savearr(Min(alen, blen), a, b);
     IF blen > alen THEN
       sys.PUT(b + alen, 0X)
     END
   END _strcopy;

œ–Œ÷≈ƒ”–¿ [stdcall] _strcmp*(op: ÷≈ÀŒ≈; b, a: ARRAY OF CHAR): BOOLEAN;
   VAR i: ÷≈ÀŒ≈; Res: BOOLEAN;
   BEGIN
     i := Ï¿ÔË.strncmp(sys.ADR(a), sys.ADR(b), Min(LEN(a), LEN(b)));
     IF i = 0 THEN
       i := _length(a) - _length(b)
     END;
     CASE op OF
     |0: Res := i = 0
     |1: Res := i # 0
     |2: Res := i < 0
     |3: Res := i > 0
     |4: Res := i <= 0
     |5: Res := i >= 0
     ELSE
     END
     RETURN Res
   END _strcmp;

œ–Œ÷≈ƒ”–¿ [stdcall] _lstrcmp*(op: ÷≈ÀŒ≈; b: CHAR; a: ARRAY OF CHAR): BOOLEAN;
   VAR s: ARRAY 2 OF CHAR;
   BEGIN
     s[0] := b;
     s[1] := 0X;
     RETURN _strcmp(op, s, a)
   END _lstrcmp;

œ–Œ÷≈ƒ”–¿ [stdcall] _rstrcmp*(op: ÷≈ÀŒ≈; b: ARRAY OF CHAR; a: CHAR): BOOLEAN;
   VAR s: ARRAY 2 OF CHAR;
   BEGIN
     s[0] := a;
     s[1] := 0X;
     RETURN _strcmp(op, b, s)
   END _rstrcmp;

œ–Œ÷≈ƒ”–¿ Int(x: ÷≈ÀŒ≈; VAR str: STRING);
   VAR i, a, b: ÷≈ÀŒ≈; c: CHAR;
   BEGIN
     i := 0;
     a := 0;
     REPEAT
       str[i] := CHR(x MOD 10 + ORD("0"));
       x := x DIV 10;
       INC(i)
     UNTIL x = 0;
     b := i - 1;
     WHILE a < b DO
       c := str[a];
       str[a] := str[b];
       str[b] := c;
       INC(a);
       DEC(b)
     END;
     str[i] := 0X
   END Int;

œ–Œ÷≈ƒ”–¿ StrAppend(VAR str: STRING; VAR pos: ÷≈ÀŒ≈; s: ARRAY OF CHAR);
   VAR i, n: ÷≈ÀŒ≈;
   BEGIN
     n := LEN(s);
     i := 0;
     WHILE (i < n) & (s[i] # 0X) DO
       str[pos] := s[i];
       INC(pos);
       INC(i)
     END
   END StrAppend;

œ–Œ÷≈ƒ”–¿ [stdcall] _assrt*(code, m: ÷≈ÀŒ≈; modname: STRING; line: ÷≈ÀŒ≈);
   VAR msg, int: STRING; pos, n: ÷≈ÀŒ≈;
   BEGIN
     pos := 0;
     n := line MOD 16;
     line := line DIV 16;
     CASE n OF
     |1: StrAppend(msg, pos, "Ì‡Û¯ÂÌËÂ ÍÓÌÚÓÎˇ")
     |2: StrAppend(msg, pos, "ÔÂÂÏÂÌÌ˚Â ÚËÔ‡ ÔÓˆÂ‰Û˚ ËÏÂÂÚ NIL ‚ Í‡˜ÂÒÚ‚Â ÁÌ‡˜ÂÌËˇ")
     |3: StrAppend(msg, pos, "Ó¯Ë·Í‡ Óı‡Ì˚ ÚËÔ‡")
     |4: StrAppend(msg, pos, "ÌÂ‰ÓÔÛÒÚËÏ˚È ‰ËÌ‡ÏË˜ÂÒÍËÈ ÚËÔ")
     |5: StrAppend(msg, pos, "Ó¯Ë·Í‡ ÔÓ‚ÂÍË ËÌ‰ÂÍÒ‡")
     |6: StrAppend(msg, pos, "ÛÍ‡Á‡ÚÂÎ¸ œ”—“Œ ‡Á˚ÏÂÌÓ‚‡Ì")
     |7: StrAppend(msg, pos, "ÌÂ‰ÓÔÛÒÚËÏÓÂ ÁÌ‡˜ÂÌËÂ ‚ ÓÔÂ‡ÚÓÂ ¬€¡Œ–")
     |8: StrAppend(msg, pos, "‰ÂÎÂÌËÂ Ì‡ ÌÓÎ¸")
     ELSE
     END;
     StrAppend(msg, pos, 0DX);
     StrAppend(msg, pos, 0AX);
     StrAppend(msg, pos, "ÏÓ‰ÛÎ¸ ");
     StrAppend(msg, pos, modname);
     StrAppend(msg, pos, 0DX);
     StrAppend(msg, pos, 0AX);
     StrAppend(msg, pos, "ÒÚÓÍ‡ ");
     Int(line, int);
     StrAppend(msg, pos, int);
     IF m = 2 THEN
       StrAppend(msg, pos, 0DX);
       StrAppend(msg, pos, 0AX);
       StrAppend(msg, pos, "code ");
       Int(code, int);
       StrAppend(msg, pos, int)
     END;
     Ï¿ÔË.—ÓÓ·˘_ŒÚÎ‡‰ÍË(sys.ADR(msg), SelfName)
   END _assrt;

œ–Œ÷≈ƒ”–¿ [stdcall] _close*;
   BEGIN
     IF CloseProc # NIL THEN
       CloseProc
     END
   END _close;

œ–Œ÷≈ƒ”–¿ [stdcall] _init*(self, rec, gsize, gadr, esp: ÷≈ÀŒ≈);
   BEGIN
     Ï¿ÔË.zeromem(gsize, gadr);
     Ï¿ÔË.Õ‡ÒÚÓËÚ¸(esp);
     SelfName := self;
     rtab := rec;
     CloseProc := NIL;
   END _init;

œ–Œ÷≈ƒ”–¿ SetClose*(proc: PROC);
   BEGIN
     CloseProc := proc
   END SetClose;

END RTL.
