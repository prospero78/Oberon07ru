МОДУЛЬ DECL;

(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
    *)

ИМПОРТ SCAN,
    мУтиль := UTILS,
    X86, SYSTEM,
    мКонст := modConstante,
    мСтр := modString,
    мСпис := modList,
    мТипы := modType,
    мОш := modError,
    mProc := modProcess,
    мКонс := modConsole,
    мКо := modConstErr,
    мПров := modAssertion;

ТИПЫ
  туИмя* = УКАЗАТЕЛЬ НА тИмя;

  туМодуль* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
    Name: SCAN.туУзел;
    файл_имя: мСтр.тСтрока;
    спис_имен: мСпис.туСписок;
    спис_импорта: мСпис.туСписок;
    IdentBegin: туИмя;
    scanner: SCAN.туСканер;
    уровень*: ЦЕЛОЕ;
    закрытый, typedecl, экспорт_типов, Std, системный: БУЛЕВО
  КОНЕЦ;

  тИмя* = ЗАПИСЬ (мСпис.тУзел)
    Name: SCAN.туУзел;
    тип*: мТипы.туТип;
    модуль*: туМодуль;
    предок*: туИмя;
    двЗнач*: ДЛИНВЕЩ;
    строка*, col*, Number*, iType*, StProc*, VarSize, ParamSize*,
    LocalSize*, Offset*, VarKind*, уровень*, ParamCount*: ЦЕЛОЕ;
    Export: БУЛЕВО
  КОНЕЦ;

  tpPtrBase = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
    Name: SCAN.туУзел;
    строка, col: ЦЕЛОЕ;
    Ptr: мТипы.туТип
  КОНЕЦ;

  туИмяСтрока = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
    строка: мСтр.тСтрока
  КОНЕЦ;

  FIELD* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
    Name: SCAN.туУзел;
    тип*: мТипы.туТип;
    Offset*: ЦЕЛОЕ;
    ByRef*, Export*: БУЛЕВО;
    модуль*: туМодуль
  КОНЕЦ;

  STRCONST* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
    строка*: мСтр.тСтрока;
    Len*, Number*: ЦЕЛОЕ
  КОНЕЦ;

  тВыражение* = ЗАПИСЬ
    id*: DECL.туИмя;
    тип*: мТипы.туТип;
    eType*: ЦЕЛОЕ;
    двЗнач*: ДЛИНВЕЩ;
    Read*, vparam*, deref*: БУЛЕВО
  КОНЕЦ;

  opPROC = ПРОЦЕДУРА;
  expPROC = ПРОЦЕДУРА (ПЕРЕМ e: тВыражение);
  assPROC = ПРОЦЕДУРА (e: DECL.тВыражение; T: мТипы.туТип; param: БУЛЕВО): БУЛЕВО;

  stTYPES* = МАССИВ 11 ИЗ мТипы.туТип;

ПЕРЕМ

  sttypes: stTYPES;
  модуль_текущ*, sys: туМодуль;
  curBlock*: туИмя;
  Path, Main, Std, ExtMain: мСтр.тСтрока;
  NamePtrBase: SCAN.туУзел; ProgSize*, RecCount, модуль_ном*: ЦЕЛОЕ;
  PtrBases, Strings, types, prog: мСпис.туСписок;
  OpSeq: opPROC;
  Expr: expPROC;
  AssComp: assPROC;
  main, sizefunc, winplatf, Const*: БУЛЕВО;
  pParseType: ПРОЦЕДУРА (ПЕРЕМ line, col: ЦЕЛОЕ): мТипы.туТип;
  прМодуль_Прочитать: ПРОЦЕДУРА (Path, Name, Ext: мСтр.тСтрока): БУЛЕВО;
  платформа: ЦЕЛОЕ;

ПРОЦЕДУРА ПроцедурРазм_Уст*;
    НАЧАЛО
      sizefunc := ИСТИНА
    КОНЕЦ ПроцедурРазм_Уст;

ПРОЦЕДУРА MemErr*(err: БУЛЕВО);
    НАЧАЛО
      ЕСЛИ err ТОГДА
        мОш.MemErr(err)
      КОНЕЦ
    КОНЕЦ MemErr;

ПРОЦЕДУРА Стр_Получ*(двЗнач_: ДЛИНВЕЩ): STRCONST;
    ПЕРЕМ
        строка: STRCONST;
    НАЧАЛО
      SYSTEM.PUT(SYSTEM.ADR(строка), FLOOR(двЗнач_))
      ВЕРНУТЬ строка
    КОНЕЦ Стр_Получ;

ПРОЦЕДУРА AddString*(str: мСтр.тСтрока): STRCONST;
    ПЕРЕМ nov: STRCONST;
    НАЧАЛО
      НОВ(nov);
      MemErr(nov = ПУСТО);
      COPY(str, nov.строка);
      nov.Len := SCAN.count - 1;
      nov.Number := X86.NewLabel();
      мСпис.Добавить(Strings, nov);
      X86.String(nov.Number, nov.Len, nov.строка)
      ВЕРНУТЬ nov
    КОНЕЦ AddString;

ПРОЦЕДУРА AddMono*(c: СИМВ): STRCONST;
    ПЕРЕМ nov: STRCONST;
    НАЧАЛО
      НОВ(nov);
      MemErr(nov = ПУСТО);
      nov.строка[0] := c;
      nov.строка[1] := 0X;
      nov.Len := 1;
      nov.Number := X86.NewLabel();
      мСпис.Добавить(Strings, nov);
      X86.String(nov.Number, nov.Len, nov.строка)
      ВЕРНУТЬ nov
    КОНЕЦ AddMono;

ПРОЦЕДУРА Coord(ПЕРЕМ line, col: ЦЕЛОЕ);
    НАЧАЛО
      line := SCAN.строка_ном;
      col := SCAN.позиц_глоб
    КОНЕЦ Coord;

ПРОЦЕДУРА Модуль_Получ(Name: SCAN.туУзел): туМодуль;
    ПЕРЕМ cur, res: туМодуль;
    НАЧАЛО
      res := ПУСТО;
      cur := prog.первый(туМодуль);
      ПОКА (cur # ПУСТО) & мУтиль.Стр_соединить(cur.Name.имя_узла, Name.имя_узла) ДЕЛАТЬ
        res := cur;
        cur := ПУСТО
      ИЛЕСЛ cur # ПУСТО ДЕЛАТЬ
        cur := cur.следующ(туМодуль)
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ Модуль_Получ;

ПРОЦЕДУРА Лексем_Дальше*;
    НАЧАЛО
      SCAN.Лексем_Получ;
      ЕСЛИ (SCAN.лекс_тип > мКонст._lexERR0) & (SCAN.лекс_тип < мКонст._lexERR20) ТОГДА
        мПров.Проверить(ЛОЖЬ, SCAN.строка_ном, SCAN.позиц_глоб + SCAN.count, SCAN.лекс_тип - мКонст._lexERR0)
      КОНЕЦ;
      мПров.Проверить2(SCAN.лекс_тип # мКонст._лекКонФл, мКо._ош18)
    КОНЕЦ Лексем_Дальше;

ПРОЦЕДУРА Проверить*(key: ЦЕЛОЕ);
    ПЕРЕМ code: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ SCAN.лекс_тип # key ТОГДА
        ВЫБРАТЬ key ИЗ
        |мКонст._лекМодуль:  code := 12
        |мКонст._лекИмя:     code := 13
        |мКонст._опТчкЗпт:    code := 14
        |мКонст._лекКонец:     code := 15
        |мКонст._лекТочка:     code := 16
        |мКонст._опРавно:      code := 26
        |мКонст._опСкобПравКруг:  code := 29
        |мКонст._lexTO:      code := 31
        |мКонст._lexOF:      code := 32
        |мКонст._опСкобФигурПрав:  code := 42
        |мКонст._lexLRound:  code := 47
        |мКонст._опЗпт:   code := 52
        |мКонст._лекТогда:    code := 89
        |мКонст._опСкобПравКв: code := 100
        |мКонст._lexDO:      code := 109
        |мКонст._лекСнова:   code := 110
        |мКонст._lexAssign:  code := 111
        |мКонст._лекВернуть:  code := 115
        |мКонст._опДвеТчк:   code := 135
        ИНАЧЕ
        КОНЕЦ;
        мПров.Проверить2(ЛОЖЬ, code)
      КОНЕЦ
    КОНЕЦ Проверить;

ПРОЦЕДУРА CheckIdent(Name: SCAN.туУзел): БУЛЕВО;
    ПЕРЕМ cur: туИмя;
    НАЧАЛО
      cur := модуль_текущ.спис_имен.последний(туИмя);
      ПОКА (cur.iType # мКонст._IDGUARD) & (cur.Name # Name) ДЕЛАТЬ
        cur := cur.предыдущ(туИмя)
      КОНЕЦ
      ВЕРНУТЬ cur.iType = мКонст._IDGUARD
    КОНЕЦ CheckIdent;

ПРОЦЕДУРА Guard;
    ПЕРЕМ ident: туИмя;
    НАЧАЛО
      НОВ(ident);
      MemErr(ident = ПУСТО);
      ident.Name := ПУСТО;
      ident.iType := мКонст._IDGUARD;
      ident.тип := sttypes[мКонст._TVOID];
      мСпис.Добавить(модуль_текущ.спис_имен, ident);
      ДОБ(модуль_текущ.уровень)
    КОНЕЦ Guard;

ПРОЦЕДУРА PushIdent(Name: SCAN.туУзел; line, col, iType: ЦЕЛОЕ; T: мТипы.туТип; u: туМодуль; Export: БУЛЕВО; StProc: ЦЕЛОЕ);
    ПЕРЕМ ident: туИмя; i: ЦЕЛОЕ;
    НАЧАЛО
      мПров.Проверить(CheckIdent(Name), line, col, мКо._ош21);
      НОВ(ident);
      MemErr(ident = ПУСТО);
      ident.Name := Name;
      ident.строка := line;
      ident.col := col;
      ЕСЛИ iType ВХОДИТ {мКонст._имяПроц, мКонст._IDMOD} ТОГДА
        ident.Number := X86.NewLabel();
        i := X86.NewLabel();
        i := X86.NewLabel();
        i := X86.NewLabel()
      КОНЕЦ;
      ident.iType := iType;
      ident.тип := T;
      ident.модуль := u;
      ident.Export := Export;
      ident.StProc := StProc;
      ident.уровень := модуль_текущ.уровень;
      мСпис.Добавить(модуль_текущ.спис_имен, ident)
    КОНЕЦ PushIdent;

ПРОЦЕДУРА StTypes;
    ПЕРЕМ type: мТипы.туТип; i: ЦЕЛОЕ;
    НАЧАЛО
      sttypes[0] := ПУСТО;
      ДЛЯ i := мКонст._тЦелое НА мКонст._тСтрока ДЕЛАТЬ
        НОВ(type);
        MemErr(type = ПУСТО);
        type.тип_узла := i;
        мСпис.Добавить(types, type);
        sttypes[i] := type
      КОНЕЦ;
      sttypes[мКонст._тЦелое].размер := 4;
      sttypes[мКонст._тВеществ].размер := 4;
      sttypes[мКонст._тДлинВещ].размер := 8;
      sttypes[мКонст._тБулево].размер := 1;
      sttypes[мКонст._тСимвол].размер := 1;
      sttypes[мКонст._TSET].размер := 4;
      sttypes[мКонст._TVOID].размер := 0;
      sttypes[мКонст._тСтрока].размер := 0;
      sttypes[мКонст._тПусто].размер := 4;
      sttypes[мКонст._TCARD16].размер := 2;
      ДЛЯ i := мКонст._тЦелое НА мКонст._тСтрока ДЕЛАТЬ
        sttypes[i].выравн := sttypes[i].размер
      КОНЕЦ
    КОНЕЦ StTypes;

ПРОЦЕДУРА PushStProc(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
    НАЧАЛО
      PushIdent(SCAN.Узел_Добавить(Name), 0, 0, мКонст._IDSTPROC, sttypes[мКонст._TVOID], ПУСТО, ЛОЖЬ, StProc)
    КОНЕЦ PushStProc;

ПРОЦЕДУРА PushStType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
    НАЧАЛО
      PushIdent(SCAN.Узел_Добавить(Name), 0, 0, мКонст._имяТипа, sttypes[T], ПУСТО, ЛОЖЬ, 0)
    КОНЕЦ PushStType;

ПРОЦЕДУРА ПроцСис_Сохр(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
    НАЧАЛО
      PushIdent(SCAN.Узел_Добавить(Name), 0, 0, мКонст._имяСисПроц, sttypes[мКонст._TVOID], ПУСТО, ИСТИНА, StProc)
    КОНЕЦ ПроцСис_Сохр;

ПРОЦЕДУРА PushSysType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
    НАЧАЛО
      PushIdent(SCAN.Узел_Добавить(Name), 0, 0, мКонст._имяТипа, sttypes[T], ПУСТО, ИСТИНА, 0)
    КОНЕЦ PushSysType;

ПРОЦЕДУРА ИмяВнутр_Уст;
    НАЧАЛО
        Guard;
        PushStProc(мКонст._ангАбсолютный,      мКонст._stABS);
        PushStProc(мКонст._русАбсолютный,      мКонст._stABS);

        PushStProc("ASR",      мКонст._stASR);

        PushStProc(мКонст._ангПроверить,   мКонст._stASSERT);
        PushStProc(мКонст._русПроверить,   мКонст._stASSERT);

        PushStType(мКонст._ангБулево,  мКонст._тБулево);
        PushStType(мКонст._русБулево,  мКонст._тБулево);

        PushStType(мКонст._ангСимвол,     мКонст._тСимвол);
        PushStType(мКонст._русСимвол,     мКонст._тСимвол);

        PushStProc("CHR",      мКонст._stCHR);
        PushStProc("COPY",     мКонст._stCOPY);

        PushStProc(мКонст._ангДекремент,      мКонст._stDEC);
        PushStProc(мКонст._русДекремент,      мКонст._stDEC);

        PushStProc("DISPOSE",  мКонст._stDISPOSE);
        PushStProc("EXCL",     мКонст._stEXCL);
        PushStProc("FLOOR",    мКонст._stFLOOR);
        PushStProc("FLT",      мКонст._stFLT);

        PushStProc(мКонст._ангИнкремент,      мКонст._stINC);
        PushStProc(мКонст._русИнкремент,      мКонст._stINC);

        PushStProc("INCL",     мКонст._stINCL);

        PushStType(мКонст._ангЦелое,  мКонст._тЦелое);
        PushStType(мКонст._русЦелое,  мКонст._тЦелое);

        PushStProc("LEN",      мКонст._stLEN);
        PushStProc("LSL",      мКонст._stLSL);

        PushStProc(мКонст._ангДлинное,     мКонст._stLONG);
        PushStProc(мКонст._русДлинное,     мКонст._stLONG);

        PushStType(мКонст._ангДлинВещ, мКонст._тДлинВещ);
        PushStType(мКонст._русДлинВещ, мКонст._тДлинВещ);

        PushStProc(мКонст._ангНовый,      мКонст._stNEW);
        PushStProc(мКонст._русНовый,      мКонст._stNEW);

        PushStProc("ODD",      мКонст._stODD);
        PushStProc("ORD",      мКонст._stORD);
        PushStProc("PACK",     мКонст._stPACK);

        PushStType(мКонст._ангВещ,     мКонст._тВеществ);
        PushStType(мКонст._русВещ,     мКонст._тВеществ);

        PushStProc("ROR",      мКонст._stROR);
        PushStType("SET",      мКонст._TSET);

        PushStProc(мКонст._ангУкоротить,    мКонст._stSHORT);
        PushStProc(мКонст._русУкоротить,    мКонст._stSHORT);

        PushStProc("UNPK",     мКонст._stUNPK);
        PushStProc("BITS",     мКонст._stBITS);
        PushStProc("LSR",      мКонст._stLSR);
        PushStProc("LENGTH",   мКонст._stLENGTH);
        Guard
    КОНЕЦ ИмяВнутр_Уст;

ПРОЦЕДУРА GetQIdent*(Unit: туМодуль; Name: SCAN.туУзел): туИмя;
    ПЕРЕМ cur, res: туИмя; line, col: ЦЕЛОЕ;
    НАЧАЛО
      res := ПУСТО;
      Coord(line, col);
      cur := Unit.IdentBegin.следующ(туИмя);
      ПОКА (cur # ПУСТО) & (cur.iType # мКонст._IDGUARD) ДЕЛАТЬ
        ЕСЛИ cur.Name = Name ТОГДА
          ЕСЛИ (Unit # модуль_текущ) & ~cur.Export ТОГДА
            res := ПУСТО
          ИНАЧЕ
            res := cur
          КОНЕЦ;
          cur := ПУСТО
        ИНАЧЕ
          cur := cur.следующ(туИмя)
        КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ GetQIdent;

ПРОЦЕДУРА GetIdent*(Name: SCAN.туУзел): туИмя;
    ПЕРЕМ cur, res: туИмя; line, col: ЦЕЛОЕ;
    НАЧАЛО
      res := ПУСТО;
      Coord(line, col);
      cur := модуль_текущ.спис_имен.последний(туИмя);
      ПОКА (cur # ПУСТО) & (cur.Name = Name) ДЕЛАТЬ
        res := cur;
        cur := ПУСТО
      ИЛЕСЛ cur # ПУСТО ДЕЛАТЬ
        cur := cur.предыдущ(туИмя)
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ GetIdent;

ПРОЦЕДУРА Отношен_Проверить*(Op: ЦЕЛОЕ): БУЛЕВО;
    ПЕРЕМ Res: БУЛЕВО;
    НАЧАЛО
      ВЫБРАТЬ Op ИЗ
      |мКонст._опРавно, мКонст._опНеРавно, мКонст._опМеньше, мКонст._опБольше,
       мКонст._lexLE, мКонст._lexGE, мКонст._лекВходит, мКонст._лекЕсть:
        Res := ИСТИНА
      ИНАЧЕ
        Res := ЛОЖЬ
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ Отношен_Проверить;

ПРОЦЕДУРА Arith(a, b: ДЛИНВЕЩ; T: мТипы.туТип; Op, line, col: ЦЕЛОЕ): ДЛИНВЕЩ;
    КОНСТ
        max = мКонст._maxDBL;
    ПЕРЕМ
        res: ДЛИНВЕЩ;
    НАЧАЛО
        ВЫБРАТЬ Op ИЗ
            |мКонст._опПлюс: res := a + b
            |мКонст._опМинус: res := a - b
            |мКонст._опУмнож: res := a * b
            |мКонст._опДел:
                мПров.Проверить(b # 0.0D0, line, col, мКо._ош37);
                res := a / b
            |мКонст._lexDIV:
                мПров.Проверить(~((a = ДЛИН(FLT(мКонст._minINT))) & (b = -1.0D0)), line, col,  мКо._ош5);
                res := ДЛИН(FLT(FLOOR(a) DIV FLOOR(b)))
            |мКонст._lexMOD:
                res := ДЛИН(FLT(FLOOR(a) MOD FLOOR(b)))
        ИНАЧЕ
        КОНЕЦ;
        мПров.Проверить(~мУтиль.ЕслиБесконеч(res), line, col,  мКо._ош7);
        ВЫБРАТЬ T.тип_узла ИЗ
            |мКонст._тЦелое:  мПров.Проверить((res <= ДЛИН(FLT(мКонст._maxINT))) &
                    (res >= ДЛИН(FLT(мКонст._minINT))), line, col, мКо._ош5)
            |мКонст._тВеществ: мПров.Проверить((res <= ДЛИН(мКонст._maxREAL)) & (res >= -ДЛИН(мКонст._maxREAL)),
                    line, col, мКо._ош7)
            |мКонст._тДлинВещ: мПров.Проверить((res <= max) & (res >= -max), line, col, мКо._ош7)
        ИНАЧЕ
        КОНЕЦ;
        ЕСЛИ (res = 0.0D0) & (T.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ}) ИЛИ (ABS(res) < ДЛИН(мКонст._minREAL)) & (T.тип_узла = мКонст._тВеществ) ТОГДА
            ВЫБРАТЬ Op ИЗ
                |мКонст._опПлюс:  мПров.Проверить(a = -b, line, col, мКо._ош9)
                |мКонст._опМинус: мПров.Проверить(a = b, line, col, мКо._ош9)
                |мКонст._опУмнож:  мПров.Проверить((a = 0.0D0) ИЛИ (b = 0.0D0), line, col, мКо._ош9)
                |мКонст._опДел: мПров.Проверить((a = 0.0D0), line, col, мКо._ош9)
            ИНАЧЕ
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ res
    КОНЕЦ Arith;

ПРОЦЕДУРА strcmp(a, b: ДЛИНВЕЩ; Op: ЦЕЛОЕ): ДЛИНВЕЩ;
    ПЕРЕМ sa, sb: STRCONST; Res: ДЛИНВЕЩ;
    НАЧАЛО
      sa := Стр_Получ(a);
      sb := Стр_Получ(b);
      ВЫБРАТЬ Op ИЗ
      |мКонст._опРавно, мКонст._опНеРавно: Res := ДЛИН(FLT(ORD(sa.строка = sb.строка)))
      |мКонст._опМеньше, мКонст._опБольше: Res := ДЛИН(FLT(ORD(sa.строка < sb.строка)))
      |мКонст._lexLE, мКонст._lexGE: Res := ДЛИН(FLT(ORD(sa.строка <= sb.строка)))
      ИНАЧЕ
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ strcmp;

ПРОЦЕДУРА Calc*(a, b: ДЛИНВЕЩ; Ta, Tb: мТипы.туТип; Op, line, col: ЦЕЛОЕ; ПЕРЕМ Res: ДЛИНВЕЩ; ПЕРЕМ TRes: мТипы.туТип);
    ПЕРЕМ c: ДЛИНВЕЩ; ai, bi: ЦЕЛОЕ;
    НАЧАЛО
      ai := FLOOR(a);
      bi := FLOOR(b);
      ЕСЛИ Op # мКонст._лекВходит ТОГДА
        мПров.Проверить(Ta = Tb, line, col, мКо._ош28)
      КОНЕЦ;
      ВЫБРАТЬ Op ИЗ
      |мКонст._опПлюс, мКонст._опМинус, мКонст._опУмнож, мКонст._опДел:
            мПров.Проверить(~((Op = мКонст._опДел) & (Ta.тип_узла = мКонст._тЦелое)), line, col, мКо._ош28);
            ЕСЛИ Ta.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ} ТОГДА
                Res := Arith(a, b, Ta, Op, line, col)
            ИЛЕСЛ Ta.тип_узла = мКонст._TSET ТОГДА
                ВЫБРАТЬ Op ИЗ
                    |мКонст._опПлюс:  Res := ДЛИН(FLT(ORD(BITS(ai) + BITS(bi))))
                    |мКонст._опМинус: Res := ДЛИН(FLT(ORD(BITS(ai) - BITS(bi))))
                    |мКонст._опУмнож:  Res := ДЛИН(FLT(ORD(BITS(ai) * BITS(bi))))
                    |мКонст._опДел: Res := ДЛИН(FLT(ORD(BITS(ai) / BITS(bi))))
                ИНАЧЕ
                КОНЕЦ
            ИНАЧЕ
                мПров.Проверить(ЛОЖЬ, line, col, мКо._ош28)
            КОНЕЦ;
            TRes := Ta
      |мКонст._lexDIV, мКонст._lexMOD:
        мПров.Проверить(Ta.тип_узла = мКонст._тЦелое, line, col, мКо._ош28);
        мПров.Проверить(bi # 0, line, col, мКо._ош39);
        TRes := Ta;
        Res := Arith(a, b, Ta, Op, line, col)
      |мКонст._опКомерцИ:
        мПров.Проверить(Ta.тип_узла = мКонст._тБулево, line, col, мКо._ош28);
        Res := ДЛИН(FLT(ORD((ai # 0) & (bi # 0))))
      |мКонст._лекИли:
        мПров.Проверить(Ta.тип_узла = мКонст._тБулево, line, col, мКо._ош28);
        Res := ДЛИН(FLT(ORD((ai # 0) ИЛИ (bi # 0))))
      |мКонст._опРавно, мКонст._опНеРавно:
        ЕСЛИ Ta.тип_узла = мКонст._тСтрока ТОГДА
          Res := strcmp(a, b, Op)
        ИНАЧЕ
          Res := ДЛИН(FLT(ORD(a = b)))
        КОНЕЦ;
        ЕСЛИ Op = мКонст._опНеРавно ТОГДА
          Res := ДЛИН(FLT(ORD(Res = 0.0D0)))
        КОНЕЦ
      |мКонст._опМеньше, мКонст._опБольше:
        ЕСЛИ Op = мКонст._опБольше ТОГДА
          c := a;
          a := b;
          b := c
        КОНЕЦ;
        мПров.Проверить(Ta.тип_узла ВХОДИТ {мКонст._тСтрока, мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ},
                line, col, мКо._ош28);
        ЕСЛИ Ta.тип_узла = мКонст._тСтрока ТОГДА
          Res := strcmp(a, b, Op)
        ИНАЧЕ
          Res := ДЛИН(FLT(ORD(a < b)))
        КОНЕЦ
      |мКонст._lexLE, мКонст._lexGE:
        ЕСЛИ Op = мКонст._lexGE ТОГДА
          c := a;
          a := b;
          b := c
        КОНЕЦ;
        мПров.Проверить(Ta.тип_узла ВХОДИТ {мКонст._тСтрока, мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ,
                мКонст._TSET}, line, col, мКо._ош28);
        ЕСЛИ Ta.тип_узла = мКонст._тСтрока ТОГДА
          Res := strcmp(a, b, Op)
        ИЛЕСЛ Ta.тип_узла = мКонст._TSET ТОГДА
          Res := ДЛИН(FLT(ORD(BITS(FLOOR(a)) <= BITS(FLOOR(b)))))
        ИНАЧЕ
          Res := ДЛИН(FLT(ORD(a <= b)))
        КОНЕЦ
      |мКонст._лекВходит:
        мПров.Проверить((Ta.тип_узла = мКонст._тЦелое) & (Tb.тип_узла = мКонст._TSET), line, col, мКо._ош28);
        мПров.Проверить(ASR(ai, 5) = 0, line, col, мКо._ош40);
        Res := ДЛИН(FLT(ORD(ai ВХОДИТ BITS(bi))))
      ИНАЧЕ
      КОНЕЦ;
      ЕСЛИ Отношен_Проверить(Op) ИЛИ (Op = мКонст._опКомерцИ) ИЛИ (Op = мКонст._лекИли) ТОГДА
        TRes := sttypes[мКонст._тБулево]
      КОНЕЦ
    КОНЕЦ Calc;

ПРОЦЕДУРА ConstExpr*(ПЕРЕМ Value: ДЛИНВЕЩ; ПЕРЕМ T: мТипы.туТип);
    ПЕРЕМ e: тВыражение; line, col: ЦЕЛОЕ;
    НАЧАЛО
      Const := ИСТИНА;
      Coord(line, col);
      sizefunc := ЛОЖЬ;
      Expr(e);
      мПров.Проверить(~sizefunc & (e.eType = мКонст._выражКонст), line, col, мКо._ош53);
      Value := e.двЗнач;
      T := e.тип;
      Const := ЛОЖЬ
    КОНЕЦ ConstExpr;

ПРОЦЕДУРА IdType*(ПЕРЕМ line, col: ЦЕЛОЕ): мТипы.туТип;
    ПЕРЕМ id: туИмя; Name: SCAN.туУзел; Unit: туМодуль; Res: мТипы.туТип;
    НАЧАЛО
      Res := ПУСТО;
      Name := SCAN.id;
      id := GetIdent(Name);
      ЕСЛИ id = ПУСТО ТОГДА
        Coord(line, col);
        NamePtrBase := Name;
        Лексем_Дальше
      ИНАЧЕ
        ЕСЛИ id.iType = мКонст._имяТипа ТОГДА
          Coord(line, col);
          Лексем_Дальше;
          Res := id.тип
        ИЛЕСЛ id.iType = мКонст._IDMOD ТОГДА
          Unit := id.модуль;
          Лексем_Дальше;
          Проверить(мКонст._лекТочка);
          Лексем_Дальше;
          Проверить(мКонст._лекИмя);
          Name := SCAN.id;
          NamePtrBase := Name;
          id := GetQIdent(Unit, Name);
          ЕСЛИ Unit # модуль_текущ ТОГДА
            мПров.Проверить2(id # ПУСТО, мКо._ош33);
            мПров.Проверить2(id.iType = мКонст._имяТипа, мКо._ош68);
            Coord(line, col);
            Лексем_Дальше;
            Res := id.тип
          ИНАЧЕ
            ЕСЛИ id = ПУСТО ТОГДА
              мПров.Проверить2((модуль_текущ.уровень = 3) & модуль_текущ.typedecl, мКо._ош33);
              Coord(line, col);
              Лексем_Дальше;
              Res := ПУСТО
            ИНАЧЕ
              мПров.Проверить2(id.iType = мКонст._имяТипа, мКо._ош68);
              Coord(line, col);
              Лексем_Дальше;
              Res := id.тип
            КОНЕЦ
          КОНЕЦ
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош68)
        КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ IdType;

ПРОЦЕДУРА FieldOffset(Align, RecSize: ЦЕЛОЕ): ЦЕЛОЕ;
    НАЧАЛО
      мПров.Проверить2(RecSize <= мКонст._maxINT - (Align - RecSize MOD Align) MOD Align, мКо._ош74)
      ВЕРНУТЬ RecSize + (Align - RecSize MOD Align) MOD Align
    КОНЕЦ FieldOffset;

ПРОЦЕДУРА SetFields(Tr, Tf: мТипы.туТип; Rec: БУЛЕВО);
    ПЕРЕМ cur: FIELD;
    НАЧАЛО
      cur := Tr.поля.первый(FIELD);
      ПОКА cur.тип # ПУСТО ДЕЛАТЬ
        cur := cur.следующ(FIELD)
      КОНЕЦ;
      ПОКА cur # ПУСТО ДЕЛАТЬ
        cur.тип := Tf;
        ЕСЛИ Rec ТОГДА
          ЕСЛИ Tf.выравн > Tr.выравн ТОГДА
            Tr.выравн := Tf.выравн
          КОНЕЦ;
          ЕСЛИ Tr.запись = мКонст._record ТОГДА
            cur.Offset := FieldOffset(Tf.выравн, Tr.размер);
            мПров.Проверить2(cur.Offset <= мКонст._maxINT - Tf.размер, мКо._ош74);
            Tr.размер := cur.Offset + Tf.размер
          ИЛЕСЛ Tr.запись = мКонст._noalign ТОГДА
            cur.Offset := FieldOffset(1, Tr.размер);
            мПров.Проверить2(cur.Offset <= мКонст._maxINT - Tf.размер, мКо._ош74);
            Tr.размер := cur.Offset + Tf.размер
          ИЛЕСЛ Tr.запись = мКонст._union ТОГДА
            ЕСЛИ Tf.размер > Tr.размер ТОГДА
              Tr.размер := Tf.размер
            КОНЕЦ;
            cur.Offset := 0
          КОНЕЦ
        ИНАЧЕ
          Tr.глубина := Tr.глубина + 4 * (ORD((Tf.тип_узла = мКонст._тЗапись) & cur.ByRef) + мТипы.Глубина_Получ(Tf) + ORD((Tf.тип_узла = мКонст._тДлинВещ) & ~cur.ByRef) + 1)
        КОНЕЦ;
        cur := cur.следующ(FIELD)
      КОНЕЦ
    КОНЕЦ SetFields;

ПРОЦЕДУРА GetField*(T: мТипы.туТип; Name: SCAN.туУзел): FIELD;
    ПЕРЕМ cur, Res: FIELD;
    НАЧАЛО
      Res := ПУСТО;
      cur := T.поля.первый(FIELD);
      ПОКА (cur # ПУСТО) & (cur.Name = Name) ДЕЛАТЬ
        Res := cur;
        cur := ПУСТО
      ИЛЕСЛ cur # ПУСТО ДЕЛАТЬ
        cur := cur.следующ(FIELD)
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ GetField;

ПРОЦЕДУРА Unique(T: мТипы.туТип; Name: SCAN.туУзел): БУЛЕВО;
    ПЕРЕМ field: FIELD; res: БУЛЕВО;
    НАЧАЛО
      res := ИСТИНА;
      ПОКА (T # ПУСТО) & res ДЕЛАТЬ
        field := GetField(T, Name);
        ЕСЛИ field # ПУСТО ТОГДА
          ЕСЛИ (field.модуль = модуль_текущ) ИЛИ field.Export ТОГДА
            res := ЛОЖЬ
          КОНЕЦ
        КОНЕЦ;
        T := T.предок
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ Unique;

ПРОЦЕДУРА notrecurs(id: БУЛЕВО; T: мТипы.туТип): БУЛЕВО;
      ВЕРНУТЬ ~(id & (модуль_текущ.спис_имен.последний(туИмя).iType = мКонст._имяТипа) & (модуль_текущ.спис_имен.последний(туИмя).тип = T) &
              (T.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тМассив}))
    КОНЕЦ notrecurs;

ПРОЦЕДУРА ReadFields(T: мТипы.туТип);
    ПЕРЕМ
        Name: SCAN.туУзел; field: FIELD; Tf: мТипы.туТип; line, col: ЦЕЛОЕ; id_T: БУЛЕВО;
    НАЧАЛО
      ПОКА SCAN.лекс_тип = мКонст._лекИмя ДЕЛАТЬ
        Name := SCAN.id;
        мПров.Проверить2(Unique(T, Name), мКо._ош21);
        НОВ(field);
        MemErr(field = ПУСТО);
        мСпис.Добавить(T.поля, field);
        field.Name := Name;
        field.тип := ПУСТО;
        field.Export := ЛОЖЬ;
        field.модуль := модуль_текущ;
        Лексем_Дальше;
        ЕСЛИ SCAN.лекс_тип = мКонст._опУмнож ТОГДА
          мПров.Проверить2(модуль_текущ.уровень = 3, мКо._ош80);
          мПров.Проверить2(модуль_текущ.typedecl, мКо._ош82);
          мПров.Проверить2(модуль_текущ.экспорт_типов, мКо._ош83);
          field.Export := ИСТИНА;
          Лексем_Дальше
        КОНЕЦ;
        ЕСЛИ SCAN.лекс_тип = мКонст._опЗпт ТОГДА
          Лексем_Дальше;
          Проверить(мКонст._лекИмя)
        ИЛЕСЛ SCAN.лекс_тип = мКонст._опДвеТчк ТОГДА
          Лексем_Дальше;
          Coord(line, col);
          id_T := SCAN.лекс_тип = мКонст._лекИмя;
          Tf:= pParseType(line, col);
          мПров.Проверить(Tf # ПУСТО, line, col, мКо._ош33);
          мПров.Проверить(notrecurs(id_T, Tf), line, col, мКо._ош87);
          SetFields(T, Tf, ИСТИНА);
          ЕСЛИ SCAN.лекс_тип = мКонст._опТчкЗпт ТОГДА
            Лексем_Дальше;
            Проверить(мКонст._лекИмя)
          ИНАЧЕ
            мПров.Проверить2(SCAN.лекс_тип = мКонст._лекКонец, мКо._ош77)
          КОНЕЦ
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош76)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ ReadFields;

ПРОЦЕДУРА OpenBase*(T: мТипы.туТип): мТипы.туТип;
    НАЧАЛО
      ПОКА (T.тип_узла = мКонст._тМассив) & (T.глубина = 0) ДЕЛАТЬ
        T := T.предок
      КОНЕЦ
      ВЕРНУТЬ T
    КОНЕЦ OpenBase;

ПРОЦЕДУРА SetVars(T: мТипы.туТип);
    ПЕРЕМ cur: туИмя; n: ЦЕЛОЕ;
    НАЧАЛО
      cur := модуль_текущ.спис_имен.последний(туИмя);
      ПОКА cur.тип = ПУСТО ДЕЛАТЬ
        cur := cur.предыдущ(туИмя)
      КОНЕЦ;
      cur := cur.следующ(туИмя);
      ПОКА cur # ПУСТО ДЕЛАТЬ
        cur.тип := T;
        ЕСЛИ cur.Export ТОГДА
          мПров.Проверить(~(T.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тМассив}), cur.строка, cur.col, мКо._ош81)
        КОНЕЦ;
        ЕСЛИ(cur.VarKind = мКонст._param_var) ИЛИ (cur.VarKind = мКонст._param) & (T.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тМассив}) ТОГДА
          n := 4 * (1 + мТипы.Глубина_Получ(T) + ORD((cur.VarKind = мКонст._param_var) & (T.тип_узла = мКонст._тЗапись)))
        ИНАЧЕ
          n := T.размер;
          мПров.Проверить2(n <= мКонст._maxINT - мУтиль.Выровнять(n), мКо._ош84);
          n := n + мУтиль.Выровнять(n)
        КОНЕЦ;
        ЕСЛИ cur.уровень = 3 ТОГДА
          cur.Offset := ProgSize;
          мПров.Проверить2(ProgSize <= мКонст._maxINT - n, мКо._ош84);
          ProgSize := ProgSize + n;
          мПров.Проверить2(ProgSize <= мКонст._maxINT - мУтиль.Выровнять(ProgSize), мКо._ош84);
          ProgSize := ProgSize + мУтиль.Выровнять(ProgSize)
        ИНАЧЕ
          ЕСЛИ cur.VarKind = 0 ТОГДА
            cur.Offset := curBlock.ParamSize - curBlock.VarSize - n
          ИНАЧЕ
            cur.Offset := curBlock.VarSize - 8 + 4 * (cur.уровень + ORD((cur.VarKind = мКонст._param_var) & (T.тип_узла = мКонст._тЗапись)))
          КОНЕЦ
        КОНЕЦ;
        мПров.Проверить2(curBlock.VarSize <= мКонст._maxINT - n, мКо._ош84);
        curBlock.VarSize := curBlock.VarSize + n;
        мПров.Проверить2(curBlock.VarSize <= мКонст._maxINT - мУтиль.Выровнять(curBlock.VarSize), мКо._ош84);
        curBlock.VarSize := curBlock.VarSize + мУтиль.Выровнять(curBlock.VarSize);
        ЕСЛИ cur.VarKind # 0 ТОГДА
          curBlock.ParamSize := curBlock.VarSize
        КОНЕЦ;
        cur := cur.следующ(туИмя)
      КОНЕЦ
    КОНЕЦ SetVars;

ПРОЦЕДУРА CreateType(tType, Len, Size, Number: ЦЕЛОЕ; Base: мТипы.туТип; Fields: БУЛЕВО; NewType: мТипы.туТип): мТипы.туТип;
    ПЕРЕМ nov: мТипы.туТип;
    НАЧАЛО
      ЕСЛИ NewType = ПУСТО ТОГДА
        НОВ(nov);
        MemErr(nov = ПУСТО)
      ИНАЧЕ
        nov := NewType
      КОНЕЦ;
      мСпис.Добавить(types, nov);
      nov.тип_узла := tType;
      nov.глубина := Len;
      nov.размер := Size;
      nov.предок := Base;
      nov.поля := ПУСТО;
      nov.Number := Number;
      ЕСЛИ Fields ТОГДА
        nov.поля := мСпис.Создать();
        MemErr(nov.поля = ПУСТО)
      КОНЕЦ
      ВЕРНУТЬ nov
    КОНЕЦ CreateType;

ПРОЦЕДУРА FormalType(ПЕРЕМ line, col: ЦЕЛОЕ): мТипы.туТип;
    ПЕРЕМ TA: мТипы.туТип;
    НАЧАЛО
      ЕСЛИ SCAN.лекс_тип = мКонст._лекМассив ТОГДА
        Лексем_Дальше;
        Проверить(мКонст._lexOF);
        Лексем_Дальше;
        TA := CreateType(мКонст._тМассив, 0, 0, 0, FormalType(line, col), ЛОЖЬ, ПУСТО)
      ИНАЧЕ
        Проверить(мКонст._лекИмя);
        TA := IdType(line, col);
        мПров.Проверить(TA # ПУСТО, line, col, мКо._ош33);
      КОНЕЦ
      ВЕРНУТЬ TA
    КОНЕЦ FormalType;

ПРОЦЕДУРА Section(T: мТипы.туТип);
    ПЕРЕМ Name: SCAN.туУзел; ByRef, cont: БУЛЕВО; field: FIELD;
        Tf: мТипы.туТип; fp: туИмя; line, col: ЦЕЛОЕ; proc: БУЛЕВО;
    НАЧАЛО
      proc := T = ПУСТО;
      ЕСЛИ proc ТОГДА
        T := curBlock.тип
      КОНЕЦ;
      мПров.Проверить2((SCAN.лекс_тип = мКонст._лекИмя) ИЛИ (SCAN.лекс_тип = мКонст._лекПерем), мКо._ош75);
      ByRef := ЛОЖЬ;
      ЕСЛИ SCAN.лекс_тип = мКонст._лекПерем ТОГДА
        ByRef := ИСТИНА;
        Лексем_Дальше;
        Проверить(мКонст._лекИмя)
      КОНЕЦ;
      cont := ИСТИНА;
      ПОКА cont ДЕЛАТЬ
        Name := SCAN.id;
        мПров.Проверить2(GetField(T, Name) = ПУСТО, мКо._ош21);
        НОВ(field);
        MemErr(field = ПУСТО);
        мСпис.Добавить(T.поля, field);
        field.Name := Name;
        field.тип := ПУСТО;
        field.ByRef := ByRef;
        ЕСЛИ proc ТОГДА
          PushIdent(Name, line, col, мКонст._имяПерем, ПУСТО, ПУСТО, ЛОЖЬ, 0);
          ДОБ(curBlock.ParamCount);
          fp := модуль_текущ.спис_имен.последний(туИмя);
          ЕСЛИ ByRef ТОГДА
            fp.VarKind := мКонст._param_var
          ИНАЧЕ
            fp.VarKind := мКонст._param
          КОНЕЦ
        КОНЕЦ;
        Лексем_Дальше;
        ЕСЛИ SCAN.лекс_тип = мКонст._опЗпт ТОГДА
          Лексем_Дальше;
          Проверить(мКонст._лекИмя)
        ИЛЕСЛ SCAN.лекс_тип = мКонст._опДвеТчк ТОГДА
          Лексем_Дальше;
          Tf := FormalType(line, col);
          мПров.Проверить(мТипы.Глубина_Получ(Tf) <= мКонст._ADIM, line, col, мКо._ош101);
          SetFields(T, Tf, ЛОЖЬ);
          ЕСЛИ proc ТОГДА
            SetVars(Tf)
          КОНЕЦ;
          cont := ЛОЖЬ
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош76)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ Section;

ПРОЦЕДУРА ParamType(T: мТипы.туТип);
    ПЕРЕМ break: БУЛЕВО;
    НАЧАЛО
      ЕСЛИ (SCAN.лекс_тип = мКонст._лекИмя) ИЛИ (SCAN.лекс_тип = мКонст._лекПерем) ТОГДА
        break := ЛОЖЬ;
        ПОВТОРЯТЬ
          Section(T);
          ЕСЛИ SCAN.лекс_тип = мКонст._опТчкЗпт ТОГДА
            Лексем_Дальше
          ИНАЧЕ
            break := ИСТИНА
          КОНЕЦ
        СНОВА break
      КОНЕЦ
    КОНЕЦ ParamType;

ПРОЦЕДУРА AddPtrBase(Name: SCAN.туУзел; line, col: ЦЕЛОЕ; T: мТипы.туТип);
    ПЕРЕМ nov: tpPtrBase;
    НАЧАЛО
      НОВ(nov);
      MemErr(nov = ПУСТО);
      nov.Name := Name;
      nov.строка := line;
      nov.col := col;
      nov.Ptr := T;
      мСпис.Добавить(PtrBases, nov)
    КОНЕЦ AddPtrBase;

ПРОЦЕДУРА FormalList(T: мТипы.туТип; ПЕРЕМ Res: мТипы.туТип);
    ПЕРЕМ line, col: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ SCAN.лекс_тип = мКонст._lexLRound ТОГДА
        Лексем_Дальше;
        ParamType(T);
        Проверить(мКонст._опСкобПравКруг);
        Лексем_Дальше;
        ЕСЛИ SCAN.лекс_тип = мКонст._опДвеТчк ТОГДА
          Лексем_Дальше;
          Проверить(мКонст._лекИмя);
          Res := IdType(line, col);
          мПров.Проверить(Res # ПУСТО, line, col, мКо._ош33);
          мПров.Проверить(~(Res.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тМассив}), line, col, мКо._ош73)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ FormalList;

ПРОЦЕДУРА CallFlag(ПЕРЕМ Call: ЦЕЛОЕ): БУЛЕВО;
    ПЕРЕМ flag: мСтр.тСтрока; res: БУЛЕВО;
    НАЧАЛО
      res := SCAN.лекс_тип = мКонст._опСкобЛевКв;
      ЕСЛИ res ТОГДА
        Лексем_Дальше;
        SCAN.GetLexStr(flag);
        ЕСЛИ flag = "cdecl" ТОГДА
          Call := мКонст._cdecl
        ИЛЕСЛ flag = "stdcall" ТОГДА
          Call := мКонст._stdcall
        ИЛЕСЛ flag = "winapi" ТОГДА
          мПров.Проверить2(winplatf, мКо._ош41);
          Call := мКонст._winapi
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош35)
        КОНЕЦ;
        Лексем_Дальше;
        Проверить(мКонст._опСкобПравКв);
        Лексем_Дальше;
      ИНАЧЕ
        Call := мКонст._defcall
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ CallFlag;

ПРОЦЕДУРА RecFlag(ПЕРЕМ rec: ЦЕЛОЕ): БУЛЕВО;
    ПЕРЕМ flag: мСтр.тСтрока; res: БУЛЕВО;
    НАЧАЛО
      res := SCAN.лекс_тип = мКонст._опСкобЛевКв;
      ЕСЛИ res ТОГДА
        Лексем_Дальше;
        SCAN.GetLexStr(flag);
        ЕСЛИ flag = "union" ТОГДА
          rec := мКонст._union
        ИЛЕСЛ flag = "noalign" ТОГДА
          rec := мКонст._noalign
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош94)
        КОНЕЦ;
        Лексем_Дальше;
        Проверить(мКонст._опСкобПравКв);
        Лексем_Дальше;
      ИНАЧЕ
        rec := мКонст._record
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ RecFlag;

ПРОЦЕДУРА StructType(Comma: БУЛЕВО; NewType: мТипы.туТип): мТипы.туТип;
    ПЕРЕМ v: ДЛИНВЕЩ; T, nov: мТипы.туТип; line, col, line2, col2: ЦЕЛОЕ; id_T: БУЛЕВО;
    НАЧАЛО
      ВЫБРАТЬ SCAN.лекс_тип ИЗ
      |мКонст._лекМассив, мКонст._опЗпт:
        ЕСЛИ SCAN.лекс_тип = мКонст._опЗпт ТОГДА
          мПров.Проверить2(Comma, мКо._ош30)
        КОНЕЦ;
        Лексем_Дальше;
        Coord(line, col);
        ConstExpr(v, T);
        мПров.Проверить(T.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
        мПров.Проверить(v > 0.0D0, line, col, мКо._ош69);
        nov := CreateType(мКонст._тМассив, FLOOR(v), 0, 0, ПУСТО, ЛОЖЬ, NewType);
        ЕСЛИ SCAN.лекс_тип = мКонст._опЗпт ТОГДА
          nov.предок := StructType(ИСТИНА, ПУСТО)
        ИЛЕСЛ SCAN.лекс_тип = мКонст._lexOF ТОГДА
          Лексем_Дальше;
          Coord(line, col);
          id_T := SCAN.лекс_тип = мКонст._лекИмя;
          nov.предок := pParseType(line, col);
          мПров.Проверить(nov.предок # ПУСТО, line, col, мКо._ош33);
          мПров.Проверить(notrecurs(id_T, nov.предок), line, col, мКо._ош87)
        ИНАЧЕ
          мПров.Проверить2(ЛОЖЬ, мКо._ош70)
        КОНЕЦ;
        мПров.Проверить2(nov.предок.размер <= мКонст._maxINT DIV nov.глубина, мКо._ош74);
        nov.размер := nov.предок.размер * nov.глубина;
        nov.выравн := nov.предок.выравн
      |мКонст._лекЗапись:
        Лексем_Дальше;
        ДОБ(RecCount);
        nov := CreateType(мКонст._тЗапись, 0, 0, RecCount, ПУСТО, ИСТИНА, NewType);
        nov.выравн := 1;
        Coord(line, col);
        ЕСЛИ RecFlag(nov.запись) ТОГДА
          мПров.Проверить(модуль_текущ.системный, line, col, мКо._ош102)
        КОНЕЦ;
        Coord(line, col);
        ЕСЛИ SCAN.лекс_тип = мКонст._lexLRound ТОГДА
          Лексем_Дальше;
          Coord(line2, col2);
          Проверить(мКонст._лекИмя);
          nov.предок := IdType(line, col);
          мПров.Проверить(nov.предок # ПУСТО, line, col, мКо._ош42);
          мПров.Проверить(nov.предок.тип_узла = мКонст._тЗапись, line, col, мКо._ош71);
          мПров.Проверить(notrecurs(ИСТИНА, nov.предок), line, col, мКо._ош87);
          nov.размер := nov.предок.размер;
          nov.выравн := nov.предок.выравн;
          Проверить(мКонст._опСкобПравКруг);
          Лексем_Дальше;
          мПров.Проверить(nov.запись = мКонст._record, line, col, мКо._ош103);
          мПров.Проверить(nov.предок.запись = мКонст._record, line2, col2, мКо._ош104)
        КОНЕЦ;
        ReadFields(nov);
        Проверить(мКонст._лекКонец);
        nov.размер := X86.Align(nov.размер, nov.выравн);
        ЕСЛИ nov.предок # ПУСТО ТОГДА
          X86.AddRec(nov.предок.Number)
        ИНАЧЕ
          X86.AddRec(0)
        КОНЕЦ;
        Лексем_Дальше
      |мКонст._лекУказат:
        Лексем_Дальше;
        Проверить(мКонст._lexTO);
        Лексем_Дальше;
        nov := CreateType(мКонст._тУказатель, 0, 4, 0, ПУСТО, ЛОЖЬ, NewType);
        nov.выравн := 4;
        Coord(line, col);
        nov.предок := pParseType(line, col);
        ЕСЛИ nov.предок = ПУСТО ТОГДА
          мПров.Проверить(модуль_текущ.typedecl, line, col, мКо._ош33);
          AddPtrBase(NamePtrBase, line, col, nov)
        ИНАЧЕ
          мПров.Проверить(nov.предок.тип_узла = мКонст._тЗапись, line, col, мКо._ош72)
        КОНЕЦ
      |мКонст._лекПроцедура:
        Лексем_Дальше;
        nov := CreateType(мКонст._TPROC, 0, 4, 0, sttypes[мКонст._TVOID], ИСТИНА, NewType);
        Coord(line, col);
        ЕСЛИ CallFlag(nov.вызов) ТОГДА
          мПров.Проверить(модуль_текущ.системный, line, col, мКо._ош102)
        КОНЕЦ;
        nov.выравн := 4;
        FormalList(nov, nov.предок)
      ИНАЧЕ
        мПров.Проверить2(ЛОЖЬ, мКо._ош30)
      КОНЕЦ
      ВЕРНУТЬ nov
    КОНЕЦ StructType;

ПРОЦЕДУРА ParseType(ПЕРЕМ line, col: ЦЕЛОЕ): мТипы.туТип;
    ПЕРЕМ Res: мТипы.туТип;
    НАЧАЛО
      ЕСЛИ SCAN.лекс_тип = мКонст._лекИмя ТОГДА
        Res := IdType(line, col)
      ИНАЧЕ
        Res := StructType(ЛОЖЬ, ПУСТО)
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ ParseType;

ПРОЦЕДУРА PopBlock;
    ПЕРЕМ cur: туИмя; n: ЦЕЛОЕ;
    НАЧАЛО
      cur := модуль_текущ.спис_имен.последний(туИмя);
      n := 0;
      ПОКА cur.iType # мКонст._IDGUARD ДЕЛАТЬ
        cur := cur.предыдущ(туИмя);
        ДОБ(n)
      КОНЕЦ;
      cur := cur.предыдущ(туИмя);
      ДОБ(n);
      модуль_текущ.спис_имен.спис_длин := модуль_текущ.спис_имен.спис_длин - n;
      модуль_текущ.спис_имен.последний := cur;
      cur.следующ := ПУСТО;
      ВЫЧ(модуль_текущ.уровень)
    КОНЕЦ PopBlock;

ПРОЦЕДУРА LinkPtr;
    ПЕРЕМ cur: tpPtrBase; id: туИмя;
    НАЧАЛО
      cur := PtrBases.первый(tpPtrBase);
      ПОКА cur # ПУСТО ДЕЛАТЬ
        id := GetIdent(cur.Name);
        мПров.Проверить(id # ПУСТО, cur.строка, cur.col, мКо._ош33);
        мПров.Проверить(id.тип.тип_узла = мКонст._тЗапись, cur.строка, cur.col, мКо._ош72);
        cur.Ptr.предок := id.тип;
        cur := cur.следующ(tpPtrBase)
      КОНЕЦ;
      мСпис.Очистить(PtrBases)
    КОНЕЦ LinkPtr;

ПРОЦЕДУРА DeclSeq;
    ПЕРЕМ Value: ДЛИНВЕЩ; T, NewType: мТипы.туТип; Name: SCAN.туУзел; line, col, Call: ЦЕЛОЕ;
        Export, func: БУЛЕВО; last, id: туИмя; e: тВыражение;

      ПРОЦЕДУРА IdentDef;
      НАЧАЛО
        Name := SCAN.id;
        Coord(line, col);
        Лексем_Дальше;
        Export := ЛОЖЬ;
        ЕСЛИ SCAN.лекс_тип = мКонст._опУмнож ТОГДА
          мПров.Проверить2(модуль_текущ.уровень = 3, мКо._ош80);
          Export := ИСТИНА;
          Лексем_Дальше
        КОНЕЦ
      КОНЕЦ IdentDef;

    НАЧАЛО
      ЕСЛИ SCAN.лекс_тип = мКонст._лекКонст ТОГДА
        Лексем_Дальше;
        ПОКА SCAN.лекс_тип = мКонст._лекИмя ДЕЛАТЬ
          IdentDef;
          PushIdent(Name, line, col, мКонст._имяКонст, ПУСТО, ПУСТО, Export, 0);
          last := модуль_текущ.спис_имен.последний(туИмя);
          Проверить(мКонст._опРавно);
          Лексем_Дальше;
          ConstExpr(Value, T);
          Проверить(мКонст._опТчкЗпт);
          last.двЗнач := Value;
          last.тип := T;
          Лексем_Дальше
        КОНЕЦ
      КОНЕЦ;
      ЕСЛИ SCAN.лекс_тип = мКонст._лекТипы ТОГДА
        мСпис.Очистить(PtrBases);
        модуль_текущ.typedecl := ИСТИНА;
        Лексем_Дальше;
        ПОКА SCAN.лекс_тип = мКонст._лекИмя ДЕЛАТЬ
          IdentDef;
          PushIdent(Name, line, col, мКонст._имяТипа, ПУСТО, ПУСТО, Export, 0);
          last := модуль_текущ.спис_имен.последний(туИмя);
          модуль_текущ.экспорт_типов := Export;
          Проверить(мКонст._опРавно);
          Лексем_Дальше;
          НОВ(NewType);
          MemErr(NewType = ПУСТО);
          last.тип := NewType;
          T := StructType(ЛОЖЬ, NewType);
          Проверить(мКонст._опТчкЗпт);
          Лексем_Дальше
        КОНЕЦ
      КОНЕЦ;
      LinkPtr;
      модуль_текущ.typedecl := ЛОЖЬ;
      модуль_текущ.экспорт_типов := ЛОЖЬ;
      ЕСЛИ SCAN.лекс_тип = мКонст._лекПерем ТОГДА
        Лексем_Дальше;
        ПОКА SCAN.лекс_тип = мКонст._лекИмя ДЕЛАТЬ
          IdentDef;
          PushIdent(Name, line, col, мКонст._имяПерем, ПУСТО, ПУСТО, Export, 0);
          ЕСЛИ SCAN.лекс_тип = мКонст._опЗпт ТОГДА
            Лексем_Дальше;
            Проверить(мКонст._лекИмя)
          ИЛЕСЛ SCAN.лекс_тип = мКонст._опДвеТчк ТОГДА
            Лексем_Дальше;
            Coord(line, col);
            T := ParseType(line, col);
            мПров.Проверить(T # ПУСТО, line, col, мКо._ош33);
            SetVars(T);
            Проверить(мКонст._опТчкЗпт);
            Лексем_Дальше
          ИНАЧЕ
            мПров.Проверить2(ЛОЖЬ, мКо._ош76)
          КОНЕЦ
        КОНЕЦ
      КОНЕЦ;
      ПОКА SCAN.лекс_тип = мКонст._лекПроцедура ДЕЛАТЬ
        Лексем_Дальше;
        Coord(line, col);
        ЕСЛИ CallFlag(Call) ТОГДА
          мПров.Проверить(модуль_текущ.уровень = 3, line, col, мКо._ош36);
          мПров.Проверить(модуль_текущ.системный, line, col, мКо._ош102)
        КОНЕЦ;
        Проверить(мКонст._лекИмя);
        IdentDef;
        PushIdent(Name, line, col, мКонст._имяПроц, CreateType(мКонст._TPROC, 0, 4, 0,
                sttypes[мКонст._TVOID], ИСТИНА, ПУСТО), ПУСТО, Export, 0);
        id := модуль_текущ.спис_имен.последний(туИмя);
        ЕСЛИ id.Export & main ТОГДА
          ЕСЛИ платформа = 6 ТОГДА
            мПров.Проверить((Name # SCAN._START) & (Name # SCAN._version), line, col, мКо._ош124)
          КОНЕЦ;
          X86.ProcExport(id.Number, Name, X86.NewLabel())
        КОНЕЦ;
        id.предок := curBlock;
        curBlock := id;
        Guard;
        FormalList(ПУСТО, curBlock.тип.предок);
        id.тип.вызов := Call;
        Проверить(мКонст._опТчкЗпт);
        Лексем_Дальше;
        DeclSeq;
        id.LocalSize := id.VarSize - id.ParamSize;
        X86.ProcBeg(id.Number, id.LocalSize, ЛОЖЬ);
        ЕСЛИ SCAN.лекс_тип = мКонст._лекНачать ТОГДА
          Лексем_Дальше;
          OpSeq
        КОНЕЦ;
        func := curBlock.тип.предок.тип_узла # мКонст._TVOID;
        ЕСЛИ func ТОГДА
          Проверить(мКонст._лекВернуть);
          мУтиль.ЮнитСтрока_Уст(модуль_ном, SCAN.строка_ном);
          Лексем_Дальше;
          Coord(line, col);
          Expr(e);
          мПров.Проверить(AssComp(e, curBlock.тип.предок, ЛОЖЬ), line, col, мКо._ош116);
          ЕСЛИ e.eType = мКонст._eVAR ТОГДА
            X86.Load(e.тип.тип_узла)
          КОНЕЦ
        ИНАЧЕ
          мПров.Проверить2(SCAN.лекс_тип # мКонст._лекВернуть, мКо._ош114)
        КОНЕЦ;
        Проверить(мКонст._лекКонец);
        Лексем_Дальше;
        Проверить(мКонст._лекИмя);
        мПров.Проверить2(SCAN.id = Name, мКо._ош78);
        Лексем_Дальше;
        Проверить(мКонст._опТчкЗпт);
        Лексем_Дальше;
        X86.ProcEnd(id.Number, (id.ParamSize + (id.уровень - 3) * 4) * ORD(curBlock.тип.вызов ВХОДИТ {мКонст._stdcall, мКонст._winapi, мКонст._defcall}),
                func, curBlock.тип.предок.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ});
        PopBlock;
        curBlock := curBlock.предок
      КОНЕЦ
    КОНЕЦ DeclSeq;

ПРОЦЕДУРА Rtl(u: туМодуль);

    ПРОЦЕДУРА AddProc(имя_: мСтр.тСтрока; номер_: ЦЕЛОЕ);
        ПЕРЕМ
            имя: туИмя;
        НАЧАЛО
            имя := GetQIdent(u, SCAN.Узел_Добавить(имя_));
            ЕСЛИ имя = ПУСТО ТОГДА
                мОш.Сообщ(136);
                mProc.Выход(1)
            КОНЕЦ;
            X86.AddRtlProc(номер_, имя.Number)
        КОНЕЦ AddProc;

    НАЧАЛО
      AddProc("_newrec", мКонст._newrec);
      AddProc("_disprec", мКонст._disprec);
      AddProc("_rset", мКонст._rset);
      AddProc("_inset", мКонст._inset);
      AddProc("_saverec", мКонст._saverec);
      AddProc("_checktype", мКонст._checktype);
      AddProc("_strcmp", мКонст._strcmp);
      AddProc("_lstrcmp", мКонст._lstrcmp);
      AddProc("_rstrcmp", мКонст._rstrcmp);
      AddProc("_savearr", мКонст._savearr);
      AddProc("_arrayidx", мКонст._arrayidx);
      AddProc("_arrayidx1", мКонст._arrayidx1);
      AddProc("_arrayrot", мКонст._arrayrot);
      AddProc("_assrt", мКонст._assrt);
      AddProc("_strcopy", мКонст._strcopy);
      AddProc("_init", мКонст._init);
      AddProc("_close", мКонст._close);
      AddProc("_halt", мКонст._halt);
      AddProc("_length", мКонст._length);
    КОНЕЦ Rtl;

ПРОЦЕДУРА Список_Импортировать;
    ПЕРЕМ cond, col, line, namecol, nameline: ЦЕЛОЕ;
        name, alias: SCAN.туУзел; u, self: туМодуль;
        FName: мСтр.тСтрока;

      ПРОЦЕДУРА Модуль_Добавить(newcond: ЦЕЛОЕ);
        ПЕРЕМ
            str: туИмяСтрока;
        НАЧАЛО
            u := Модуль_Получ(name);
            ЕСЛИ u = ПУСТО ТОГДА
              self := модуль_текущ;
              SCAN.Резерв_Сделать(модуль_текущ.scanner);
              COPY(name.имя_узла, FName);
              ЕСЛИ ~((~self.Std & прМодуль_Прочитать(Path, FName, мКонст._расшир)) ИЛИ
                    прМодуль_Прочитать(Std, FName, мКонст._расшир)) ТОГДА
                ЕСЛИ FName = "SYSTEM" ТОГДА
                  модуль_текущ := sys;
                  self.системный := ИСТИНА
                ИНАЧЕ
                  мПров.Проверить(ЛОЖЬ, nameline, namecol, мКо._ош23)
                КОНЕЦ
              КОНЕЦ;
              SCAN.Резерв_Воостановить(self.scanner);
              u := модуль_текущ;
              модуль_текущ := self;
              мУтиль.ФайлПуть_Уст(модуль_текущ.файл_имя)
            ИНАЧЕ
              мПров.Проверить(u.закрытый, nameline, namecol, мКо._ош22)
            КОНЕЦ;
            PushIdent(alias, line, col, мКонст._IDMOD, sttypes[мКонст._TVOID], u, ЛОЖЬ, 0);
            НОВ(str);
            MemErr(str = ПУСТО);
            str.строка := name.имя_узла;
            мСпис.Добавить(модуль_текущ.спис_импорта, str);
            cond := newcond
        КОНЕЦ Модуль_Добавить;

    НАЧАЛО
      cond := 0;
      ПОКА cond # 4 ДЕЛАТЬ
        Лексем_Дальше;
        ВЫБРАТЬ cond ИЗ
        |0: Проверить(мКонст._лекИмя);
            name := SCAN.id;
            Coord(line, col);
            Coord(nameline, namecol);
            alias := name;
            cond := 1
        |1: ВЫБРАТЬ SCAN.лекс_тип ИЗ
            |мКонст._опЗпт:  Модуль_Добавить(0)
            |мКонст._опТчкЗпт:   Модуль_Добавить(4); Лексем_Дальше
            |мКонст._lexAssign: cond := 2
            ИНАЧЕ
              мПров.Проверить2(ЛОЖЬ, мКо._ош19)
            КОНЕЦ
        |2: Проверить(мКонст._лекИмя);
            name := SCAN.id;
            Coord(nameline, namecol);
            cond := 3
        |3: ВЫБРАТЬ SCAN.лекс_тип ИЗ
            |мКонст._опЗпт: Модуль_Добавить(0)
            |мКонст._опТчкЗпт:  Модуль_Добавить(4); Лексем_Дальше
            ИНАЧЕ
              мПров.Проверить2(ЛОЖЬ, мКо._ош20)
            КОНЕЦ
        ИНАЧЕ
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ Список_Импортировать;

ПРОЦЕДУРА Header(Name: SCAN.туУзел);
    НАЧАЛО
      НОВ(модуль_текущ);
      MemErr(модуль_текущ = ПУСТО);
      модуль_текущ.спис_имен := мСпис.Создать();
      MemErr(модуль_текущ.спис_имен = ПУСТО);
      модуль_текущ.уровень := 0;
      модуль_текущ.Name := Name;
      Guard; Guard;
      PushIdent(модуль_текущ.Name, 0, 0, мКонст._IDMOD, sttypes[мКонст._TVOID], модуль_текущ, ЛОЖЬ, 0);
      Guard;
      модуль_текущ.IdentBegin := модуль_текущ.спис_имен.последний(туИмя);
      модуль_текущ.закрытый := ИСТИНА
    КОНЕЦ Header;

ПРОЦЕДУРА МодПсевдо_Добав;
    ПЕРЕМ
        модуль: туМодуль;
    НАЧАЛО
      модуль := модуль_текущ;
      Header(SCAN.Узел_Добавить("SYSTEM"));
      ПроцСис_Сохр("ADR",     мКонст._sysADR);
      ПроцСис_Сохр("SIZE",    мКонст._sysSIZE);
      ПроцСис_Сохр("TYPEID",  мКонст._sysTYPEID);
      ПроцСис_Сохр("BIT",     мКонст._sysBIT);
      ПроцСис_Сохр("GET",     мКонст._sysGET);
      ПроцСис_Сохр("PUT",     мКонст._sysPUT);
      ПроцСис_Сохр("CODE",    мКонст._sysCODE);
      ПроцСис_Сохр("MOVE",    мКонст._sysMOVE);
      PushSysType("CARD16",  мКонст._TCARD16);
      sys := модуль_текущ;
      модуль_текущ := модуль
    КОНЕЦ МодПсевдо_Добав;

ПРОЦЕДУРА Модуль_Прочитать(Path, Name1, Ext: мСтр.тСтрока): БУЛЕВО;
    ПЕРЕМ
        FHandle: ЦЕЛОЕ; name, Name, b: мСтр.тСтрока; idmod: туИмя; Res, temp: БУЛЕВО;
    НАЧАЛО
        Res := ЛОЖЬ;
        name := Name1;
        Name := Name1;
        мУтиль.ТриСтр_соединить(Path, Name, b);
        мУтиль.ТриСтр_соединить(b, Ext, Name);
        ЕСЛИ SCAN.Файл_Прочитать(Name, FHandle) ТОГДА
            НОВ(модуль_текущ);
            MemErr(модуль_текущ = ПУСТО);
            модуль_текущ.системный := ЛОЖЬ;
            модуль_текущ.Std := Path = Std;
            мСпис.Добавить(prog, модуль_текущ);
            модуль_текущ.спис_имен := мСпис.Создать();
            MemErr(модуль_текущ.спис_имен = ПУСТО);
            модуль_текущ.спис_импорта := мСпис.Создать();
            MemErr(модуль_текущ.спис_импорта = ПУСТО);
            НОВ(модуль_текущ.scanner);
            MemErr(модуль_текущ.scanner = ПУСТО);
            модуль_текущ.закрытый := ЛОЖЬ;
            модуль_текущ.уровень := 0;
            модуль_текущ.typedecl := ЛОЖЬ;
            модуль_текущ.экспорт_типов := ЛОЖЬ;
            COPY(Name, модуль_текущ.файл_имя);
            мУтиль.ФайлПуть_Уст(модуль_текущ.файл_имя);
            ИмяВнутр_Уст;
            Лексем_Дальше; Проверить(мКонст._лекМодуль);
            Лексем_Дальше; Проверить(мКонст._лекИмя);
            мПров.Проверить2(мУтиль.Стр_соединить(SCAN.id.имя_узла, name), мКо._ош24);
            модуль_текущ.Name := SCAN.id;
            PushIdent(модуль_текущ.Name, SCAN.строка_ном, SCAN.позиц_глоб, мКонст._IDMOD, sttypes[мКонст._TVOID], модуль_текущ,
                    ЛОЖЬ, 0);
            idmod := модуль_текущ.спис_имен.последний(туИмя);
            Guard;
            Лексем_Дальше; Проверить(мКонст._опТчкЗпт);
            Лексем_Дальше;
            ЕСЛИ SCAN.лекс_тип = мКонст._лекИмпорт ТОГДА
                temp := main;
                main := ЛОЖЬ;
                Список_Импортировать;
                main := temp
            КОНЕЦ;
            мКонс.Стр_Печать("Компиляция "); мКонс.Стр_Печать(модуль_текущ.Name.имя_узла); мКонс.Стр_Нов;
            X86.Module(idmod.Name.имя_узла, idmod.Number);
            модуль_ном := idmod.Number;
            модуль_текущ.IdentBegin := модуль_текущ.спис_имен.последний(туИмя);
            curBlock := idmod;
            DeclSeq;
            X86.ProcBeg(idmod.Number, 0, ИСТИНА);
            ЕСЛИ SCAN.лекс_тип = мКонст._лекНачать ТОГДА
                Лексем_Дальше;
                OpSeq
            КОНЕЦ;
            Проверить(мКонст._лекКонец);
            Лексем_Дальше; Проверить(мКонст._лекИмя);
            мПров.Проверить2(SCAN.id = модуль_текущ.Name, мКо._ош17);
            Лексем_Дальше; Проверить(мКонст._лекТочка);
            X86.Leave;
            модуль_текущ.закрытый := ИСТИНА;
            мСпис.Очистить(модуль_текущ.спис_импорта);
            Res := ИСТИНА
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Модуль_Прочитать;

ПРОЦЕДУРА Program*(StdPath, FilePath, NameFile, ExtFile: мСтр.тСтрока; windows: БУЛЕВО;
  OpSeqProc: opPROC; ExprProc: expPROC; AssCompProc: assPROC; ПЕРЕМ stypes: stTYPES);
    НАЧАЛО
      winplatf := windows;
      Path := FilePath;
      Main := NameFile;
      ExtMain := ExtFile;
      Std := StdPath;
      OpSeq := OpSeqProc;
      Expr := ExprProc;
      AssComp := AssCompProc;
      prog := мСпис.Создать();
      MemErr(prog = ПУСТО);
      PtrBases := мСпис.Создать();
      MemErr(PtrBases = ПУСТО);
      types := мСпис.Создать();
      MemErr(types = ПУСТО);
      StTypes;
      Strings := мСпис.Создать();
      MemErr(Strings = ПУСТО);
      МодПсевдо_Добав;
      stypes := sttypes
    КОНЕЦ Program;

ПРОЦЕДУРА delfirstchar(ПЕРЕМ s: мСтр.тСтрока);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ДЛЯ i := 0 ДО LENGTH(s) - 1 ДЕЛАТЬ
        s[i] := s[i + 1]
      КОНЕЦ
    КОНЕЦ delfirstchar;

ПРОЦЕДУРА Компилировать*(platform, stksize: ЦЕЛОЕ);
    ПЕРЕМ full, path, name, ext, temp, path2: мСтр.тСтрока;
    НАЧАЛО
      платформа := platform;
      main := ЛОЖЬ;
      ЕСЛИ Модуль_Прочитать(Std, "RTL", мКонст._расшир) ТОГДА
        Rtl(модуль_текущ)
      ИНАЧЕ
        мОш.Сообщ(56);
        mProc.Выход(1)
      КОНЕЦ;
      main := ИСТИНА;
      ЕСЛИ ~Модуль_Прочитать(Path, Main, ExtMain) ТОГДА
        path2 := Path;
        мУтиль.СтрПарам_Уст(full, 0);
        мУтиль.ФайлПуть_разделить(full, path, name, ext);
        ЕСЛИ path[0] # 0X ТОГДА
          path[LENGTH(path) - 1] := 0X
        КОНЕЦ;
        ЕСЛИ Path[0] = мКонст._слэш ТОГДА
          delfirstchar(Path)
        КОНЕЦ;
        мУтиль.ТриСтр_соединить(path, мКонст._слэш, path);
        мУтиль.ТриСтр_соединить(path, Path, full);
        Path := full;
        ЕСЛИ (мКонст._ос = "WIN") & (Path[0] = мКонст._слэш) ТОГДА
          delfirstchar(Path)
        КОНЕЦ;
        ЕСЛИ ~Модуль_Прочитать(Path, Main, ExtMain) ТОГДА
          мОш.Сообщ(55);
          мКонс.Стр_Печать(path2);
          мКонс.Стр_Печать(Main);
          мКонс.Стр_Печать(ExtMain);
          мКонс.Стр_Нов;
          mProc.Выход(1)
        КОНЕЦ
      КОНЕЦ;
      temp := Path;
      мУтиль.ТриСтр_соединить(temp, Main, temp);
      ЕСЛИ platform ВХОДИТ {2, 3} ТОГДА
        мУтиль.ТриСтр_соединить(temp, ".exe", temp)
      ИЛЕСЛ platform = 1 ТОГДА
        мУтиль.ТриСтр_соединить(temp, ".dll", temp)
      ИЛЕСЛ platform = 4 ТОГДА
        мУтиль.ТриСтр_соединить(temp, ".kex", temp)
      ИЛЕСЛ platform = 6 ТОГДА
        мУтиль.ТриСтр_соединить(temp, ".obj", temp)
      КОНЕЦ;
      ЕСЛИ platform ВХОДИТ {1, 2, 3, 4} ТОГДА
        stksize := stksize * 100000H
      КОНЕЦ;
      X86.Epilog(DECL.ProgSize, temp, stksize)
    КОНЕЦ Компилировать;

НАЧАЛО
  pParseType := ParseType;
  прМодуль_Прочитать := Модуль_Прочитать
КОНЕЦ DECL.
