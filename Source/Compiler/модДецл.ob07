(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
  *)

ÃŒƒ”À‹ ÏÓ‰ƒÂˆÎ;

»ÃœŒ–“ Ï—Í‡Ì := ÏÓ‰—Í‡ÌÂ,
    Ï”ÚËÎ¸ := ÏÓ‰”ÚËÎ¸,
    X86 := ÏÓ‰¿ÒÏ86_32,
    SYSTEM,
    Ï“ËÔ˚ := ÏÓ‰“ËÔ˚,
    Ï ÓÌÒÚ := ÏÓ‰ ÓÌÒÚ‡ÌÚ˚;

 ŒÕ—“

  lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
  lxBY = 3;
  lxDIV = 6;
  lxMOD = 17;

  lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54; lxNot = 55; lxAnd = 56; lxComma = 57; lxSemi = 58;
  lxStick = 59; lxLRound = 60; lxLSquare = 61; lxLCurly = 62; lxCaret = 63; lxRRound = 64; lxRSquare = 65;
  lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69; lxColon = 70;
  lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

  lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
  lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

  IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

  stABS = 1; stODD = 2; stLEN = 3; stLSL = 4; stASR = 5; stROR = 6; stFLOOR = 7; stFLT = 8;
  stORD = 9; stCHR = 10; stLONG = 11; stSHORT = 12; stINC = 13; stDEC = 14; stINCL = 15;
  stEXCL = 16; stCOPY = 17; stNEW = 18; stASSERT = 19; stPACK = 20; stUNPK = 21; stDISPOSE = 22;
  stBITS = 23; stLSR = 24; stLENGTH = 25;

  sysADR = 101; sysSIZE = 102; sysBIT = 103; sysGET = 104; sysPUT = 105; sysCODE = 106;
  sysTYPEID = 107; sysMOVE = 108;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7; TNIL = 8;
  TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  paramvar* = 1; param* = 2;

  defcall = 0; stdcall = 1; cdecl = 2; winapi* = 3;

  record = 0; union = 1; noalign = 2;

  eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

  IOVER* = lxERR5 - lxERR0;
  FOVER* = lxERR7 - lxERR0;
  UNDER* = lxERR9 - lxERR0;

“»œ€

  pTYPE* = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      tType*, Size*, Len*, Number*, Align, Call*, Rec: INTEGER;
      Base*: pTYPE;
      Fields*: Ï”ÚËÎ¸.tpList
     ŒÕ≈÷;

  IDENT* = ” ¿«¿“≈À‹ Õ¿ rIDENT;

  UNIT* = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Name: Ï—Í‡Ì.NODE;
      File: Ï“ËÔ˚.tString;
      Idents: Ï”ÚËÎ¸.tpList;
      Import: Ï”ÚËÎ¸.tpList;
      IdentBegin: IDENT;
      scanner: Ï—Í‡Ì.SCANNER;
      Level*: INTEGER;
      Closed, typedecl, ExportType, Std, sys: BOOLEAN
     ŒÕ≈÷;

  rIDENT* = «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Name: Ï—Í‡Ì.NODE;
      T*: pTYPE;
      Unit*: UNIT;
      Parent*: IDENT;
      Value*: LONGREAL;
      line*, col*, Number*, iType*, StProc*, VarSize, ParamSize*,
      LocalSize*, Offset*, VarKind*, Level*, ParamCount*: INTEGER;
      Export: BOOLEAN
     ŒÕ≈÷;

  PTRBASE = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Name: Ï—Í‡Ì.NODE;
      line, col: INTEGER;
      Ptr: pTYPE
     ŒÕ≈÷;

  STRITEM = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Str: Ï“ËÔ˚.tString
     ŒÕ≈÷;

  FIELD* = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Name: Ï—Í‡Ì.NODE;
      T*: pTYPE;
      Offset*: INTEGER;
      ByRef*, Export*: BOOLEAN;
      Unit*: UNIT
     ŒÕ≈÷;

  STRCONST* = ” ¿«¿“≈À‹ Õ¿ «¿œ»—‹ (Ï”ÚËÎ¸.tItem)
      Str*: Ï“ËÔ˚.tString;
      Len*, Number*: INTEGER
     ŒÕ≈÷;

  EXPRESSION* = «¿œ»—‹
      id*: IDENT;
      T*: pTYPE;
      eType*: INTEGER;
      Value*: LONGREAL;
      Read*, vparam*, deref*: BOOLEAN
     ŒÕ≈÷;

  opPROC = œ–Œ÷≈ƒ”–¿;
  expPROC = œ–Œ÷≈ƒ”–¿ (œ≈– e: EXPRESSION);
  assPROC = œ–Œ÷≈ƒ”–¿ (e: EXPRESSION; T: pTYPE; param: BOOLEAN): BOOLEAN;

  stTYPES* = Ã¿——»¬ 11 »« pTYPE;

œ≈–≈Ã

  sttypes: stTYPES; unit*, sys: UNIT; curBlock*: IDENT;
  Path, Main, Std, ExtMain: Ï“ËÔ˚.tString;
  NamePtrBase: Ï—Í‡Ì.NODE; ProgSize*, RecCount, UnitNumber*: INTEGER;
  PtrBases, Strings, types, prog: Ï”ÚËÎ¸.tpList;
  OpSeq: opPROC; Expr: expPROC;
  AssComp: assPROC; main, sizefunc, winplatf, Const*: BOOLEAN;
  pParseType: œ–Œ÷≈ƒ”–¿ (œ≈– line, col: INTEGER): pTYPE;
  pReadModule: œ–Œ÷≈ƒ”–¿ (Path, Name, Ext: Ï“ËÔ˚.tString): BOOLEAN;
  Platform: INTEGER;

œ–Œ÷≈ƒ”–¿ SetSizeFunc*;
  Õ¿◊¿ÀŒ
    sizefunc := »—“»Õ¿
   ŒÕ≈÷ SetSizeFunc;

œ–Œ÷≈ƒ”–¿ MemErr*(err: BOOLEAN);
  Õ¿◊¿ÀŒ
    ≈—À» err “Œ√ƒ¿
      Ï”ÚËÎ¸.MemErr(err)
     ŒÕ≈÷
   ŒÕ≈÷ MemErr;

œ–Œ÷≈ƒ”–¿ GetString*(adr: LONGREAL): STRCONST;
  œ≈–≈Ã str: STRCONST;
  Õ¿◊¿ÀŒ
    SYSTEM.PUT(SYSTEM.ADR(str), FLOOR(adr))
    ¬≈–Õ”“‹ str
   ŒÕ≈÷ GetString;

œ–Œ÷≈ƒ”–¿ AddString*(str: Ï“ËÔ˚.tString): STRCONST;
  œ≈–≈Ã nov: STRCONST;
  Õ¿◊¿ÀŒ
    NEW(nov);
    MemErr(nov = œ”—“Œ);
    COPY(str, nov.Str);
    nov.Len := Ï—Í‡Ì.count - 1;
    nov.Number := X86.NewLabel();
    Ï”ÚËÎ¸.Push(Strings, nov);
    X86.String(nov.Number, nov.Len, nov.Str)
    ¬≈–Õ”“‹ nov
   ŒÕ≈÷ AddString;

œ–Œ÷≈ƒ”–¿ AddMono*(c: CHAR): STRCONST;
  œ≈–≈Ã nov: STRCONST;
  Õ¿◊¿ÀŒ
    NEW(nov);
    MemErr(nov = œ”—“Œ);
    nov.Str[0] := c;
    nov.Str[1] := 0X;
    nov.Len := 1;
    nov.Number := X86.NewLabel();
    Ï”ÚËÎ¸.Push(Strings, nov);
    X86.String(nov.Number, nov.Len, nov.Str)
    ¬≈–Õ”“‹ nov
   ŒÕ≈÷ AddMono;

œ–Œ÷≈ƒ”–¿ Coord(œ≈– line, col: INTEGER);
  Õ¿◊¿ÀŒ
    line := Ï—Í‡Ì.line;
    col := Ï—Í‡Ì.col
   ŒÕ≈÷ Coord;

œ–Œ÷≈ƒ”–¿ GetModule(Name: Ï—Í‡Ì.NODE): UNIT;
  œ≈–≈Ã cur, res: UNIT;
  Õ¿◊¿ÀŒ
    res := œ”—“Œ;
    cur := prog.First(UNIT);
    œŒ ¿ (cur # œ”—“Œ) & Ï”ÚËÎ¸.streq(cur.Name.Name, Name.Name) ƒ≈À¿“‹
      res := cur;
      cur := œ”—“Œ
    ¿≈—À» cur # œ”—“Œ ƒ≈À¿“‹
      cur := cur.Next(UNIT)
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ GetModule;

œ–Œ÷≈ƒ”–¿ Assert*(cond: BOOLEAN; line, col, code: INTEGER);
  Õ¿◊¿ÀŒ
    ≈—À» ~cond “Œ√ƒ¿
      Ï”ÚËÎ¸.ErrMsgPos(line, col, code);
      Ï”ÚËÎ¸.HALT(1)
     ŒÕ≈÷
   ŒÕ≈÷ Assert;

œ–Œ÷≈ƒ”–¿ Assert2(cond: BOOLEAN; code: INTEGER);
  Õ¿◊¿ÀŒ
    ≈—À» ~cond “Œ√ƒ¿
      Assert(ÀŒ∆‹, Ï—Í‡Ì.line, Ï—Í‡Ì.col, code)
     ŒÕ≈÷
   ŒÕ≈÷ Assert2;

œ–Œ÷≈ƒ”–¿ Next*;
  Õ¿◊¿ÀŒ
    Ï—Í‡Ì.GetLex;
    ≈—À» (Ï—Í‡Ì.tLex > lxERR0) & (Ï—Í‡Ì.tLex < lxERR20) “Œ√ƒ¿
      Assert(ÀŒ∆‹, Ï—Í‡Ì.line, Ï—Í‡Ì.col + Ï—Í‡Ì.count, Ï—Í‡Ì.tLex - lxERR0)
     ŒÕ≈÷;
    Assert2(Ï—Í‡Ì.tLex # lxEOF, 27)
   ŒÕ≈÷ Next;

œ–Œ÷≈ƒ”–¿ Check*(key: INTEGER);
  œ≈–≈Ã code: INTEGER;
  Õ¿◊¿ÀŒ
    ≈—À» Ï—Í‡Ì.tLex # key “Œ√ƒ¿
      ¬€¡Œ– key »«
      |Ï ÓÌÒÚ.ÍÒÃŒƒ”À‹:  code := 21
      |lxIDENT:   code := 22
      |lxSemi:    code := 23
      |Ï ÓÌÒÚ.ÍÒ ŒÕ≈÷:     code := 24
      |lxDot:     code := 25
      |lxEQ:      code := 35
      |lxRRound:  code := 38
      |Ï ÓÌÒÚ.ÍÒƒŒ:      code := 40
      |Ï ÓÌÒÚ.ÍÒ»«:      code := 41
      |lxRCurly:  code := 51
      |lxLRound:  code := 56
      |lxComma:   code := 61
      |Ï ÓÌÒÚ.ÍÒ“Œ√ƒ¿:    code := 98
      |lxRSquare: code := 109
      |Ï ÓÌÒÚ.ÍÒƒ≈À¿“‹:      code := 118
      |Ï ÓÌÒÚ.ÍÒœŒ ¿Õ≈:   code := 119
      |lxAssign:  code := 120
      |Ï ÓÌÒÚ.ÍÒ¬≈–Õ”“‹:  code := 124
      |lxColon:   code := 157
      »Õ¿◊≈
       ŒÕ≈÷;
      Assert2(ÀŒ∆‹, code)
     ŒÕ≈÷
   ŒÕ≈÷ Check;

œ–Œ÷≈ƒ”–¿ CheckIdent(Name: Ï—Í‡Ì.NODE): BOOLEAN;
  œ≈–≈Ã cur: IDENT;
  Õ¿◊¿ÀŒ
    cur := unit.Idents.Last(IDENT);
    œŒ ¿ (cur.iType # IDGUARD) & (cur.Name # Name) ƒ≈À¿“‹
      cur := cur.Prev(IDENT)
     ŒÕ≈÷
    ¬≈–Õ”“‹ cur.iType = IDGUARD
   ŒÕ≈÷ CheckIdent;

œ–Œ÷≈ƒ”–¿ Guard;
  œ≈–≈Ã ident: IDENT;
  Õ¿◊¿ÀŒ
    NEW(ident);
    MemErr(ident = œ”—“Œ);
    ident.Name := œ”—“Œ;
    ident.iType := IDGUARD;
    ident.T := sttypes[TVOID];
    Ï”ÚËÎ¸.Push(unit.Idents, ident);
    INC(unit.Level)
   ŒÕ≈÷ Guard;

œ–Œ÷≈ƒ”–¿ PushIdent(Name: Ï—Í‡Ì.NODE; line, col, iType: INTEGER; T: pTYPE; u: UNIT; Export: BOOLEAN; StProc: INTEGER);
  œ≈–≈Ã ident: IDENT; i: INTEGER;
  Õ¿◊¿ÀŒ
    Assert(CheckIdent(Name), line, col, 30);
    NEW(ident);
    MemErr(ident = œ”—“Œ);
    ident.Name := Name;
    ident.line := line;
    ident.col := col;
    ≈—À» iType IN {IDPROC, IDMOD} “Œ√ƒ¿
      ident.Number := X86.NewLabel();
      i := X86.NewLabel();
      i := X86.NewLabel();
      i := X86.NewLabel()
     ŒÕ≈÷;
    ident.iType := iType;
    ident.T := T;
    ident.Unit := u;
    ident.Export := Export;
    ident.StProc := StProc;
    ident.Level := unit.Level;
    Ï”ÚËÎ¸.Push(unit.Idents, ident)
   ŒÕ≈÷ PushIdent;

œ–Œ÷≈ƒ”–¿ StTypes;
  œ≈–≈Ã type: pTYPE; i: INTEGER;
  Õ¿◊¿ÀŒ
    sttypes[0] := œ”—“Œ;
    ƒÀﬂ i := TINTEGER ƒŒ TSTRING ƒ≈À¿“‹
      NEW(type);
      MemErr(type = œ”—“Œ);
      type.tType := i;
      Ï”ÚËÎ¸.Push(types, type);
      sttypes[i] := type
     ŒÕ≈÷;
    sttypes[TINTEGER].Size := 4;
    sttypes[TREAL].Size := 4;
    sttypes[TLONGREAL].Size := 8;
    sttypes[TBOOLEAN].Size := 1;
    sttypes[TCHAR].Size := 1;
    sttypes[TSET].Size := 4;
    sttypes[TVOID].Size := 0;
    sttypes[TSTRING].Size := 0;
    sttypes[TNIL].Size := 4;
    sttypes[TCARD16].Size := 2;
    ƒÀﬂ i := TINTEGER ƒŒ TSTRING ƒ≈À¿“‹
      sttypes[i].Align := sttypes[i].Size
     ŒÕ≈÷
   ŒÕ≈÷ StTypes;

œ–Œ÷≈ƒ”–¿ PushStProc(Name: Ï“ËÔ˚.tString; StProc: INTEGER);
  Õ¿◊¿ÀŒ
    PushIdent(Ï—Í‡Ì.AddNode(Name), 0, 0, IDSTPROC, sttypes[TVOID], œ”—“Œ, ÀŒ∆‹, StProc)
   ŒÕ≈÷ PushStProc;

œ–Œ÷≈ƒ”–¿ PushStType(Name: Ï“ËÔ˚.tString; T: INTEGER);
  Õ¿◊¿ÀŒ
    PushIdent(Ï—Í‡Ì.AddNode(Name), 0, 0, IDTYPE, sttypes[T], œ”—“Œ, ÀŒ∆‹, 0)
   ŒÕ≈÷ PushStType;

œ–Œ÷≈ƒ”–¿ PushSysProc(Name: Ï“ËÔ˚.tString; StProc: INTEGER);
  Õ¿◊¿ÀŒ
    PushIdent(Ï—Í‡Ì.AddNode(Name), 0, 0, IDSYSPROC, sttypes[TVOID], œ”—“Œ, »—“»Õ¿, StProc)
   ŒÕ≈÷ PushSysProc;

œ–Œ÷≈ƒ”–¿ PushSysType(Name: Ï“ËÔ˚.tString; T: INTEGER);
  Õ¿◊¿ÀŒ
    PushIdent(Ï—Í‡Ì.AddNode(Name), 0, 0, IDTYPE, sttypes[T], œ”—“Œ, »—“»Õ¿, 0)
   ŒÕ≈÷ PushSysType;

œ–Œ÷≈ƒ”–¿ StIdent;
  Õ¿◊¿ÀŒ
    Guard;
    PushStProc("ABS",      stABS);
    PushStProc("ASR",      stASR);
    PushStProc("ASSERT",   stASSERT);
    PushStType("BOOLEAN",  TBOOLEAN);
    PushStType("CHAR",     TCHAR);
    PushStProc("CHR",      stCHR);
    PushStProc("COPY",     stCOPY);
    PushStProc("DEC",      stDEC);
    PushStProc("DISPOSE",  stDISPOSE);
    PushStProc("EXCL",     stEXCL);
    PushStProc("FLOOR",    stFLOOR);
    PushStProc("FLT",      stFLT);
    PushStProc("INC",      stINC);
    PushStProc("INCL",     stINCL);
    PushStType("INTEGER",  TINTEGER);
    PushStProc("LEN",      stLEN);
    PushStProc("LSL",      stLSL);
    PushStProc("LONG",     stLONG);
    PushStType("LONGREAL", TLONGREAL);
    PushStProc("NEW",      stNEW);
    PushStProc("ODD",      stODD);
    PushStProc("ORD",      stORD);
    PushStProc("PACK",     stPACK);
    PushStType("REAL",     TREAL);
    PushStProc("ROR",      stROR);
    PushStType("SET",      TSET);
    PushStProc("SHORT",    stSHORT);
    PushStProc("UNPK",     stUNPK);
    PushStProc("BITS",     stBITS);
    PushStProc("LSR",      stLSR);
    PushStProc("LENGTH",   stLENGTH);
    Guard
   ŒÕ≈÷ StIdent;

œ–Œ÷≈ƒ”–¿ GetQIdent*(Unit: UNIT; Name: Ï—Í‡Ì.NODE): IDENT;
  œ≈–≈Ã cur, res: IDENT; line, col: INTEGER;
  Õ¿◊¿ÀŒ
    res := œ”—“Œ;
    Coord(line, col);
    cur := Unit.IdentBegin.Next(IDENT);
    œŒ ¿ (cur # œ”—“Œ) & (cur.iType # IDGUARD) ƒ≈À¿“‹
      ≈—À» cur.Name = Name “Œ√ƒ¿
        ≈—À» (Unit # unit) & ~cur.Export “Œ√ƒ¿
          res := œ”—“Œ
        »Õ¿◊≈
          res := cur
         ŒÕ≈÷;
        cur := œ”—“Œ
      »Õ¿◊≈
        cur := cur.Next(IDENT)
       ŒÕ≈÷
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ GetQIdent;

œ–Œ÷≈ƒ”–¿ GetIdent*(Name: Ï—Í‡Ì.NODE): IDENT;
  œ≈–≈Ã cur, res: IDENT; line, col: INTEGER;
  Õ¿◊¿ÀŒ
    res := œ”—“Œ;
    Coord(line, col);
    cur := unit.Idents.Last(IDENT);
    œŒ ¿ (cur # œ”—“Œ) & (cur.Name = Name) ƒ≈À¿“‹
      res := cur;
      cur := œ”—“Œ
    ¿≈—À» cur # œ”—“Œ ƒ≈À¿“‹
      cur := cur.Prev(IDENT)
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ GetIdent;

œ–Œ÷≈ƒ”–¿ Relation*(Op: INTEGER): BOOLEAN;
  œ≈–≈Ã Res: BOOLEAN;
  Õ¿◊¿ÀŒ
    ¬€¡Œ– Op »«
    |lxEQ, lxNE, lxLT, lxGT,
     lxLE, lxGE, Ï ÓÌÒÚ.ÍÒ¬, Ï ÓÌÒÚ.ÍÒ≈—“‹:
      Res := »—“»Õ¿
    »Õ¿◊≈
      Res := ÀŒ∆‹
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ Relation;

œ–Œ÷≈ƒ”–¿ Arith(a, b: LONGREAL; T: pTYPE; Op, line, col: INTEGER): LONGREAL;
  CONST max = Ï—Í‡Ì.maxDBL;
  œ≈–≈Ã res: LONGREAL;
  Õ¿◊¿ÀŒ
    ¬€¡Œ– Op »«
    |lxPlus: res := a + b
    |lxMinus: res := a - b
    |lxMult: res := a * b
    |lxSlash:
      Assert(b # 0.0D0, line, col, 46);
      res := a / b
    |lxDIV:
      Assert(~((a = LONG(FLT(Ï ÓÌÒÚ.ˆÂÎÓÂ_ÏËÌ))) & (b = -1.0D0)), line, col, IOVER);
      res := LONG(FLT(FLOOR(a) DIV FLOOR(b)))
    |lxMOD:
      res := LONG(FLT(FLOOR(a) MOD FLOOR(b)))
    »Õ¿◊≈
     ŒÕ≈÷;
    Assert(~Ï”ÚËÎ¸.IsInf(res), line, col, FOVER);
    ¬€¡Œ– T.tType »«
    |TINTEGER:  Assert((res <= LONG(FLT(Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ))) & (res >= LONG(FLT(Ï ÓÌÒÚ.ˆÂÎÓÂ_ÏËÌ))), line, col, IOVER)
    |TREAL:     Assert((res <= LONG(Ï ÓÌÒÚ.‚Â˘_Ï‡ÍÒ)) & (res >= -LONG(Ï ÓÌÒÚ.‚Â˘_Ï‡ÍÒ)), line, col, FOVER)
    |TLONGREAL: Assert((res <= max) & (res >= -max), line, col, FOVER)
    »Õ¿◊≈
     ŒÕ≈÷;
    ≈—À» (res = 0.0D0) & (T.tType IN {TREAL, TLONGREAL}) »À» (ABS(res) < LONG(Ï ÓÌÒÚ.‚Â˘_ÏËÌ)) & (T.tType = TREAL) “Œ√ƒ¿
      ¬€¡Œ– Op »«
      |lxPlus:  Assert(a = -b, line, col, UNDER)
      |lxMinus: Assert(a = b, line, col, UNDER)
      |lxMult:  Assert((a = 0.0D0) »À» (b = 0.0D0), line, col, UNDER)
      |lxSlash: Assert((a = 0.0D0), line, col, UNDER)
      »Õ¿◊≈
       ŒÕ≈÷
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ Arith;

œ–Œ÷≈ƒ”–¿ strcmp(a, b: LONGREAL; Op: INTEGER): LONGREAL;
  œ≈–≈Ã sa, sb: STRCONST; Res: LONGREAL;
  Õ¿◊¿ÀŒ
    sa := GetString(a);
    sb := GetString(b);
    ¬€¡Œ– Op »«
    |lxEQ, lxNE: Res := LONG(FLT(ORD(sa.Str = sb.Str)))
    |lxLT, lxGT: Res := LONG(FLT(ORD(sa.Str < sb.Str)))
    |lxLE, lxGE: Res := LONG(FLT(ORD(sa.Str <= sb.Str)))
    »Õ¿◊≈
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ strcmp;

œ–Œ÷≈ƒ”–¿ Calc*(a, b: LONGREAL; Ta, Tb: pTYPE; Op, line, col: INTEGER; œ≈– Res: LONGREAL; œ≈– TRes: pTYPE);
  œ≈–≈Ã c: LONGREAL; ai, bi: INTEGER;
  Õ¿◊¿ÀŒ
    ai := FLOOR(a);
    bi := FLOOR(b);
    ≈—À» Op # Ï ÓÌÒÚ.ÍÒ¬ “Œ√ƒ¿
      Assert(Ta = Tb, line, col, 37)
     ŒÕ≈÷;
    ¬€¡Œ– Op »«
    |lxPlus, lxMinus, lxMult, lxSlash:
      Assert(~((Op = lxSlash) & (Ta.tType = TINTEGER)), line, col, 37);
      ≈—À» Ta.tType IN {TINTEGER, TREAL, TLONGREAL} “Œ√ƒ¿
        Res := Arith(a, b, Ta, Op, line, col)
      ¿≈—À» Ta.tType = TSET “Œ√ƒ¿
        ¬€¡Œ– Op »«
        |lxPlus:  Res := LONG(FLT(ORD(BITS(ai) + BITS(bi))))
        |lxMinus: Res := LONG(FLT(ORD(BITS(ai) - BITS(bi))))
        |lxMult:  Res := LONG(FLT(ORD(BITS(ai) * BITS(bi))))
        |lxSlash: Res := LONG(FLT(ORD(BITS(ai) / BITS(bi))))
        »Õ¿◊≈
         ŒÕ≈÷
      »Õ¿◊≈
        Assert(ÀŒ∆‹, line, col, 37)
       ŒÕ≈÷;
      TRes := Ta
    |lxDIV, lxMOD:
      Assert(Ta.tType = TINTEGER, line, col, 37);
      Assert(bi # 0, line, col, 48);
      TRes := Ta;
      Res := Arith(a, b, Ta, Op, line, col)
    |lxAnd:
      Assert(Ta.tType = TBOOLEAN, line, col, 37);
      Res := LONG(FLT(ORD((ai # 0) & (bi # 0))))
    |Ï ÓÌÒÚ.lxOR:
      Assert(Ta.tType = TBOOLEAN, line, col, 37);
      Res := LONG(FLT(ORD((ai # 0) »À» (bi # 0))))
    |lxEQ, lxNE:
      ≈—À» Ta.tType = TSTRING “Œ√ƒ¿
        Res := strcmp(a, b, Op)
      »Õ¿◊≈
        Res := LONG(FLT(ORD(a = b)))
       ŒÕ≈÷;
      ≈—À» Op = lxNE “Œ√ƒ¿
        Res := LONG(FLT(ORD(Res = 0.0D0)))
       ŒÕ≈÷
    |lxLT, lxGT:
      ≈—À» Op = lxGT “Œ√ƒ¿
        c := a;
        a := b;
        b := c
       ŒÕ≈÷;
      Assert(Ta.tType IN {TSTRING, TINTEGER, TREAL, TLONGREAL}, line, col, 37);
      ≈—À» Ta.tType = TSTRING “Œ√ƒ¿
        Res := strcmp(a, b, Op)
      »Õ¿◊≈
        Res := LONG(FLT(ORD(a < b)))
       ŒÕ≈÷
    |lxLE, lxGE:
      ≈—À» Op = lxGE “Œ√ƒ¿
        c := a;
        a := b;
        b := c
       ŒÕ≈÷;
      Assert(Ta.tType IN {TSTRING, TINTEGER, TREAL, TLONGREAL, TSET}, line, col, 37);
      ≈—À» Ta.tType = TSTRING “Œ√ƒ¿
        Res := strcmp(a, b, Op)
      ¿≈—À» Ta.tType = TSET “Œ√ƒ¿
        Res := LONG(FLT(ORD(BITS(FLOOR(a)) <= BITS(FLOOR(b)))))
      »Õ¿◊≈
        Res := LONG(FLT(ORD(a <= b)))
       ŒÕ≈÷
    |Ï ÓÌÒÚ.ÍÒ¬:
      Assert((Ta.tType = TINTEGER) & (Tb.tType = TSET), line, col, 37);
      Assert(ASR(ai, 5) = 0, line, col, 49);
      Res := LONG(FLT(ORD(ai IN BITS(bi))))
    »Õ¿◊≈
     ŒÕ≈÷;
    ≈—À» Relation(Op) »À» (Op = lxAnd) »À» (Op = Ï ÓÌÒÚ.lxOR) “Œ√ƒ¿
      TRes := sttypes[TBOOLEAN]
     ŒÕ≈÷
   ŒÕ≈÷ Calc;

œ–Œ÷≈ƒ”–¿ ConstExpr*(œ≈– Value: LONGREAL; œ≈– T: pTYPE);
  œ≈–≈Ã e: EXPRESSION; line, col: INTEGER;
  Õ¿◊¿ÀŒ
    Const := »—“»Õ¿;
    Coord(line, col);
    sizefunc := ÀŒ∆‹;
    Expr(e);
    Assert(~sizefunc & (e.eType = eCONST), line, col, 62);
    Value := e.Value;
    T := e.T;
    Const := ÀŒ∆‹
   ŒÕ≈÷ ConstExpr;

œ–Œ÷≈ƒ”–¿ IdType*(œ≈– line, col: INTEGER): pTYPE;
  œ≈–≈Ã id: IDENT; Name: Ï—Í‡Ì.NODE; Unit: UNIT; Res: pTYPE;
  Õ¿◊¿ÀŒ
    Res := œ”—“Œ;
    Name := Ï—Í‡Ì.id;
    id := GetIdent(Name);
    ≈—À» id = œ”—“Œ “Œ√ƒ¿
      Coord(line, col);
      NamePtrBase := Name;
      Next
    »Õ¿◊≈
      ≈—À» id.iType = IDTYPE “Œ√ƒ¿
        Coord(line, col);
        Next;
        Res := id.T
      ¿≈—À» id.iType = IDMOD “Œ√ƒ¿
        Unit := id.Unit;
        Next;
        Check(lxDot);
        Next;
        Check(lxIDENT);
        Name := Ï—Í‡Ì.id;
        NamePtrBase := Name;
        id := GetQIdent(Unit, Name);
        ≈—À» Unit # unit “Œ√ƒ¿
          Assert2(id # œ”—“Œ, 42);
          Assert2(id.iType = IDTYPE, 77);
          Coord(line, col);
          Next;
          Res := id.T
        »Õ¿◊≈
          ≈—À» id = œ”—“Œ “Œ√ƒ¿
            Assert2((unit.Level = 3) & unit.typedecl, 42);
            Coord(line, col);
            Next;
            Res := œ”—“Œ
          »Õ¿◊≈
            Assert2(id.iType = IDTYPE, 77);
            Coord(line, col);
            Next;
            Res := id.T
           ŒÕ≈÷
         ŒÕ≈÷
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 77)
       ŒÕ≈÷
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ IdType;

œ–Œ÷≈ƒ”–¿ FieldOffset(Align, RecSize: INTEGER): INTEGER;
  Õ¿◊¿ÀŒ
    Assert2(RecSize <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - (Align - RecSize MOD Align) MOD Align, 83)
    ¬≈–Õ”“‹ RecSize + (Align - RecSize MOD Align) MOD Align
   ŒÕ≈÷ FieldOffset;

œ–Œ÷≈ƒ”–¿ Dim*(T: pTYPE): INTEGER;
  œ≈–≈Ã n: INTEGER;
  Õ¿◊¿ÀŒ
    n := 0;
    œŒ ¿ (T.tType = TARRAY) & (T.Len = 0) ƒ≈À¿“‹
      INC(n);
      T := T.Base
     ŒÕ≈÷
    ¬≈–Õ”“‹ n
   ŒÕ≈÷ Dim;

œ–Œ÷≈ƒ”–¿ SetFields(Tr, Tf: pTYPE; Rec: BOOLEAN);
  œ≈–≈Ã cur: FIELD;
  Õ¿◊¿ÀŒ
    cur := Tr.Fields.First(FIELD);
    œŒ ¿ cur.T # œ”—“Œ ƒ≈À¿“‹
      cur := cur.Next(FIELD)
     ŒÕ≈÷;
    œŒ ¿ cur # œ”—“Œ ƒ≈À¿“‹
      cur.T := Tf;
      ≈—À» Rec “Œ√ƒ¿
        ≈—À» Tf.Align > Tr.Align “Œ√ƒ¿
          Tr.Align := Tf.Align
         ŒÕ≈÷;
        ≈—À» Tr.Rec = record “Œ√ƒ¿
          cur.Offset := FieldOffset(Tf.Align, Tr.Size);
          Assert2(cur.Offset <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - Tf.Size, 83);
          Tr.Size := cur.Offset + Tf.Size
        ¿≈—À» Tr.Rec = noalign “Œ√ƒ¿
          cur.Offset := FieldOffset(1, Tr.Size);
          Assert2(cur.Offset <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - Tf.Size, 83);
          Tr.Size := cur.Offset + Tf.Size
        ¿≈—À» Tr.Rec = union “Œ√ƒ¿
          ≈—À» Tf.Size > Tr.Size “Œ√ƒ¿
            Tr.Size := Tf.Size
           ŒÕ≈÷;
          cur.Offset := 0
         ŒÕ≈÷
      »Õ¿◊≈
        Tr.Len := Tr.Len + 4 * (ORD((Tf.tType = TRECORD) & cur.ByRef) + Dim(Tf) + ORD((Tf.tType = TLONGREAL) & ~cur.ByRef) + 1)
       ŒÕ≈÷;
      cur := cur.Next(FIELD)
     ŒÕ≈÷
   ŒÕ≈÷ SetFields;

œ–Œ÷≈ƒ”–¿ GetField*(T: pTYPE; Name: Ï—Í‡Ì.NODE): FIELD;
  œ≈–≈Ã cur, Res: FIELD;
  Õ¿◊¿ÀŒ
    Res := œ”—“Œ;
    cur := T.Fields.First(FIELD);
    œŒ ¿ (cur # œ”—“Œ) & (cur.Name = Name) ƒ≈À¿“‹
      Res := cur;
      cur := œ”—“Œ
    ¿≈—À» cur # œ”—“Œ ƒ≈À¿“‹
      cur := cur.Next(FIELD)
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ GetField;

œ–Œ÷≈ƒ”–¿ Unique(T: pTYPE; Name: Ï—Í‡Ì.NODE): BOOLEAN;
  œ≈–≈Ã field: FIELD; res: BOOLEAN;
  Õ¿◊¿ÀŒ
    res := »—“»Õ¿;
    œŒ ¿ (T # œ”—“Œ) & res ƒ≈À¿“‹
      field := GetField(T, Name);
      ≈—À» field # œ”—“Œ “Œ√ƒ¿
        ≈—À» (field.Unit = unit) »À» field.Export “Œ√ƒ¿
          res := ÀŒ∆‹
         ŒÕ≈÷
       ŒÕ≈÷;
      T := T.Base
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ Unique;

œ–Œ÷≈ƒ”–¿ notrecurs(id: BOOLEAN; T: pTYPE): BOOLEAN;
    ¬≈–Õ”“‹ ~(id & (unit.Idents.Last(IDENT).iType = IDTYPE) & (unit.Idents.Last(IDENT).T = T) &
            (T.tType IN {TRECORD, TARRAY}))
   ŒÕ≈÷ notrecurs;

œ–Œ÷≈ƒ”–¿ ReadFields(T: pTYPE);
  œ≈–≈Ã Name: Ï—Í‡Ì.NODE; field: FIELD; Tf: pTYPE; line, col: INTEGER; id_T: BOOLEAN;
  Õ¿◊¿ÀŒ
    œŒ ¿ Ï—Í‡Ì.tLex = lxIDENT ƒ≈À¿“‹
      Name := Ï—Í‡Ì.id;
      Assert2(Unique(T, Name), 30);
      NEW(field);
      MemErr(field = œ”—“Œ);
      Ï”ÚËÎ¸.Push(T.Fields, field);
      field.Name := Name;
      field.T := œ”—“Œ;
      field.Export := ÀŒ∆‹;
      field.Unit := unit;
      Next;
      ≈—À» Ï—Í‡Ì.tLex = lxMult “Œ√ƒ¿
        Assert2(unit.Level = 3, 89);
        Assert2(unit.typedecl, 91);
        Assert2(unit.ExportType, 92);
        field.Export := »—“»Õ¿;
        Next
       ŒÕ≈÷;
      ≈—À» Ï—Í‡Ì.tLex = lxComma “Œ√ƒ¿
        Next;
        Check(lxIDENT)
      ¿≈—À» Ï—Í‡Ì.tLex = lxColon “Œ√ƒ¿
        Next;
        Coord(line, col);
        id_T := Ï—Í‡Ì.tLex = lxIDENT;
        Tf:= pParseType(line, col);
        Assert(Tf # œ”—“Œ, line, col, 42);
        Assert(notrecurs(id_T, Tf), line, col, 96);
        SetFields(T, Tf, »—“»Õ¿);
        ≈—À» Ï—Í‡Ì.tLex = lxSemi “Œ√ƒ¿
          Next;
          Check(lxIDENT)
        »Õ¿◊≈
          Assert2(Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒ ŒÕ≈÷, 86)
         ŒÕ≈÷
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 85)
       ŒÕ≈÷
     ŒÕ≈÷
   ŒÕ≈÷ ReadFields;

œ–Œ÷≈ƒ”–¿ OpenBase*(T: pTYPE): pTYPE;
  Õ¿◊¿ÀŒ
    œŒ ¿ (T.tType = TARRAY) & (T.Len = 0) ƒ≈À¿“‹
      T := T.Base
     ŒÕ≈÷
    ¬≈–Õ”“‹ T
   ŒÕ≈÷ OpenBase;

œ–Œ÷≈ƒ”–¿ SetVars(T: pTYPE);
  œ≈–≈Ã cur: IDENT; n: INTEGER;
  Õ¿◊¿ÀŒ
    cur := unit.Idents.Last(IDENT);
    œŒ ¿ cur.T = œ”—“Œ ƒ≈À¿“‹
      cur := cur.Prev(IDENT)
     ŒÕ≈÷;
    cur := cur.Next(IDENT);
    œŒ ¿ cur # œ”—“Œ ƒ≈À¿“‹
      cur.T := T;
      ≈—À» cur.Export “Œ√ƒ¿
        Assert(~(T.tType IN {TRECORD, TARRAY}), cur.line, cur.col, 90)
       ŒÕ≈÷;
      ≈—À»(cur.VarKind = paramvar) »À» (cur.VarKind = param) & (T.tType IN {TRECORD, TARRAY}) “Œ√ƒ¿
        n := 4 * (1 + Dim(T) + ORD((cur.VarKind = paramvar) & (T.tType = TRECORD)))
      »Õ¿◊≈
        n := T.Size;
        Assert2(n <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - Ï”ÚËÎ¸.Align(n), 93);
        n := n + Ï”ÚËÎ¸.Align(n)
       ŒÕ≈÷;
      ≈—À» cur.Level = 3 “Œ√ƒ¿
        cur.Offset := ProgSize;
        Assert2(ProgSize <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - n, 93);
        ProgSize := ProgSize + n;
        Assert2(ProgSize <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - Ï”ÚËÎ¸.Align(ProgSize), 93);
        ProgSize := ProgSize + Ï”ÚËÎ¸.Align(ProgSize)
      »Õ¿◊≈
        ≈—À» cur.VarKind = 0 “Œ√ƒ¿
          cur.Offset := curBlock.ParamSize - curBlock.VarSize - n
        »Õ¿◊≈
          cur.Offset := curBlock.VarSize - 8 + 4 * (cur.Level + ORD((cur.VarKind = paramvar) & (T.tType = TRECORD)))
         ŒÕ≈÷
       ŒÕ≈÷;
      Assert2(curBlock.VarSize <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - n, 93);
      curBlock.VarSize := curBlock.VarSize + n;
      Assert2(curBlock.VarSize <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ - Ï”ÚËÎ¸.Align(curBlock.VarSize), 93);
      curBlock.VarSize := curBlock.VarSize + Ï”ÚËÎ¸.Align(curBlock.VarSize);
      ≈—À» cur.VarKind # 0 “Œ√ƒ¿
        curBlock.ParamSize := curBlock.VarSize
       ŒÕ≈÷;
      cur := cur.Next(IDENT)
     ŒÕ≈÷
   ŒÕ≈÷ SetVars;

œ–Œ÷≈ƒ”–¿ CreateType(tType, Len, Size, Number: INTEGER; Base: pTYPE; Fields: BOOLEAN; NewType: pTYPE): pTYPE;
  œ≈–≈Ã nov: pTYPE;
  Õ¿◊¿ÀŒ
    ≈—À» NewType = œ”—“Œ “Œ√ƒ¿
      NEW(nov);
      MemErr(nov = œ”—“Œ)
    »Õ¿◊≈
      nov := NewType
     ŒÕ≈÷;
    Ï”ÚËÎ¸.Push(types, nov);
    nov.tType := tType;
    nov.Len := Len;
    nov.Size := Size;
    nov.Base := Base;
    nov.Fields := œ”—“Œ;
    nov.Number := Number;
    ≈—À» Fields “Œ√ƒ¿
      nov.Fields := Ï”ÚËÎ¸.CreateList();
      MemErr(nov.Fields = œ”—“Œ)
     ŒÕ≈÷
    ¬≈–Õ”“‹ nov
   ŒÕ≈÷ CreateType;

œ–Œ÷≈ƒ”–¿ FormalType(œ≈– line, col: INTEGER): pTYPE;
  œ≈–≈Ã TA: pTYPE;
  Õ¿◊¿ÀŒ
    ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒÃ¿——»¬ “Œ√ƒ¿
      Next;
      Check(Ï ÓÌÒÚ.ÍÒ»«);
      Next;
      TA := CreateType(TARRAY, 0, 0, 0, FormalType(line, col), ÀŒ∆‹, œ”—“Œ)
    »Õ¿◊≈
      Check(lxIDENT);
      TA := IdType(line, col);
      Assert(TA # œ”—“Œ, line, col, 42);
     ŒÕ≈÷
    ¬≈–Õ”“‹ TA
   ŒÕ≈÷ FormalType;

œ–Œ÷≈ƒ”–¿ Section(T: pTYPE);
  œ≈–≈Ã Name: Ï—Í‡Ì.NODE; ByRef, cont: BOOLEAN; field: FIELD;
      Tf: pTYPE; fp: IDENT; line, col: INTEGER; proc: BOOLEAN;
  Õ¿◊¿ÀŒ
    proc := T = œ”—“Œ;
    ≈—À» proc “Œ√ƒ¿
      T := curBlock.T
     ŒÕ≈÷;
    Assert2((Ï—Í‡Ì.tLex = lxIDENT) »À» (Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒœ≈–≈Ã), 84);
    ByRef := ÀŒ∆‹;
    ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒœ≈–≈Ã “Œ√ƒ¿
      ByRef := »—“»Õ¿;
      Next;
      Check(lxIDENT)
     ŒÕ≈÷;
    cont := »—“»Õ¿;
    œŒ ¿ cont ƒ≈À¿“‹
      Name := Ï—Í‡Ì.id;
      Assert2(GetField(T, Name) = œ”—“Œ, 30);
      NEW(field);
      MemErr(field = œ”—“Œ);
      Ï”ÚËÎ¸.Push(T.Fields, field);
      field.Name := Name;
      field.T := œ”—“Œ;
      field.ByRef := ByRef;
      ≈—À» proc “Œ√ƒ¿
        PushIdent(Name, line, col, IDVAR, œ”—“Œ, œ”—“Œ, ÀŒ∆‹, 0);
        INC(curBlock.ParamCount);
        fp := unit.Idents.Last(IDENT);
        ≈—À» ByRef “Œ√ƒ¿
          fp.VarKind := paramvar
        »Õ¿◊≈
          fp.VarKind := param
         ŒÕ≈÷
       ŒÕ≈÷;
      Next;
      ≈—À» Ï—Í‡Ì.tLex = lxComma “Œ√ƒ¿
        Next;
        Check(lxIDENT)
      ¿≈—À» Ï—Í‡Ì.tLex = lxColon “Œ√ƒ¿
        Next;
        Tf := FormalType(line, col);
        Assert(Dim(Tf) <= X86.ADIM, line, col, 110);
        SetFields(T, Tf, ÀŒ∆‹);
        ≈—À» proc “Œ√ƒ¿
          SetVars(Tf)
         ŒÕ≈÷;
        cont := ÀŒ∆‹
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 85)
       ŒÕ≈÷
     ŒÕ≈÷
   ŒÕ≈÷ Section;

œ–Œ÷≈ƒ”–¿ ParamType(T: pTYPE);
  œ≈–≈Ã break: BOOLEAN;
  Õ¿◊¿ÀŒ
    ≈—À» (Ï—Í‡Ì.tLex = lxIDENT) »À» (Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒœ≈–≈Ã) “Œ√ƒ¿
      break := ÀŒ∆‹;
      œŒ¬“Œ–ﬂ“‹
        Section(T);
        ≈—À» Ï—Í‡Ì.tLex = lxSemi “Œ√ƒ¿
          Next
        »Õ¿◊≈
          break := »—“»Õ¿
         ŒÕ≈÷
      œŒ ¿Õ≈ break
     ŒÕ≈÷
   ŒÕ≈÷ ParamType;

œ–Œ÷≈ƒ”–¿ AddPtrBase(Name: Ï—Í‡Ì.NODE; line, col: INTEGER; T: pTYPE);
  œ≈–≈Ã nov: PTRBASE;
  Õ¿◊¿ÀŒ
    NEW(nov);
    MemErr(nov = œ”—“Œ);
    nov.Name := Name;
    nov.line := line;
    nov.col := col;
    nov.Ptr := T;
    Ï”ÚËÎ¸.Push(PtrBases, nov)
   ŒÕ≈÷ AddPtrBase;

œ–Œ÷≈ƒ”–¿ FormalList(T: pTYPE; œ≈– Res: pTYPE);
  œ≈–≈Ã line, col: INTEGER;
  Õ¿◊¿ÀŒ
    ≈—À» Ï—Í‡Ì.tLex = lxLRound “Œ√ƒ¿
      Next;
      ParamType(T);
      Check(lxRRound);
      Next;
      ≈—À» Ï—Í‡Ì.tLex = lxColon “Œ√ƒ¿
        Next;
        Check(lxIDENT);
        Res := IdType(line, col);
        Assert(Res # œ”—“Œ, line, col, 42);
        Assert(~(Res.tType IN {TRECORD, TARRAY}), line, col, 82)
       ŒÕ≈÷
     ŒÕ≈÷
   ŒÕ≈÷ FormalList;

œ–Œ÷≈ƒ”–¿ CallFlag(œ≈– Call: INTEGER): BOOLEAN;
  œ≈–≈Ã
    flag: Ï“ËÔ˚.tString;
    res: BOOLEAN;
  Õ¿◊¿ÀŒ
    res := Ï—Í‡Ì.tLex = lxLSquare;
    ≈—À» res “Œ√ƒ¿
      Next;
      Ï—Í‡Ì.GetLexStr(flag);
      ≈—À» flag = "cdecl" “Œ√ƒ¿
        Call := cdecl
      ¿≈—À» flag = "stdcall" “Œ√ƒ¿
        Call := stdcall
      ¿≈—À» flag = "winapi" “Œ√ƒ¿
        Assert2(winplatf, 50);
        Call := winapi
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 44)
       ŒÕ≈÷;
      Next;
      Check(lxRSquare);
      Next;
    »Õ¿◊≈
      Call := defcall
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ CallFlag;

œ–Œ÷≈ƒ”–¿ RecFlag(œ≈– rec: INTEGER): BOOLEAN;
  œ≈–≈Ã
    flag: Ï“ËÔ˚.tString;
    res: BOOLEAN;
  Õ¿◊¿ÀŒ
    res := Ï—Í‡Ì.tLex = lxLSquare;
    ≈—À» res “Œ√ƒ¿
      Next;
      Ï—Í‡Ì.GetLexStr(flag);
      ≈—À» flag = "union" “Œ√ƒ¿
        rec := union
      ¿≈—À» flag = "noalign" “Œ√ƒ¿
        rec := noalign
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 103)
       ŒÕ≈÷;
      Next;
      Check(lxRSquare);
      Next;
    »Õ¿◊≈
      rec := record
     ŒÕ≈÷
    ¬≈–Õ”“‹ res
   ŒÕ≈÷ RecFlag;

œ–Œ÷≈ƒ”–¿ StructType(Comma: BOOLEAN; NewType: pTYPE): pTYPE;
  œ≈–≈Ã v: LONGREAL; T, nov: pTYPE; line, col, line2, col2: INTEGER; id_T: BOOLEAN;
  Õ¿◊¿ÀŒ
    ¬€¡Œ– Ï—Í‡Ì.tLex »«
    |Ï ÓÌÒÚ.ÍÒÃ¿——»¬, lxComma:
      ≈—À» Ï—Í‡Ì.tLex = lxComma “Œ√ƒ¿
        Assert2(Comma, 39)
       ŒÕ≈÷;
      Next;
      Coord(line, col);
      ConstExpr(v, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      Assert(v > 0.0D0, line, col, 78);
      nov := CreateType(TARRAY, FLOOR(v), 0, 0, œ”—“Œ, ÀŒ∆‹, NewType);
      ≈—À» Ï—Í‡Ì.tLex = lxComma “Œ√ƒ¿
        nov.Base := StructType(»—“»Õ¿, œ”—“Œ)
      ¿≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒ»« “Œ√ƒ¿
        Next;
        Coord(line, col);
        id_T := Ï—Í‡Ì.tLex = lxIDENT;
        nov.Base := pParseType(line, col);
        Assert(nov.Base # œ”—“Œ, line, col, 42);
        Assert(notrecurs(id_T, nov.Base), line, col, 96)
      »Õ¿◊≈
        Assert2(ÀŒ∆‹, 79)
       ŒÕ≈÷;
      Assert2(nov.Base.Size <= Ï ÓÌÒÚ.ˆÂÎÓÂ_Ï‡ÍÒ DIV nov.Len, 83);
      nov.Size := nov.Base.Size * nov.Len;
      nov.Align := nov.Base.Align
    |Ï ÓÌÒÚ.ÍÒ«¿œ»—‹:
      Next;
      INC(RecCount);
      nov := CreateType(TRECORD, 0, 0, RecCount, œ”—“Œ, »—“»Õ¿, NewType);
      nov.Align := 1;
      Coord(line, col);
      ≈—À» RecFlag(nov.Rec) “Œ√ƒ¿
        Assert(unit.sys, line, col, 111)
       ŒÕ≈÷;
      Coord(line, col);
      ≈—À» Ï—Í‡Ì.tLex = lxLRound “Œ√ƒ¿
        Next;
        Coord(line2, col2);
        Check(lxIDENT);
        nov.Base := IdType(line, col);
        Assert(nov.Base # œ”—“Œ, line, col, 42);
        Assert(nov.Base.tType = TRECORD, line, col, 80);
        Assert(notrecurs(»—“»Õ¿, nov.Base), line, col, 96);
        nov.Size := nov.Base.Size;
        nov.Align := nov.Base.Align;
        Check(lxRRound);
        Next;
        Assert(nov.Rec = record, line, col, 112);
        Assert(nov.Base.Rec = record, line2, col2, 113)
       ŒÕ≈÷;
      ReadFields(nov);
      Check(Ï ÓÌÒÚ.ÍÒ ŒÕ≈÷);
      nov.Size := X86.Align(nov.Size, nov.Align);
      ≈—À» nov.Base # œ”—“Œ “Œ√ƒ¿
        X86.AddRec(nov.Base.Number)
      »Õ¿◊≈
        X86.AddRec(0)
       ŒÕ≈÷;
      Next
    |Ï ÓÌÒÚ.ÍÒ” ¿«¿“≈À‹:
      Next;
      Check(Ï ÓÌÒÚ.ÍÒƒŒ);
      Next;
      nov := CreateType(TPOINTER, 0, 4, 0, œ”—“Œ, ÀŒ∆‹, NewType);
      nov.Align := 4;
      Coord(line, col);
      nov.Base := pParseType(line, col);
      ≈—À» nov.Base = œ”—“Œ “Œ√ƒ¿
        Assert(unit.typedecl, line, col, 42);
        AddPtrBase(NamePtrBase, line, col, nov)
      »Õ¿◊≈
        Assert(nov.Base.tType = TRECORD, line, col, 81)
       ŒÕ≈÷
    |Ï ÓÌÒÚ.ÍÒœ–Œ÷≈ƒ”–¿:
      Next;
      nov := CreateType(TPROC, 0, 4, 0, sttypes[TVOID], »—“»Õ¿, NewType);
      Coord(line, col);
      ≈—À» CallFlag(nov.Call) “Œ√ƒ¿
        Assert(unit.sys, line, col, 111)
       ŒÕ≈÷;
      nov.Align := 4;
      FormalList(nov, nov.Base)
    »Õ¿◊≈
      Assert2(ÀŒ∆‹, 39)
     ŒÕ≈÷
    ¬≈–Õ”“‹ nov
   ŒÕ≈÷ StructType;

œ–Œ÷≈ƒ”–¿ ParseType(œ≈– line, col: INTEGER): pTYPE;
  œ≈–≈Ã Res: pTYPE;
  Õ¿◊¿ÀŒ
    ≈—À» Ï—Í‡Ì.tLex = lxIDENT “Œ√ƒ¿
      Res := IdType(line, col)
    »Õ¿◊≈
      Res := StructType(ÀŒ∆‹, œ”—“Œ)
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ ParseType;

œ–Œ÷≈ƒ”–¿ PopBlock;
  œ≈–≈Ã cur: IDENT; n: INTEGER;
  Õ¿◊¿ÀŒ
    cur := unit.Idents.Last(IDENT);
    n := 0;
    œŒ ¿ cur.iType # IDGUARD ƒ≈À¿“‹
      cur := cur.Prev(IDENT);
      INC(n)
     ŒÕ≈÷;
    cur := cur.Prev(IDENT);
    INC(n);
    unit.Idents.Count := unit.Idents.Count - n;
    unit.Idents.Last := cur;
    cur.Next := œ”—“Œ;
    DEC(unit.Level)
   ŒÕ≈÷ PopBlock;

œ–Œ÷≈ƒ”–¿ LinkPtr;
  œ≈–≈Ã cur: PTRBASE; id: IDENT;
  Õ¿◊¿ÀŒ
    cur := PtrBases.First(PTRBASE);
    œŒ ¿ cur # œ”—“Œ ƒ≈À¿“‹
      id := GetIdent(cur.Name);
      Assert(id # œ”—“Œ, cur.line, cur.col, 42);
      Assert(id.T.tType = TRECORD, cur.line, cur.col, 81);
      cur.Ptr.Base := id.T;
      cur := cur.Next(PTRBASE)
     ŒÕ≈÷;
    Ï”ÚËÎ¸.Clear(PtrBases)
   ŒÕ≈÷ LinkPtr;

œ–Œ÷≈ƒ”–¿ DeclSeq;
  œ≈–≈Ã Value: LONGREAL; T, NewType: pTYPE; Name: Ï—Í‡Ì.NODE; line, col, Call: INTEGER;
      Export, func: BOOLEAN; last, id: IDENT; e: EXPRESSION;

    œ–Œ÷≈ƒ”–¿ IdentDef;
    Õ¿◊¿ÀŒ
      Name := Ï—Í‡Ì.id;
      Coord(line, col);
      Next;
      Export := ÀŒ∆‹;
      ≈—À» Ï—Í‡Ì.tLex = lxMult “Œ√ƒ¿
        Assert2(unit.Level = 3, 89);
        Export := »—“»Õ¿;
        Next
       ŒÕ≈÷
     ŒÕ≈÷ IdentDef;

  Õ¿◊¿ÀŒ
    ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒ ŒÕ—“ “Œ√ƒ¿
      Next;
      œŒ ¿ Ï—Í‡Ì.tLex = lxIDENT ƒ≈À¿“‹
        IdentDef;
        PushIdent(Name, line, col, IDCONST, œ”—“Œ, œ”—“Œ, Export, 0);
        last := unit.Idents.Last(IDENT);
        Check(lxEQ);
        Next;
        ConstExpr(Value, T);
        Check(lxSemi);
        last.Value := Value;
        last.T := T;
        Next
       ŒÕ≈÷
     ŒÕ≈÷;
    ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒ“»œ€ “Œ√ƒ¿
      Ï”ÚËÎ¸.Clear(PtrBases);
      unit.typedecl := »—“»Õ¿;
      Next;
      œŒ ¿ Ï—Í‡Ì.tLex = lxIDENT ƒ≈À¿“‹
        IdentDef;
        PushIdent(Name, line, col, IDTYPE, œ”—“Œ, œ”—“Œ, Export, 0);
        last := unit.Idents.Last(IDENT);
        unit.ExportType := Export;
        Check(lxEQ);
        Next;
        NEW(NewType);
        MemErr(NewType = œ”—“Œ);
        last.T := NewType;
        T := StructType(ÀŒ∆‹, NewType);
        Check(lxSemi);
        Next
       ŒÕ≈÷
     ŒÕ≈÷;
    LinkPtr;
    unit.typedecl := ÀŒ∆‹;
    unit.ExportType := ÀŒ∆‹;
    ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒœ≈–≈Ã “Œ√ƒ¿
      Next;
      œŒ ¿ Ï—Í‡Ì.tLex = lxIDENT ƒ≈À¿“‹
        IdentDef;
        PushIdent(Name, line, col, IDVAR, œ”—“Œ, œ”—“Œ, Export, 0);
        ≈—À» Ï—Í‡Ì.tLex = lxComma “Œ√ƒ¿
          Next;
          Check(lxIDENT)
        ¿≈—À» Ï—Í‡Ì.tLex = lxColon “Œ√ƒ¿
          Next;
          Coord(line, col);
          T := ParseType(line, col);
          Assert(T # œ”—“Œ, line, col, 42);
          SetVars(T);
          Check(lxSemi);
          Next
        »Õ¿◊≈
          Assert2(ÀŒ∆‹, 85)
         ŒÕ≈÷
       ŒÕ≈÷
     ŒÕ≈÷;
    œŒ ¿ Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒœ–Œ÷≈ƒ”–¿ ƒ≈À¿“‹
      Next;
      Coord(line, col);
      ≈—À» CallFlag(Call) “Œ√ƒ¿
        Assert(unit.Level = 3, line, col, 45);
        Assert(unit.sys, line, col, 111)
       ŒÕ≈÷;
      Check(lxIDENT);
      IdentDef;
      PushIdent(Name, line, col, IDPROC, CreateType(TPROC, 0, 4, 0, sttypes[TVOID], »—“»Õ¿, œ”—“Œ), œ”—“Œ, Export, 0);
      id := unit.Idents.Last(IDENT);
      ≈—À» id.Export & main “Œ√ƒ¿
        ≈—À» Platform = 6 “Œ√ƒ¿
          Assert((Name # Ï—Í‡Ì._START) & (Name # Ï—Í‡Ì._version), line, col, 133)
         ŒÕ≈÷;
        X86.ProcExport(id.Number, Name, X86.NewLabel())
       ŒÕ≈÷;
      id.Parent := curBlock;
      curBlock := id;
      Guard;
      FormalList(œ”—“Œ, curBlock.T.Base);
      id.T.Call := Call;
      Check(lxSemi);
      Next;
      DeclSeq;
      id.LocalSize := id.VarSize - id.ParamSize;
      X86.ProcBeg(id.Number, id.LocalSize, ÀŒ∆‹);
      ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒÕ¿◊¿ÀŒ “Œ√ƒ¿
        Next;
        OpSeq
       ŒÕ≈÷;
      func := curBlock.T.Base.tType # TVOID;
      ≈—À» func “Œ√ƒ¿
        Check(Ï ÓÌÒÚ.ÍÒ¬≈–Õ”“‹);
        Ï”ÚËÎ¸.UnitLine(UnitNumber, Ï—Í‡Ì.line);
        Next;
        Coord(line, col);
        Expr(e);
        Assert(AssComp(e, curBlock.T.Base, ÀŒ∆‹), line, col, 125);
        ≈—À» e.eType = eVAR “Œ√ƒ¿
          X86.Load(e.T.tType)
         ŒÕ≈÷
      »Õ¿◊≈
        Assert2(Ï—Í‡Ì.tLex # Ï ÓÌÒÚ.ÍÒ¬≈–Õ”“‹, 123)
       ŒÕ≈÷;
      Check(Ï ÓÌÒÚ.ÍÒ ŒÕ≈÷);
      Next;
      Check(lxIDENT);
      Assert2(Ï—Í‡Ì.id = Name, 87);
      Next;
      Check(lxSemi);
      Next;
      X86.ProcEnd(id.Number, (id.ParamSize + (id.Level - 3) * 4) * ORD(curBlock.T.Call IN {stdcall, winapi, defcall}), func, curBlock.T.Base.tType IN {TREAL, TLONGREAL});
      PopBlock;
      curBlock := curBlock.Parent
     ŒÕ≈÷
   ŒÕ≈÷ DeclSeq;

œ–Œ÷≈ƒ”–¿ Rtl(u: UNIT);

    œ–Œ÷≈ƒ”–¿ AddProc(name: Ï“ËÔ˚.tString; num: INTEGER);
    œ≈–≈Ã id: IDENT;
    Õ¿◊¿ÀŒ
      id := GetQIdent(u, Ï—Í‡Ì.AddNode(name));
      ≈—À» id = œ”—“Œ “Œ√ƒ¿
        Ï”ÚËÎ¸.ErrMsg(158);
        Ï”ÚËÎ¸.HALT(1)
       ŒÕ≈÷;
      X86.AddRtlProc(num, id.Number)
     ŒÕ≈÷ AddProc;

  Õ¿◊¿ÀŒ
    AddProc("_newrec", X86._newrec);
    AddProc("_disprec", X86._disprec);
    AddProc("_rset", X86._rset);
    AddProc("_inset", X86._inset);
    AddProc("_saverec", X86._saverec);
    AddProc("_checktype", X86._checktype);
    AddProc("_strcmp", X86._strcmp);
    AddProc("_lstrcmp", X86._lstrcmp);
    AddProc("_rstrcmp", X86._rstrcmp);
    AddProc("_savearr", X86._savearr);
    AddProc("_arrayidx", X86._arrayidx);
    AddProc("_arrayidx1", X86._arrayidx1);
    AddProc("_arrayrot", X86._arrayrot);
    AddProc("_assrt", X86._assrt);
    AddProc("_strcopy", X86._strcopy);
    AddProc("_init", X86._init);
    AddProc("_close", X86._close);
    AddProc("_halt", X86._halt);
    AddProc("_length", X86._length);
   ŒÕ≈÷ Rtl;

œ–Œ÷≈ƒ”–¿ ImportList;
  œ≈–≈Ã cond, col, line, namecol, nameline: INTEGER;
      name, alias: Ï—Í‡Ì.NODE; u, self: UNIT;
      FName: Ï“ËÔ˚.tString;

    œ–Œ÷≈ƒ”–¿ AddUnit(newcond: INTEGER);
    œ≈–≈Ã str: STRITEM;
    Õ¿◊¿ÀŒ
      u := GetModule(name);
      ≈—À» u = œ”—“Œ “Œ√ƒ¿
        self := unit;
        Ï—Í‡Ì.Backup(unit.scanner);
        COPY(name.Name, FName);
        ≈—À» ~((~self.Std & pReadModule(Path, FName, Ï ÓÌÒÚ.‡Ò¯Ë)) »À»
                                pReadModule(Std, FName, Ï ÓÌÒÚ.‡Ò¯Ë)) “Œ√ƒ¿
          ≈—À» FName = "SYSTEM" “Œ√ƒ¿
            unit := sys;
            self.sys := »—“»Õ¿
          »Õ¿◊≈
            Assert(ÀŒ∆‹, nameline, namecol, 32)
           ŒÕ≈÷
         ŒÕ≈÷;
        Ï—Í‡Ì.Recover(self.scanner);
        u := unit;
        unit := self;
        Ï”ÚËÎ¸.SetFile(unit.File)
      »Õ¿◊≈
        Assert(u.Closed, nameline, namecol, 31)
       ŒÕ≈÷;
      PushIdent(alias, line, col, IDMOD, sttypes[TVOID], u, ÀŒ∆‹, 0);
      NEW(str);
      MemErr(str = œ”—“Œ);
      str.Str := name.Name;
      Ï”ÚËÎ¸.Push(unit.Import, str);
      cond := newcond
     ŒÕ≈÷ AddUnit;

  Õ¿◊¿ÀŒ
    cond := 0;
    œŒ ¿ cond # 4 ƒ≈À¿“‹
      Next;
      ¬€¡Œ– cond »«
      |0: Check(lxIDENT);
          name := Ï—Í‡Ì.id;
          Coord(line, col);
          Coord(nameline, namecol);
          alias := name;
          cond := 1
      |1: ¬€¡Œ– Ï—Í‡Ì.tLex »«
          |lxComma:  AddUnit(0)
          |lxSemi:   AddUnit(4); Next
          |lxAssign: cond := 2
          »Õ¿◊≈
            Assert2(ÀŒ∆‹, 28)
           ŒÕ≈÷
      |2: Check(lxIDENT);
          name := Ï—Í‡Ì.id;
          Coord(nameline, namecol);
          cond := 3
      |3: ¬€¡Œ– Ï—Í‡Ì.tLex »«
          |lxComma: AddUnit(0)
          |lxSemi:  AddUnit(4); Next
          »Õ¿◊≈
            Assert2(ÀŒ∆‹, 29)
           ŒÕ≈÷
      »Õ¿◊≈
       ŒÕ≈÷
     ŒÕ≈÷
   ŒÕ≈÷ ImportList;

œ–Œ÷≈ƒ”–¿ Header(Name: Ï—Í‡Ì.NODE);
  Õ¿◊¿ÀŒ
    NEW(unit);
    MemErr(unit = œ”—“Œ);
    unit.Idents := Ï”ÚËÎ¸.CreateList();
    MemErr(unit.Idents = œ”—“Œ);
    unit.Level := 0;
    unit.Name := Name;
    Guard; Guard;
    PushIdent(unit.Name, 0, 0, IDMOD, sttypes[TVOID], unit, ÀŒ∆‹, 0);
    Guard;
    unit.IdentBegin := unit.Idents.Last(IDENT);
    unit.Closed := »—“»Õ¿
   ŒÕ≈÷ Header;

œ–Œ÷≈ƒ”–¿ Pseudo;
  œ≈–≈Ã temp: UNIT;
  Õ¿◊¿ÀŒ
    temp := unit;
    Header(Ï—Í‡Ì.AddNode("SYSTEM"));
    PushSysProc("ADR",     sysADR);
    PushSysProc("SIZE",    sysSIZE);
    PushSysProc("TYPEID",  sysTYPEID);
    PushSysProc("BIT",     sysBIT);
    PushSysProc("GET",     sysGET);
    PushSysProc("PUT",     sysPUT);
    PushSysProc("CODE",    sysCODE);
    PushSysProc("MOVE",    sysMOVE);
    PushSysType("CARD16",  TCARD16);
    sys := unit;
    unit := temp
   ŒÕ≈÷ Pseudo;

œ–Œ÷≈ƒ”–¿ ReadModule(Path, Name1, Ext: Ï“ËÔ˚.tString): BOOLEAN;
  œ≈–≈Ã FHandle: INTEGER; name, Name, b: Ï“ËÔ˚.tString; idmod: IDENT; Res, temp: BOOLEAN;
  Õ¿◊¿ÀŒ
    Res := ÀŒ∆‹;
    name := Name1;
    Name := Name1;
    Ï”ÚËÎ¸.concat(Path, Name, b);
    Ï”ÚËÎ¸.concat(b, Ext, Name);
    ≈—À» Ï—Í‡Ì.Open(Name, FHandle) “Œ√ƒ¿
      NEW(unit);
      MemErr(unit = œ”—“Œ);
      unit.sys := ÀŒ∆‹;
      unit.Std := Path = Std;
      Ï”ÚËÎ¸.Push(prog, unit);
      unit.Idents := Ï”ÚËÎ¸.CreateList();
      MemErr(unit.Idents = œ”—“Œ);
      unit.Import := Ï”ÚËÎ¸.CreateList();
      MemErr(unit.Import = œ”—“Œ);
      NEW(unit.scanner);
      MemErr(unit.scanner = œ”—“Œ);
      unit.Closed := ÀŒ∆‹;
      unit.Level := 0;
      unit.typedecl := ÀŒ∆‹;
      unit.ExportType := ÀŒ∆‹;
      COPY(Name, unit.File);
      Ï”ÚËÎ¸.SetFile(unit.File);
      StIdent;
      Next; Check(Ï ÓÌÒÚ.ÍÒÃŒƒ”À‹);
      
      Next; Check(lxIDENT);
      Assert2(Ï”ÚËÎ¸.streq(Ï—Í‡Ì.id.Name, name), 33);
      unit.Name := Ï—Í‡Ì.id;
      PushIdent(unit.Name, Ï—Í‡Ì.line, Ï—Í‡Ì.col, IDMOD, sttypes[TVOID], unit, ÀŒ∆‹, 0);
      idmod := unit.Idents.Last(IDENT);
      Guard;
      Next; Check(lxSemi);
      Next;
      ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒ»ÃœŒ–“ “Œ√ƒ¿
        temp := main;
        main := ÀŒ∆‹;
        ImportList;
        main := temp
       ŒÕ≈÷;
      Ï”ÚËÎ¸.OutString("ÍÓÏÔËÎËÛ˛ "); Ï”ÚËÎ¸.OutString(unit.Name.Name); Ï”ÚËÎ¸.Ln;
      X86.Module(idmod.Name.Name, idmod.Number);
      UnitNumber := idmod.Number;
      unit.IdentBegin := unit.Idents.Last(IDENT);
      curBlock := idmod;
      DeclSeq;
      X86.ProcBeg(idmod.Number, 0, »—“»Õ¿);
      ≈—À» Ï—Í‡Ì.tLex = Ï ÓÌÒÚ.ÍÒÕ¿◊¿ÀŒ “Œ√ƒ¿
        Next;
        OpSeq
       ŒÕ≈÷;
      Check(Ï ÓÌÒÚ.ÍÒ ŒÕ≈÷);
      Next; Check(lxIDENT);
      Assert2(Ï—Í‡Ì.id = unit.Name, 26);
      Next; Check(lxDot);
      X86.Leave;
      unit.Closed := »—“»Õ¿;
      Ï”ÚËÎ¸.Clear(unit.Import);
      Res := »—“»Õ¿
     ŒÕ≈÷
    ¬≈–Õ”“‹ Res
   ŒÕ≈÷ ReadModule;

œ–Œ÷≈ƒ”–¿ Program*(StdPath, FilePath, NameFile, ExtFile: Ï“ËÔ˚.tString; windows: BOOLEAN;
    OpSeqProc: opPROC; ExprProc: expPROC; AssCompProc: assPROC; œ≈– stypes: stTYPES);
  Õ¿◊¿ÀŒ
    winplatf := windows;
    Path := FilePath;
    Main := NameFile;
    ExtMain := ExtFile;
    Std := StdPath;
    OpSeq := OpSeqProc;
    Expr := ExprProc;
    AssComp := AssCompProc;
    prog := Ï”ÚËÎ¸.CreateList();
    MemErr(prog = œ”—“Œ);
    PtrBases := Ï”ÚËÎ¸.CreateList();
    MemErr(PtrBases = œ”—“Œ);
    types := Ï”ÚËÎ¸.CreateList();
    MemErr(types = œ”—“Œ);
    StTypes;
    Strings := Ï”ÚËÎ¸.CreateList();
    MemErr(Strings = œ”—“Œ);
    Pseudo;
    stypes := sttypes
   ŒÕ≈÷ Program;

œ–Œ÷≈ƒ”–¿ delfirstchar(œ≈– s: Ï“ËÔ˚.tString);
  œ≈–≈Ã i: INTEGER;
  Õ¿◊¿ÀŒ
    ƒÀﬂ i := 0 ƒŒ LENGTH(s) - 1 ƒ≈À¿“‹
      s[i] := s[i + 1]
     ŒÕ≈÷
   ŒÕ≈÷ delfirstchar;

œ–Œ÷≈ƒ”–¿ Compile*(platform, stksize: INTEGER);
  œ≈–≈Ã full, path, name, ext, temp, path2: Ï“ËÔ˚.tString;
  Õ¿◊¿ÀŒ
    Platform := platform;
    main := ÀŒ∆‹;
    ≈—À» ReadModule(Std, "RTL", Ï ÓÌÒÚ.‡Ò¯Ë) “Œ√ƒ¿
      Rtl(unit)
    »Õ¿◊≈
      Ï”ÚËÎ¸.ErrMsg(65);
      Ï”ÚËÎ¸.HALT(1)
     ŒÕ≈÷;
    main := »—“»Õ¿;
    ≈—À» ~ReadModule(Path, Main, ExtMain) “Œ√ƒ¿
      path2 := Path;
      Ï”ÚËÎ¸.ParamStr(full, 0);
      Ï”ÚËÎ¸.Split(full, path, name, ext);
      ≈—À» path[0] # 0X “Œ√ƒ¿
        path[LENGTH(path) - 1] := 0X
       ŒÕ≈÷;
      ≈—À» Path[0] = Ï ÓÌÒÚ.ÒÎ˝¯ “Œ√ƒ¿
        delfirstchar(Path)
       ŒÕ≈÷;
      Ï”ÚËÎ¸.concat(path, Ï ÓÌÒÚ.ÒÎ˝¯, path);
      Ï”ÚËÎ¸.concat(path, Path, full);
      Path := full;
      ≈—À» (Ï ÓÌÒÚ.Œ— = "WIN") & (Path[0] = Ï ÓÌÒÚ.ÒÎ˝¯) “Œ√ƒ¿
        delfirstchar(Path)
       ŒÕ≈÷;
      ≈—À» ~ReadModule(Path, Main, ExtMain) “Œ√ƒ¿
        Ï”ÚËÎ¸.ErrMsg(64);
        Ï”ÚËÎ¸.OutString(path2);
        Ï”ÚËÎ¸.OutString(Main);
        Ï”ÚËÎ¸.OutString(ExtMain);
        Ï”ÚËÎ¸.Ln;
        Ï”ÚËÎ¸.HALT(1)
       ŒÕ≈÷
     ŒÕ≈÷;
    temp := Path;
    Ï”ÚËÎ¸.concat(temp, Main, temp);
    ≈—À» platform IN {2, 3} “Œ√ƒ¿
      Ï”ÚËÎ¸.concat(temp, ".exe", temp)
    ¿≈—À» platform = 1 “Œ√ƒ¿
      Ï”ÚËÎ¸.concat(temp, ".dll", temp)
    ¿≈—À» platform = 4 “Œ√ƒ¿
      Ï”ÚËÎ¸.concat(temp, ".kex", temp)
    ¿≈—À» platform = 6 “Œ√ƒ¿
      Ï”ÚËÎ¸.concat(temp, ".obj", temp)
     ŒÕ≈÷;
    ≈—À» platform IN {1, 2, 3, 4} “Œ√ƒ¿
      stksize := stksize * 100000H
     ŒÕ≈÷;
    X86.Epilog(ProgSize, temp, stksize)
   ŒÕ≈÷ Compile;

Õ¿◊¿ÀŒ
  pParseType := ParseType;
  pReadModule := ReadModule
 ŒÕ≈÷ ÏÓ‰ƒÂˆÎ.
