(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.
   *)

МОДУЛЬ модДецл;

ИМПОРТ мСкан := модСканер,
   мУтиль := модУтиль,
   мАсм86 := модАсм86_32,
   mSys := SYSTEM,
   мЗвено := модЗвено,
   мТип := модТип,
   мФайл := модФайл,
   мКонст := модКонстанты,
   мКонс := модКонсоль,
   мПам := модПамять,
   мПроц := модПроцесс,
   мОш := модОшибки,
   мСтр := модСтроки,
   мЦепь := модЦепь,
   мПров := модПроверка,
   мУзел := модУзел,
   мВинКонс := модВинКонсоль;

КОНСТ

   lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
   lxBY = 3;
   lxDIV = 6;
   lxMOD = 17;

   lxLRound = 60; lxCaret = 63;
   lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
   lxLE = 75; lxGE = 76;

   lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
   lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

   IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

   paramvar* = 1; param* = 2;
 
   defcall = 0; stdcall = 1; cdecl = 2; winapi* = 3;

   record = 0; union = 1; noalign = 2;

   eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

   IOVER* = lxERR5 - lxERR0;
   FOVER* = lxERR7 - lxERR0;
   UNDER* = lxERR9 - lxERR0;

ТИПЫ

   туСущность* = УКАЗАТЕЛЬ НА тСущность;

   туМодуль* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         уУзел: мУзел.туУзел;
         файл_стр: мСтр.тСтрока;
         Idents:      мЦепь.туЦепь;
         импорт_спис: мЦепь.туЦепь;
         IdentBegin: туСущность;
         сканер: мСкан.туСканер;
         уровень*: ЦЕЛОЕ;
         закрыт, typedecl, ExportType, Std, системный: БУЛЕВО
      КОНЕЦ;

   тСущность* = ЗАПИСЬ (мЗвено.тЗвено)
         уУзел: мУзел.туУзел;
         T*: мТип.туТип;
         модуль*: туМодуль;
         Parent*: туСущность;
         Value*: ДЛИНВЕЩ;
         line*, col*, Number*, iType*, StProc*, VarSize, ParamSize*,
         LocalSize*, Offset*, VarKind*, Level*, ParamCount*: ЦЕЛОЕ;
         Export: БУЛЕВО
      КОНЕЦ;

   PTRBASE = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         Name: мУзел.туУзел;
         line, col: ЦЕЛОЕ;
         Ptr: мТип.туТип
      КОНЕЦ;

   туПунктСтр = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         Str: мСтр.тСтрока
      КОНЕЦ;

   туПоле* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         Name: мУзел.туУзел;
         T*: мТип.туТип;
         Offset*: ЦЕЛОЕ;
         ByRef*, Export*: БУЛЕВО;
         Unit*: туМодуль
      КОНЕЦ;

   туКонстСтр* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         стр*: мСтр.тСтрока;
         длина*, номер*: ЦЕЛОЕ
      КОНЕЦ;

   тВыражение* = ЗАПИСЬ
         id*: туСущность;
         T*: мТип.туТип;
         eType*: ЦЕЛОЕ;
         Value*: ДЛИНВЕЩ;
         Read*, vparam*, deref*: БУЛЕВО
      КОНЕЦ;

   тПроцедура = ПРОЦЕДУРА;
   тПроцедураПер = ПРОЦЕДУРА (ПЕР e: тВыражение);
   тПроцедураСвязь = ПРОЦЕДУРА (e: тВыражение; T: мТип.туТип; param: БУЛЕВО): БУЛЕВО;

   туТипНабор* = МАССИВ 11 ИЗ мТип.туТип;

ПЕРЕМ

   sttypes: туТипНабор;
   модуль*, мод_систем: туМодуль;
   curBlock*: туСущность;
   Path, Main, Std, ExtMain: мСтр.тСтрока;
   NamePtrBase: мУзел.туУзел;
   ProgSize*, RecCount, UnitNumber*: ЦЕЛОЕ;
   PtrBases, строки, types, prog: мЦепь.туЦепь;
   OpSeq: тПроцедура;
   Expr: тПроцедураПер;
   AssComp: тПроцедураСвязь;
   main, sizefunc, winplatf, Const*: БУЛЕВО;
   pParseType: ПРОЦЕДУРА (ПЕР line, col: ЦЕЛОЕ): мТип.туТип;
   пМодуль_Читать: ПРОЦЕДУРА (Path, Name, Ext: мСтр.тСтрока): БУЛЕВО;
   цКодОС: ЦЕЛОЕ;

ПРОЦЕДУРА ПроцедурРазм_Уст*;
   НАЧАЛО
      sizefunc := ИСТИНА
   КОНЕЦ ПроцедурРазм_Уст;

ПРОЦЕДУРА уКонстСтр_Получ*(adr: ДЛИНВЕЩ): туКонстСтр;
    ПЕРЕМ
        уКонстСтр: туКонстСтр;
    НАЧАЛО
        mSys.PUT(mSys.ADR(уКонстСтр), FLOOR(adr))
        ВЕРНУТЬ уКонстСтр
    КОНЕЦ уКонстСтр_Получ;

ПРОЦЕДУРА Стр_Создать*(стр_: мСтр.тСтрока): туКонстСтр;
    ПЕРЕМ
        стр_нов: туКонстСтр;
    НАЧАЛО
        НОВ(стр_нов);
        мПам.Мало(стр_нов = ПУСТО);
        COPY(стр_, стр_нов.стр);
        стр_нов.длина := мСкан.счётчик - 1;
        стр_нов.номер := мАсм86.NewLabel();
        мЦепь.Добавить(строки, стр_нов);
        мАсм86.String(стр_нов.номер, стр_нов.длина, стр_нов.стр)
        ВЕРНУТЬ стр_нов
    КОНЕЦ Стр_Создать;

ПРОЦЕДУРА СтрМоно_Создать*(c: ЛИТ): туКонстСтр;
  ПЕРЕМ
    nov: туКонстСтр;
  НАЧАЛО
    НОВ(nov);
    мПам.Мало(nov = ПУСТО);
    nov.стр[0] := c;
    nov.стр[1] := 0X;
    nov.длина := 1;
    nov.номер := мАсм86.NewLabel();
    мЦепь.Добавить(строки, nov);
    мАсм86.String(nov.номер, nov.длина, nov.стр)
    ВЕРНУТЬ nov
  КОНЕЦ СтрМоно_Создать;

ПРОЦЕДУРА Коорд_Уст*(ПЕР line, col: ЦЕЛОЕ);
  НАЧАЛО
    line := мСкан.цСтрока;
    col := мСкан.col
  КОНЕЦ Коорд_Уст;

ПРОЦЕДУРА Модуль_Получ(Name: мУзел.туУзел): туМодуль;
   ПЕРЕМ
      cur, res: туМодуль;
   НАЧАЛО
      res := ПУСТО;
      cur := prog.предыдущ(туМодуль);
      ПОКА (cur # ПУСТО) & мСтр.Сравнить(cur.уУзел.имя_стр, Name.имя_стр) ДЕЛАТЬ
         res := cur;
         cur := ПУСТО
      АЕСЛИ cur # ПУСТО ДЕЛАТЬ
         cur := cur.следующ(туМодуль)
      КОНЕЦ
      ВЕРНУТЬ res
   КОНЕЦ Модуль_Получ;

ПРОЦЕДУРА КлючСлед_Получ*;
  НАЧАЛО
    мСкан.Лексема_Получ;
    ЕСЛИ (мСкан.сущность > lxERR0) & (мСкан.сущность < lxERR20) ТОГДА
      мПров.Тест(ЛОЖЬ, мСкан.цСтрока, мСкан.col + мСкан.счётчик, мСкан.сущность - lxERR0)
    КОНЕЦ;
    мПров.Тест2(мСкан.сущность # lxEOF, 27)
  КОНЕЦ КлючСлед_Получ;

ПРОЦЕДУРА Ключ_Проверить*(key: ЦЕЛОЕ);
   ПЕРЕМ
      code: ЦЕЛОЕ;
   НАЧАЛО
      ЕСЛИ мСкан.сущность # key ТОГДА
         ВЫБОР key ИЗ
            |мКонст.ксМОДУЛЬ:  code := 21
            |lxIDENT:   code := 22
            |мКонст.опТчкЗпт:    code := 23
            |мКонст.ксКОНЕЦ:     code := 24
            |lxDot:     code := 25
            |мКонст.опРавно:      code := 35
            |мКонст.опСкобкаПрКр:  code := 38
            |мКонст.ксДО:      code := 40
            |мКонст.ксИЗ:      code := 41
            |lxRCurly:  code := 51
            |lxLRound:  code := 56
            |мКонст.опЗапятая:   code := 61
            |мКонст.ксТОГДА:    code := 98
            |мКонст.опСкобкаПрКв: code := 109
            |мКонст.ксДЕЛАТЬ:      code := 118
            |мКонст.ксПОКАНЕ:   code := 119
            |lxAssign:  code := 120
            |мКонст.ксВЕРНУТЬ:  code := 124
            |мКонст.опДвоеточ:   code := 157
         ИНАЧЕ
         КОНЕЦ;
         мПров.Тест2(ЛОЖЬ, code)
      КОНЕЦ
   КОНЕЦ Ключ_Проверить;

ПРОЦЕДУРА CheckIdent(Name: мУзел.туУзел): БУЛЕВО;
   ПЕРЕМ
      cur: туСущность;
   НАЧАЛО
      cur := модуль.Idents.следующ(туСущность);
      ПОКА (cur.iType # IDGUARD) & (cur.уУзел # Name) ДЕЛАТЬ
         cur := cur.предыдущ(туСущность)
      КОНЕЦ
      ВЕРНУТЬ cur.iType = IDGUARD
   КОНЕЦ CheckIdent;

ПРОЦЕДУРА Охрана_Создать;
   ПЕРЕМ
      ident: туСущность;
   НАЧАЛО
      НОВ(ident);
      мПам.Мало(ident = ПУСТО);
      ident.уУзел := ПУСТО;
      ident.iType := IDGUARD;
      ident.T := sttypes[мКонст.TVOID];
      мЦепь.Добавить(модуль.Idents, ident);
      ДОБ(модуль.уровень)
   КОНЕЦ Охрана_Создать;

ПРОЦЕДУРА PushIdent(Name: мУзел.туУзел; line, col, iType: ЦЕЛОЕ; T: мТип.туТип; u: туМодуль; Export: БУЛЕВО; StProc: ЦЕЛОЕ);
   ПЕРЕМ
      ident: туСущность;
      i: ЦЕЛОЕ;
   НАЧАЛО
      мПров.Тест(CheckIdent(Name), line, col, 30);
      НОВ(ident);
      мПам.Мало(ident = ПУСТО);
      ident.уУзел := Name;
      ident.line := line;
      ident.col := col;
      ЕСЛИ iType IN {IDPROC, IDMOD} ТОГДА
         ident.Number := мАсм86.NewLabel();
         i := мАсм86.NewLabel();
         i := мАсм86.NewLabel();
         i := мАсм86.NewLabel()
      КОНЕЦ;
      ident.iType := iType;
      ident.T := T;
      ident.модуль := u;
      ident.Export := Export;
      ident.StProc := StProc;
      ident.Level := модуль.уровень;
      мЦепь.Добавить(модуль.Idents, ident)
   КОНЕЦ PushIdent;

ПРОЦЕДУРА StTypes;
   ПЕРЕМ
      type: мТип.туТип;
      i: ЦЕЛОЕ;
   НАЧАЛО
      sttypes[0] := ПУСТО;
      ДЛЯ i := мКонст.типЦЕЛОЕ ДО мКонст.типСТРОКА ДЕЛАТЬ
         НОВ(type);
         мПам.Мало(type = ПУСТО);
         type.тип_ном := i;
         мЦепь.Добавить(types, type);
         sttypes[i] := type
      КОНЕЦ;
      sttypes[мКонст.типЦЕЛОЕ].размер := 4;
      sttypes[мКонст.типВЕЩ].размер := 4;
      sttypes[мКонст.типДЛИНВЕЩ].размер := 8;
      sttypes[мКонст.типБУЛЕВО].размер := 1;
      sttypes[мКонст.типЛИТЕРА].размер := 1;
      sttypes[мКонст.типНАБОР].размер := 4;
      sttypes[мКонст.TVOID].размер := 0;
      sttypes[мКонст.типСТРОКА].размер := 0;
      sttypes[мКонст.типПУСТО].размер := 4;
      sttypes[мКонст.TCARD16].размер := 2;
      ДЛЯ i := мКонст.типЦЕЛОЕ ДО мКонст.типСТРОКА ДЕЛАТЬ
         sttypes[i].выравнив := sttypes[i].размер
      КОНЕЦ
   КОНЕЦ StTypes;

ПРОЦЕДУРА PushStProc(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мУзел.Добавить(Name), 0, 0, IDSTPROC, sttypes[мКонст.TVOID], ПУСТО, ЛОЖЬ, StProc)
  КОНЕЦ PushStProc;

ПРОЦЕДУРА PushStType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
   НАЧАЛО
      PushIdent(мУзел.Добавить(Name), 0, 0, IDTYPE, sttypes[T], ПУСТО, ЛОЖЬ, 0)
   КОНЕЦ PushStType;

ПРОЦЕДУРА PushSysProc(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
   НАЧАЛО
      PushIdent(мУзел.Добавить(Name), 0, 0, IDSYSPROC, sttypes[мКонст.TVOID], ПУСТО, ИСТИНА, StProc)
   КОНЕЦ PushSysProc;

ПРОЦЕДУРА PushSysType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мУзел.Добавить(Name), 0, 0, IDTYPE, sttypes[T], ПУСТО, ИСТИНА, 0)
  КОНЕЦ PushSysType;

ПРОЦЕДУРА StIdent;
   НАЧАЛО
      Охрана_Создать;
      (* базовые типы *)
      PushStType("BOOLEAN",  мКонст.типБУЛЕВО);
      PushStType("БУЛЕВО",  мКонст.типБУЛЕВО);
      
      PushStType("CHAR",     мКонст.типЛИТЕРА);
      PushStType("ЛИТ",      мКонст.типЛИТЕРА);
      
      PushStType("INTEGER",  мКонст.типЦЕЛОЕ);
      PushStType("ЦЕЛОЕ",    мКонст.типЦЕЛОЕ);
      
      PushStType("REAL",     мКонст.типВЕЩ);
      PushStType("ВЕЩ",      мКонст.типВЕЩ);
      
      PushStType("LONGREAL", мКонст.типДЛИНВЕЩ);
      PushStType("ДЛИНВЕЩ",  мКонст.типДЛИНВЕЩ);
      
      PushStType("SET",      мКонст.типНАБОР);
      PushStType("НАБОР",    мКонст.типНАБОР);
      
      PushStProc("ABS",      мКонст.процАБС);
      PushStProc("АБС",      мКонст.процАБС);
      
      PushStProc("ASR",      мКонст.stASR);
    
      PushStProc("ASSERT",   мКонст.процКОНТРОЛЬ);
      PushStProc("КОНТРОЛЬ", мКонст.процКОНТРОЛЬ);

      PushStProc("CHR",      мКонст.stCHR);
      PushStProc("COPY",     мКонст.stCOPY);
      
      PushStProc("INC",      мКонст.процДОБ);
      PushStProc("ДОБ",      мКонст.процДОБ);
      
      PushStProc("DEC",      мКонст.процВЫЧ);
      PushStProc("ВЫЧ",      мКонст.процВЫЧ);
      
      PushStProc("DISPOSE",  мКонст.stDISPOSE);
      PushStProc("EXCL",     мКонст.stEXCL);
      PushStProc("FLOOR",    мКонст.stFLOOR);
      PushStProc("FLT",      мКонст.stFLT);
      
      PushStProc("INCL",     мКонст.stINCL);
      
      PushStProc("LEN",      мКонст.stLEN);
      PushStProc("LSL",      мКонст.stLSL);
      
      PushStProc("LONG",     мКонст.процУДЛИН);
      PushStProc("УДЛИН",    мКонст.процУДЛИН);
      
      PushStProc("NEW",      мКонст.процНОВ);
      PushStProc("НОВ",      мКонст.процНОВ);
      
      PushStProc("ODD",      мКонст.процЧЁТ);
      PushStProc("ЧЁТ",      мКонст.процЧЁТ);
      
      PushStProc("ORD",      мКонст.stORD);
      PushStProc("PACK",     мКонст.stPACK);
      
      PushStProc("ROR",      мКонст.stROR);
      
      PushStProc("SHORT",    мКонст.процУКОРОТ);
      PushStProc("УКОРОТ",    мКонст.процУКОРОТ);
      
      PushStProc("UNPK",     мКонст.stUNPK);
      PushStProc("BITS",     мКонст.stBITS);
      PushStProc("LSR",      мКонст.stLSR);
      
      PushStProc("LENGTH",   мКонст.stLENGTH);
      PushStProc("ДЛИНСТР",    мКонст.stLENGTH);
      Охрана_Создать
   КОНЕЦ StIdent;

ПРОЦЕДУРА GetQIdent*(Unit: туМодуль; Name: мУзел.туУзел): туСущность;
   ПЕРЕМ
      cur, res: туСущность;
      line, col: ЦЕЛОЕ;
   НАЧАЛО
      res := ПУСТО;
      Коорд_Уст(line, col);
      cur := Unit.IdentBegin.следующ(туСущность);
      ПОКА (cur # ПУСТО) & (cur.iType # IDGUARD) ДЕЛАТЬ
         ЕСЛИ cur.уУзел = Name ТОГДА
            ЕСЛИ (Unit # модуль) & ~cur.Export ТОГДА
               res := ПУСТО
            ИНАЧЕ
               res := cur
            КОНЕЦ;
            cur := ПУСТО
         ИНАЧЕ
            cur := cur.следующ(туСущность)
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ res
   КОНЕЦ GetQIdent;

ПРОЦЕДУРА GetIdent*(Name: мУзел.туУзел): туСущность;
   ПЕРЕМ
      cur, res: туСущность;
      line, col: ЦЕЛОЕ;
   НАЧАЛО
      res := ПУСТО;
      Коорд_Уст(line, col);
      cur := модуль.Idents.следующ(туСущность);
      ПОКА (cur # ПУСТО) & (cur.уУзел = Name) ДЕЛАТЬ
         res := cur;
         cur := ПУСТО
      АЕСЛИ cur # ПУСТО ДЕЛАТЬ
         cur := cur.предыдущ(туСущность)
      КОНЕЦ
      ВЕРНУТЬ res
   КОНЕЦ GetIdent;

ПРОЦЕДУРА Relation*(Op: ЦЕЛОЕ): БУЛЕВО;
   ПЕРЕМ
      Res: БУЛЕВО;
   НАЧАЛО
      ВЫБОР Op ИЗ
         |мКонст.опРавно, мКонст.опНеРавно, мКонст.опМеньше, мКонст.опБольше,
            lxLE, lxGE, мКонст.ксВ, мКонст.ксЕСТЬ:
                  Res := ИСТИНА
      ИНАЧЕ
         Res := ЛОЖЬ
      КОНЕЦ
      ВЕРНУТЬ Res
   КОНЕЦ Relation;

ПРОЦЕДУРА Arith(a, b: ДЛИНВЕЩ; T: мТип.туТип; Op, line, col: ЦЕЛОЕ): ДЛИНВЕЩ;
   КОНСТ
      max = мСкан.maxDBL;
   ПЕРЕМ
      res: ДЛИНВЕЩ;
   НАЧАЛО
      ВЫБОР Op ИЗ
         |мКонст.опПлюс: res := a + b
         |мКонст.опМинус: res := a - b
         |мКонст.опУмнож: res := a * b
         |мКонст.опДелен:
            мПров.Тест(b # 0.0D0, line, col, 46);
            res := a / b
         |lxDIV:
            мПров.Тест(~((a = УДЛИН(FLT(мКонст.целое_мин))) & (b = -1.0D0)), line, col, IOVER);
            res := УДЛИН(FLT(FLOOR(a) DIV FLOOR(b)))
         |lxMOD:
            res := УДЛИН(FLT(FLOOR(a) MOD FLOOR(b)))
      ИНАЧЕ
      КОНЕЦ;
      мПров.Тест(~мУтиль.ЕслиБесконеч(res), line, col, FOVER);
      ВЫБОР T.тип_ном ИЗ
         |мКонст.типЦЕЛОЕ: 
            мПров.Тест((res <= УДЛИН(FLT(мКонст.целое_макс))) & (res >= УДЛИН(FLT(мКонст.целое_мин))), line, col, IOVER)
         |мКонст.типВЕЩ:     
            мПров.Тест((res <= УДЛИН(мКонст.вещ_макс)) & (res >= -УДЛИН(мКонст.вещ_макс)), line, col, FOVER)
         |мКонст.типДЛИНВЕЩ: 
          мПров.Тест((res <= max) & (res >= -max), line, col, FOVER)
      ИНАЧЕ
      КОНЕЦ;
      ЕСЛИ (res = 0.0D0) & (T.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}) ИЛИ (ABS(res) < УДЛИН(мКонст.вещ_мин)) & (T.тип_ном = мКонст.типВЕЩ) ТОГДА
         ВЫБОР Op ИЗ
            |мКонст.опПлюс:  мПров.Тест(a = -b, line, col, UNDER)
            |мКонст.опМинус: мПров.Тест(a = b, line, col, UNDER)
            |мКонст.опУмнож:  мПров.Тест((a = 0.0D0) ИЛИ (b = 0.0D0), line, col, UNDER)
            |мКонст.опДелен: мПров.Тест((a = 0.0D0), line, col, UNDER)
         ИНАЧЕ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ res
   КОНЕЦ Arith;

ПРОЦЕДУРА strcmp(адр1, адр2: ДЛИНВЕЩ; Op: ЦЕЛОЕ): ДЛИНВЕЩ;
   ПЕРЕМ
      sa, sb: туКонстСтр;
      Res: ДЛИНВЕЩ;
   НАЧАЛО
      sa := уКонстСтр_Получ(адр1);
      sb := уКонстСтр_Получ(адр2);
      ВЫБОР Op ИЗ
         |мКонст.опРавно, мКонст.опНеРавно: Res := УДЛИН(FLT(ORD(sa.стр = sb.стр)))
         |мКонст.опМеньше, мКонст.опБольше: Res := УДЛИН(FLT(ORD(sa.стр < sb.стр)))
         |lxLE, lxGE: Res := УДЛИН(FLT(ORD(sa.стр <= sb.стр)))
      ИНАЧЕ
      КОНЕЦ
      ВЕРНУТЬ Res
   КОНЕЦ strcmp;

ПРОЦЕДУРА Calc*(a, b: ДЛИНВЕЩ; Ta, Tb: мТип.туТип; Op, line, col: ЦЕЛОЕ; ПЕР Res: ДЛИНВЕЩ; ПЕР TRes: мТип.туТип);
  ПЕРЕМ c: ДЛИНВЕЩ; ai, bi: ЦЕЛОЕ;
  НАЧАЛО
    ai := FLOOR(a);
    bi := FLOOR(b);
    ЕСЛИ Op # мКонст.ксВ ТОГДА
      мПров.Тест(Ta = Tb, line, col, 37)
    КОНЕЦ;
    ВЫБОР Op ИЗ
    |мКонст.опПлюс, мКонст.опМинус, мКонст.опУмнож, мКонст.опДелен:
      мПров.Тест(~((Op = мКонст.опДелен) & (Ta.тип_ном = мКонст.типЦЕЛОЕ)), line, col, 37);
      ЕСЛИ Ta.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ} ТОГДА
        Res := Arith(a, b, Ta, Op, line, col)
      АЕСЛИ Ta.тип_ном = мКонст.типНАБОР ТОГДА
        ВЫБОР Op ИЗ
        |мКонст.опПлюс:  Res := УДЛИН(FLT(ORD(BITS(ai) + BITS(bi))))
        |мКонст.опМинус: Res := УДЛИН(FLT(ORD(BITS(ai) - BITS(bi))))
        |мКонст.опУмнож:  Res := УДЛИН(FLT(ORD(BITS(ai) * BITS(bi))))
        |мКонст.опДелен: Res := УДЛИН(FLT(ORD(BITS(ai) / BITS(bi))))
        ИНАЧЕ
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест(ЛОЖЬ, line, col, 37)
      КОНЕЦ;
      TRes := Ta
    |lxDIV, lxMOD:
      мПров.Тест(Ta.тип_ном = мКонст.типЦЕЛОЕ, line, col, 37);
      мПров.Тест(bi # 0, line, col, 48);
      TRes := Ta;
      Res := Arith(a, b, Ta, Op, line, col)
    |мКонст.опИ:
      мПров.Тест(Ta.тип_ном = мКонст.типБУЛЕВО, line, col, 37);
      Res := УДЛИН(FLT(ORD((ai # 0) & (bi # 0))))
    |мКонст.lxOR:
      мПров.Тест(Ta.тип_ном = мКонст.типБУЛЕВО, line, col, 37);
      Res := УДЛИН(FLT(ORD((ai # 0) ИЛИ (bi # 0))))
    |мКонст.опРавно, мКонст.опНеРавно:
      ЕСЛИ Ta.тип_ном = мКонст.типСТРОКА ТОГДА
        Res := strcmp(a, b, Op)
      ИНАЧЕ
        Res := УДЛИН(FLT(ORD(a = b)))
      КОНЕЦ;
      ЕСЛИ Op = мКонст.опНеРавно ТОГДА
        Res := УДЛИН(FLT(ORD(Res = 0.0D0)))
      КОНЕЦ
    |мКонст.опМеньше, мКонст.опБольше:
      ЕСЛИ Op = мКонст.опБольше ТОГДА
        c := a;
        a := b;
        b := c
      КОНЕЦ;
      мПров.Тест(Ta.тип_ном В {мКонст.типСТРОКА, мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, line, col, 37);
      ЕСЛИ Ta.тип_ном = мКонст.типСТРОКА ТОГДА
        Res := strcmp(a, b, Op)
      ИНАЧЕ
        Res := УДЛИН(FLT(ORD(a < b)))
      КОНЕЦ
    |lxLE, lxGE:
      ЕСЛИ Op = lxGE ТОГДА
        c := a;
        a := b;
        b := c
      КОНЕЦ;
      мПров.Тест(Ta.тип_ном В {мКонст.типСТРОКА, мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типНАБОР}, line, col, 37);
      ЕСЛИ Ta.тип_ном = мКонст.типСТРОКА ТОГДА
        Res := strcmp(a, b, Op)
      АЕСЛИ Ta.тип_ном = мКонст.типНАБОР ТОГДА
        Res := УДЛИН(FLT(ORD(BITS(FLOOR(a)) <= BITS(FLOOR(b)))))
      ИНАЧЕ
        Res := УДЛИН(FLT(ORD(a <= b)))
      КОНЕЦ
    |мКонст.ксВ:
      мПров.Тест((Ta.тип_ном = мКонст.типЦЕЛОЕ) & (Tb.тип_ном = мКонст.типНАБОР), line, col, 37);
      мПров.Тест(ASR(ai, 5) = 0, line, col, 49);
      Res := УДЛИН(FLT(ORD(ai IN BITS(bi))))
    ИНАЧЕ
    КОНЕЦ;
    ЕСЛИ Relation(Op) ИЛИ (Op = мКонст.опИ) ИЛИ (Op = мКонст.lxOR) ТОГДА
      TRes := sttypes[мКонст.типБУЛЕВО]
    КОНЕЦ
  КОНЕЦ Calc;

ПРОЦЕДУРА ConstExpr*(ПЕР двЗначение_: ДЛИНВЕЩ; ПЕР тип: мТип.туТип);
   ПЕРЕМ
      выраж: тВыражение;
      строка, col: ЦЕЛОЕ;
   НАЧАЛО
      Const := ИСТИНА;
      Коорд_Уст(строка, col);
      sizefunc := ЛОЖЬ;
      Expr(выраж);
      мПров.Тест(~sizefunc & (выраж.eType = eCONST), строка, col, 62);
      двЗначение_ := выраж.Value;
      тип := выраж.T;
      Const := ЛОЖЬ
   КОНЕЦ ConstExpr;

ПРОЦЕДУРА IdType*(ПЕР line, col: ЦЕЛОЕ): мТип.туТип;
   ПЕРЕМ
      имя: туСущность;
      Name: мУзел.туУзел;
      Unit: туМодуль;
      Res: мТип.туТип;
   НАЧАЛО
      Res := ПУСТО;
      Name := мСкан.id;
      имя := GetIdent(Name);
      ЕСЛИ имя = ПУСТО ТОГДА
         Коорд_Уст(line, col);
         NamePtrBase := Name;
         КлючСлед_Получ
      ИНАЧЕ
         ЕСЛИ имя.iType = IDTYPE ТОГДА
            Коорд_Уст(line, col);
            КлючСлед_Получ;
            Res := имя.T
         АЕСЛИ имя.iType = IDMOD ТОГДА
            Unit := имя.модуль;
            КлючСлед_Получ;
            Ключ_Проверить(lxDot);
            КлючСлед_Получ;
            Ключ_Проверить(lxIDENT);
            Name := мСкан.id;
            NamePtrBase := Name;
            имя := GetQIdent(Unit, Name);
            ЕСЛИ Unit # модуль ТОГДА
               мПров.Тест2(имя # ПУСТО, 42);
               мПров.Тест2(имя.iType = IDTYPE, 77);
               Коорд_Уст(line, col);
               КлючСлед_Получ;
               Res := имя.T
            ИНАЧЕ
               ЕСЛИ имя = ПУСТО ТОГДА
                  мПров.Тест2((модуль.уровень = 3) & модуль.typedecl, 42);
                  Коорд_Уст(line, col);
                  КлючСлед_Получ;
                  Res := ПУСТО
               ИНАЧЕ
                  мПров.Тест2(имя.iType = IDTYPE, 77);
                  Коорд_Уст(line, col);
                  КлючСлед_Получ;
                  Res := имя.T
               КОНЕЦ
            КОНЕЦ
         ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 77)
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ Res
   КОНЕЦ IdType;

ПРОЦЕДУРА FieldOffset(Align, RecSize: ЦЕЛОЕ): ЦЕЛОЕ;
  НАЧАЛО
    мПров.Тест2(RecSize <= мКонст.целое_макс - (Align - RecSize MOD Align) MOD Align, 83)
    ВЕРНУТЬ RecSize + (Align - RecSize MOD Align) MOD Align
  КОНЕЦ FieldOffset;

ПРОЦЕДУРА Dim*(T: мТип.туТип): ЦЕЛОЕ;
  ПЕРЕМ
      n: ЦЕЛОЕ;
  НАЧАЛО
    n := 0;
    ПОКА (T.тип_ном = мКонст.типМАССИВ) & (T.длина = 0) ДЕЛАТЬ
      ДОБ(n);
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ n
  КОНЕЦ Dim;

ПРОЦЕДУРА SetFields(Tr, Tf: мТип.туТип; Rec: БУЛЕВО);
  ПЕРЕМ
    cur: туПоле;
  НАЧАЛО
    cur := Tr.поля.предыдущ(туПоле);
    ПОКА cur.T # ПУСТО ДЕЛАТЬ
      cur := cur.следующ(туПоле)
    КОНЕЦ;
    ПОКА cur # ПУСТО ДЕЛАТЬ
      cur.T := Tf;
      ЕСЛИ Rec ТОГДА
        ЕСЛИ Tf.выравнив > Tr.выравнив ТОГДА
          Tr.выравнив := Tf.выравнив
        КОНЕЦ;
        ЕСЛИ Tr.запись = record ТОГДА
          cur.Offset := FieldOffset(Tf.выравнив, Tr.размер);
          мПров.Тест2(cur.Offset <= мКонст.целое_макс - Tf.размер, 83);
          Tr.размер := cur.Offset + Tf.размер
        АЕСЛИ Tr.запись = noalign ТОГДА
          cur.Offset := FieldOffset(1, Tr.размер);
          мПров.Тест2(cur.Offset <= мКонст.целое_макс - Tf.размер, 83);
          Tr.размер := cur.Offset + Tf.размер
        АЕСЛИ Tr.запись = union ТОГДА
          ЕСЛИ Tf.размер > Tr.размер ТОГДА
            Tr.размер := Tf.размер
          КОНЕЦ;
          cur.Offset := 0
        КОНЕЦ
      ИНАЧЕ
        Tr.длина := Tr.длина + 4 * (ORD((Tf.тип_ном = мКонст.типЗАПИСЬ) & cur.ByRef) + Dim(Tf) + ORD((Tf.тип_ном = мКонст.типДЛИНВЕЩ) & ~cur.ByRef) + 1)
      КОНЕЦ;
      cur := cur.следующ(туПоле)
    КОНЕЦ
  КОНЕЦ SetFields;

ПРОЦЕДУРА GetField*(T: мТип.туТип; Name: мУзел.туУзел): туПоле;
  ПЕРЕМ
    cur, Res: туПоле;
  НАЧАЛО
    Res := ПУСТО;
    cur := T.поля.предыдущ(туПоле);
    ПОКА (cur # ПУСТО) & (cur.Name = Name) ДЕЛАТЬ
      Res := cur;
      cur := ПУСТО
    АЕСЛИ cur # ПУСТО ДЕЛАТЬ
      cur := cur.следующ(туПоле)
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ GetField;

ПРОЦЕДУРА Unique(T: мТип.туТип; Name: мУзел.туУзел): БУЛЕВО;
  ПЕРЕМ
    field: туПоле;
    res: БУЛЕВО;
  НАЧАЛО
    res := ИСТИНА;
    ПОКА (T # ПУСТО) & res ДЕЛАТЬ
      field := GetField(T, Name);
      ЕСЛИ field # ПУСТО ТОГДА
        ЕСЛИ (field.Unit = модуль) ИЛИ field.Export ТОГДА
          res := ЛОЖЬ
        КОНЕЦ
      КОНЕЦ;
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Unique;

ПРОЦЕДУРА notrecurs(id: БУЛЕВО; T: мТип.туТип): БУЛЕВО;
    ВЕРНУТЬ ~(id & (модуль.Idents.следующ(туСущность).iType = IDTYPE) & (модуль.Idents.следующ(туСущность).T = T) &
            (T.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типМАССИВ}))
  КОНЕЦ notrecurs;

ПРОЦЕДУРА ReadFields(T: мТип.туТип);
   ПЕРЕМ
      Name: мУзел.туУзел;
      field: туПоле;
      Tf: мТип.туТип;
      line, col: ЦЕЛОЕ;
      id_T: БУЛЕВО;
   НАЧАЛО
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
         Name := мСкан.id;
         мПров.Тест2(Unique(T, Name), 30);
         НОВ(field);
         мПам.Мало(field = ПУСТО);
         мЦепь.Добавить(T.поля, field);
         field.Name := Name;
         field.T := ПУСТО;
         field.Export := ЛОЖЬ;
         field.Unit := модуль;
         КлючСлед_Получ;
         ЕСЛИ мСкан.сущность = мКонст.опУмнож ТОГДА
            мПров.Тест2(модуль.уровень = 3, 89);
            мПров.Тест2(модуль.typedecl, 91);
            мПров.Тест2(модуль.ExportType, 92);
            field.Export := ИСТИНА;
            КлючСлед_Получ
         КОНЕЦ;
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
         КлючСлед_Получ;
         Ключ_Проверить(lxIDENT)
      АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
         КлючСлед_Получ;
         Коорд_Уст(line, col);
         id_T := мСкан.сущность = lxIDENT;
         Tf:= pParseType(line, col);
         мПров.Тест(Tf # ПУСТО, line, col, 42);
         мПров.Тест(notrecurs(id_T, Tf), line, col, 96);
         SetFields(T, Tf, ИСТИНА);
         ЕСЛИ мСкан.сущность = мКонст.опТчкЗпт ТОГДА
            КлючСлед_Получ;
            Ключ_Проверить(lxIDENT)
         ИНАЧЕ
            мПров.Тест2(мСкан.сущность = мКонст.ксКОНЕЦ, 86)
         КОНЕЦ
         ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 85)
         КОНЕЦ
      КОНЕЦ
   КОНЕЦ ReadFields;

ПРОЦЕДУРА OpenBase*(T: мТип.туТип): мТип.туТип;
  НАЧАЛО
    ПОКА (T.тип_ном = мКонст.типМАССИВ) & (T.длина = 0) ДЕЛАТЬ
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ T
  КОНЕЦ OpenBase;

ПРОЦЕДУРА SetVars(T: мТип.туТип);
  ПЕРЕМ
    cur: туСущность;
    n: ЦЕЛОЕ;
  НАЧАЛО
    cur := модуль.Idents.следующ(туСущность);
    ПОКА cur.T = ПУСТО ДЕЛАТЬ
      cur := cur.предыдущ(туСущность)
    КОНЕЦ;
    cur := cur.следующ(туСущность);
    ПОКА cur # ПУСТО ДЕЛАТЬ
      cur.T := T;
      ЕСЛИ cur.Export ТОГДА
        мПров.Тест(~(T.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типМАССИВ}), cur.line, cur.col, 90)
      КОНЕЦ;
      ЕСЛИ(cur.VarKind = paramvar) ИЛИ (cur.VarKind = param) & (T.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типМАССИВ}) ТОГДА
        n := 4 * (1 + Dim(T) + ORD((cur.VarKind = paramvar) & (T.тип_ном = мКонст.типЗАПИСЬ)))
      ИНАЧЕ
        n := T.размер;
        мПров.Тест2(n <= мКонст.целое_макс - мПам.Выровнять(n), 93);
        n := n + мПам.Выровнять(n)
      КОНЕЦ;
      ЕСЛИ cur.Level = 3 ТОГДА
        cur.Offset := ProgSize;
        мПров.Тест2(ProgSize <= мКонст.целое_макс - n, 93);
        ProgSize := ProgSize + n;
        мПров.Тест2(ProgSize <= мКонст.целое_макс - мПам.Выровнять(ProgSize), 93);
        ProgSize := ProgSize + мПам.Выровнять(ProgSize)
      ИНАЧЕ
        ЕСЛИ cur.VarKind = 0 ТОГДА
          cur.Offset := curBlock.ParamSize - curBlock.VarSize - n
        ИНАЧЕ
          cur.Offset := curBlock.VarSize - 8 + 4 * (cur.Level + ORD((cur.VarKind = paramvar) & (T.тип_ном = мКонст.типЗАПИСЬ)))
        КОНЕЦ
      КОНЕЦ;
      мПров.Тест2(curBlock.VarSize <= мКонст.целое_макс - n, 93);
      curBlock.VarSize := curBlock.VarSize + n;
      мПров.Тест2(curBlock.VarSize <= мКонст.целое_макс - мПам.Выровнять(curBlock.VarSize), 93);
      curBlock.VarSize := curBlock.VarSize + мПам.Выровнять(curBlock.VarSize);
      ЕСЛИ cur.VarKind # 0 ТОГДА
        curBlock.ParamSize := curBlock.VarSize
      КОНЕЦ;
      cur := cur.следующ(туСущность)
    КОНЕЦ
  КОНЕЦ SetVars;

ПРОЦЕДУРА Тип_Создать(tType, Len, Size, Number: ЦЕЛОЕ; Base: мТип.туТип; Fields: БУЛЕВО; NewType: мТип.туТип): мТип.туТип;
   ПЕРЕМ
      nov: мТип.туТип;
   НАЧАЛО
      ЕСЛИ NewType = ПУСТО ТОГДА
         НОВ(nov);
         мПам.Мало(nov = ПУСТО)
      ИНАЧЕ
         nov := NewType
      КОНЕЦ;
      мЦепь.Добавить(types, nov);
    nov.тип_ном := tType;
    nov.длина := Len;
    nov.размер := Size;
    nov.Base := Base;
    nov.поля := ПУСТО;
    nov.номер := Number;
    ЕСЛИ Fields ТОГДА
      nov.поля := мЦепь.Создать();
      мПам.Мало(nov.поля = ПУСТО)
    КОНЕЦ
    ВЕРНУТЬ nov
  КОНЕЦ Тип_Создать;

ПРОЦЕДУРА FormalType(ПЕР line, col: ЦЕЛОЕ): мТип.туТип;
   ПЕРЕМ
      TA: мТип.туТип;
   НАЧАЛО
      ЕСЛИ мСкан.сущность = мКонст.ксМАССИВ ТОГДА
         КлючСлед_Получ;
         Ключ_Проверить(мКонст.ксИЗ);
         КлючСлед_Получ;
         TA := Тип_Создать(мКонст.типМАССИВ, 0, 0, 0, FormalType(line, col), ЛОЖЬ, ПУСТО)
      ИНАЧЕ
         Ключ_Проверить(lxIDENT);
         TA := IdType(line, col);
         мПров.Тест(TA # ПУСТО, line, col, 42);
      КОНЕЦ
      ВЕРНУТЬ TA
   КОНЕЦ FormalType;

ПРОЦЕДУРА Section(T: мТип.туТип);
   ПЕРЕМ
         Name: мУзел.туУзел;
         ByRef, cont: БУЛЕВО;
         field: туПоле;
         Tf: мТип.туТип;
         fp: туСущность;
         line, col: ЦЕЛОЕ;
         proc: БУЛЕВО;
   НАЧАЛО
       proc := T = ПУСТО;
       ЕСЛИ proc ТОГДА
         T := curBlock.T
       КОНЕЦ;
       мПров.Тест2((мСкан.сущность = lxIDENT) ИЛИ (мСкан.сущность = мКонст.ксПЕРЕМ), 84);
       ByRef := ЛОЖЬ;
       ЕСЛИ мСкан.сущность = мКонст.ксПЕРЕМ ТОГДА
         ByRef := ИСТИНА;
         КлючСлед_Получ;
         Ключ_Проверить(lxIDENT)
       КОНЕЦ;
       cont := ИСТИНА;
       ПОКА cont ДЕЛАТЬ
         Name := мСкан.id;
         мПров.Тест2(GetField(T, Name) = ПУСТО, 30);
         НОВ(field);
         мПам.Мало(field = ПУСТО);
         мЦепь.Добавить(T.поля, field);
         field.Name := Name;
         field.T := ПУСТО;
         field.ByRef := ByRef;
         ЕСЛИ proc ТОГДА
           PushIdent(Name, line, col, IDVAR, ПУСТО, ПУСТО, ЛОЖЬ, 0);
           ДОБ(curBlock.ParamCount);
           fp := модуль.Idents.следующ(туСущность);
           ЕСЛИ ByRef ТОГДА
             fp.VarKind := paramvar
           ИНАЧЕ
             fp.VarKind := param
           КОНЕЦ
         КОНЕЦ;
         КлючСлед_Получ;
         ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
           КлючСлед_Получ;
           Ключ_Проверить(lxIDENT)
         АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
           КлючСлед_Получ;
           Tf := FormalType(line, col);
           мПров.Тест(Dim(Tf) <= мАсм86.ADIM, line, col, 110);
           SetFields(T, Tf, ЛОЖЬ);
           ЕСЛИ proc ТОГДА
             SetVars(Tf)
           КОНЕЦ;
           cont := ЛОЖЬ
         ИНАЧЕ
           мПров.Тест2(ЛОЖЬ, 85)
         КОНЕЦ
       КОНЕЦ
   КОНЕЦ Section;

ПРОЦЕДУРА ParamType(T: мТип.туТип);
  ПЕРЕМ break: БУЛЕВО;
  НАЧАЛО
    ЕСЛИ (мСкан.сущность = lxIDENT) ИЛИ (мСкан.сущность = мКонст.ксПЕРЕМ) ТОГДА
      break := ЛОЖЬ;
      ПОВТОРЯТЬ
        Section(T);
        ЕСЛИ мСкан.сущность = мКонст.опТчкЗпт ТОГДА
          КлючСлед_Получ
        ИНАЧЕ
          break := ИСТИНА
        КОНЕЦ
      ПОКАНЕ break
    КОНЕЦ
  КОНЕЦ ParamType;

ПРОЦЕДУРА AddPtrBase(Name: мУзел.туУзел; line, col: ЦЕЛОЕ; T: мТип.туТип);
   ПЕРЕМ
      nov: PTRBASE;
   НАЧАЛО
       НОВ(nov);
       мПам.Мало(nov = ПУСТО);
       nov.Name := Name;
       nov.line := line;
       nov.col := col;
       nov.Ptr := T;
       мЦепь.Добавить(PtrBases, nov)
   КОНЕЦ AddPtrBase;

ПРОЦЕДУРА FormalList(T: мТип.туТип; ПЕР Res: мТип.туТип);
  ПЕРЕМ line, col: ЦЕЛОЕ;
  НАЧАЛО
    ЕСЛИ мСкан.сущность = lxLRound ТОГДА
      КлючСлед_Получ;
      ParamType(T);
      Ключ_Проверить(мКонст.опСкобкаПрКр);
      КлючСлед_Получ;
      ЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
        КлючСлед_Получ;
        Ключ_Проверить(lxIDENT);
        Res := IdType(line, col);
        мПров.Тест(Res # ПУСТО, line, col, 42);
        мПров.Тест(~(Res.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типМАССИВ}), line, col, 82)
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ FormalList;

ПРОЦЕДУРА CallFlag(ПЕР Call: ЦЕЛОЕ): БУЛЕВО;
  ПЕРЕМ
    flag: мСтр.тСтрока;
    res: БУЛЕВО;
  НАЧАЛО
    res := мСкан.сущность = мКонст.опСкобкаЛевКв;
    ЕСЛИ res ТОГДА
      КлючСлед_Получ;
      мСкан.GetLexStr(flag);
      ЕСЛИ flag = "cdecl" ТОГДА
        Call := cdecl
      АЕСЛИ flag = "stdcall" ТОГДА
        Call := stdcall
      АЕСЛИ flag = "winapi" ТОГДА
        мПров.Тест2(winplatf, 50);
        Call := winapi
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 44)
      КОНЕЦ;
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опСкобкаПрКв);
      КлючСлед_Получ;
    ИНАЧЕ
      Call := defcall
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ CallFlag;

ПРОЦЕДУРА RecFlag(ПЕР rec: ЦЕЛОЕ): БУЛЕВО;
  ПЕРЕМ
    flag: мСтр.тСтрока;
    res: БУЛЕВО;
  НАЧАЛО
    res := мСкан.сущность = мКонст.опСкобкаЛевКв;
    ЕСЛИ res ТОГДА
      КлючСлед_Получ;
      мСкан.GetLexStr(flag);
      ЕСЛИ flag = "union" ТОГДА
        rec := union
      АЕСЛИ flag = "noalign" ТОГДА
        rec := noalign
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 103)
      КОНЕЦ;
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опСкобкаПрКв);
      КлючСлед_Получ;
    ИНАЧЕ
      rec := record
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ RecFlag;

ПРОЦЕДУРА StructType(Comma: БУЛЕВО; NewType: мТип.туТип): мТип.туТип;
   ПЕРЕМ
      v: ДЛИНВЕЩ;
      T, nov: мТип.туТип;
      line, col, line2, col2: ЦЕЛОЕ;
      id_T: БУЛЕВО;
  НАЧАЛО
    ВЫБОР мСкан.сущность ИЗ
    |мКонст.ксМАССИВ, мКонст.опЗапятая:
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        мПров.Тест2(Comma, 39)
      КОНЕЦ;
      КлючСлед_Получ;
      Коорд_Уст(line, col);
      ConstExpr(v, T);
      мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
      мПров.Тест(v > 0.0D0, line, col, 78);
      nov := Тип_Создать(мКонст.типМАССИВ, FLOOR(v), 0, 0, ПУСТО, ЛОЖЬ, NewType);
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        nov.Base := StructType(ИСТИНА, ПУСТО)
      АЕСЛИ мСкан.сущность = мКонст.ксИЗ ТОГДА
        КлючСлед_Получ;
        Коорд_Уст(line, col);
        id_T := мСкан.сущность = lxIDENT;
        nov.Base := pParseType(line, col);
        мПров.Тест(nov.Base # ПУСТО, line, col, 42);
        мПров.Тест(notrecurs(id_T, nov.Base), line, col, 96)
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 79)
      КОНЕЦ;
      мПров.Тест2(nov.Base.размер <= мКонст.целое_макс DIV nov.длина, 83);
      nov.размер := nov.Base.размер * nov.длина;
      nov.выравнив := nov.Base.выравнив
    |мКонст.ксЗАПИСЬ:
      КлючСлед_Получ;
      ДОБ(RecCount);
      nov := Тип_Создать(мКонст.типЗАПИСЬ, 0, 0, RecCount, ПУСТО, ИСТИНА, NewType);
      nov.выравнив := 1;
      Коорд_Уст(line, col);
      ЕСЛИ RecFlag(nov.запись) ТОГДА
        мПров.Тест(модуль.системный, line, col, 111)
      КОНЕЦ;
      Коорд_Уст(line, col);
      ЕСЛИ мСкан.сущность = lxLRound ТОГДА
        КлючСлед_Получ;
        Коорд_Уст(line2, col2);
        Ключ_Проверить(lxIDENT);
        nov.Base := IdType(line, col);
        мПров.Тест(nov.Base # ПУСТО, line, col, 42);
        мПров.Тест(nov.Base.тип_ном = мКонст.типЗАПИСЬ, line, col, 80);
        мПров.Тест(notrecurs(ИСТИНА, nov.Base), line, col, 96);
        nov.размер := nov.Base.размер;
        nov.выравнив := nov.Base.выравнив;
        Ключ_Проверить(мКонст.опСкобкаПрКр);
        КлючСлед_Получ;
        мПров.Тест(nov.запись = record, line, col, 112);
        мПров.Тест(nov.Base.запись = record, line2, col2, 113)
      КОНЕЦ;
      ReadFields(nov);
      Ключ_Проверить(мКонст.ксКОНЕЦ);
      nov.размер := мАсм86.Align(nov.размер, nov.выравнив);
      ЕСЛИ nov.Base # ПУСТО ТОГДА
         мАсм86.AddRec(nov.Base.номер)
      ИНАЧЕ
         мАсм86.AddRec(0)
      КОНЕЦ;
      КлючСлед_Получ
    |мКонст.ксУКАЗАТЕЛЬ:
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.ксДО);
      КлючСлед_Получ;
      nov := Тип_Создать(мКонст.типУКАЗАТЕЛЬ, 0, 4, 0, ПУСТО, ЛОЖЬ, NewType);
      nov.выравнив := 4;
      Коорд_Уст(line, col);
      nov.Base := pParseType(line, col);
      ЕСЛИ nov.Base = ПУСТО ТОГДА
        мПров.Тест(модуль.typedecl, line, col, 42);
        AddPtrBase(NamePtrBase, line, col, nov)
      ИНАЧЕ
        мПров.Тест(nov.Base.тип_ном = мКонст.типЗАПИСЬ, line, col, 81)
      КОНЕЦ
    |мКонст.ксПРОЦЕДУРА:
      КлючСлед_Получ;
      nov := Тип_Создать(мКонст.типПРОЦЕДУРА, 0, 4, 0, sttypes[мКонст.TVOID], ИСТИНА, NewType);
      Коорд_Уст(line, col);
      ЕСЛИ CallFlag(nov.вызов) ТОГДА
        мПров.Тест(модуль.системный, line, col, 111)
      КОНЕЦ;
      nov.выравнив := 4;
      FormalList(nov, nov.Base)
    ИНАЧЕ
      мПров.Тест2(ЛОЖЬ, 39)
    КОНЕЦ
    ВЕРНУТЬ nov
  КОНЕЦ StructType;

ПРОЦЕДУРА ParseType(ПЕР line, col: ЦЕЛОЕ): мТип.туТип;
   ПЕРЕМ
      Res: мТип.туТип;
   НАЧАЛО
    ЕСЛИ мСкан.сущность = lxIDENT ТОГДА
      Res := IdType(line, col)
    ИНАЧЕ
      Res := StructType(ЛОЖЬ, ПУСТО)
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ ParseType;

ПРОЦЕДУРА PopBlock;
  ПЕРЕМ
    cur: туСущность;
    n: ЦЕЛОЕ;
  НАЧАЛО
    cur := модуль.Idents.следующ(туСущность);
    n := 0;
    ПОКА cur.iType # IDGUARD ДЕЛАТЬ
      cur := cur.предыдущ(туСущность);
      ДОБ(n)
    КОНЕЦ;
    cur := cur.предыдущ(туСущность);
    ДОБ(n);
    модуль.Idents.счетчик := модуль.Idents.счетчик - n;
    модуль.Idents.следующ := cur;
    cur.следующ := ПУСТО;
    ВЫЧ(модуль.уровень)
  КОНЕЦ PopBlock;

ПРОЦЕДУРА LinkPtr;
  ПЕРЕМ
    cur: PTRBASE;
    id: туСущность;
  НАЧАЛО
    cur := PtrBases.предыдущ(PTRBASE);
    ПОКА cur # ПУСТО ДЕЛАТЬ
      id := GetIdent(cur.Name);
      мПров.Тест(id # ПУСТО, cur.line, cur.col, 42);
      мПров.Тест(id.T.тип_ном = мКонст.типЗАПИСЬ, cur.line, cur.col, 81);
      cur.Ptr.Base := id.T;
      cur := cur.следующ(PTRBASE)
    КОНЕЦ;
    мЦепь.Очистить(PtrBases)
  КОНЕЦ LinkPtr;

ПРОЦЕДУРА DeclSeq;
   ПЕРЕМ
      Value: ДЛИНВЕЩ;
      T, NewType: мТип.туТип;
      Name: мУзел.туУзел;
      line, col, Call: ЦЕЛОЕ;
      Export, func: БУЛЕВО;
      last, id: туСущность;
       e: тВыражение;

   ПРОЦЕДУРА IdentDef;
      НАЧАЛО
            Name := мСкан.id;
            Коорд_Уст(line, col);
            КлючСлед_Получ;
            Export := ЛОЖЬ;
            ЕСЛИ мСкан.сущность = мКонст.опУмнож ТОГДА
              мПров.Тест2(модуль.уровень = 3, 89);
              Export := ИСТИНА;
              КлючСлед_Получ
            КОНЕЦ
      КОНЕЦ IdentDef;

  НАЧАЛО
    ЕСЛИ мСкан.сущность = мКонст.ксКОНСТ ТОГДА
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDCONST, ПУСТО, ПУСТО, Export, 0);
        last := модуль.Idents.следующ(туСущность);
        Ключ_Проверить(мКонст.опРавно);
        КлючСлед_Получ;
        ConstExpr(Value, T);
        Ключ_Проверить(мКонст.опТчкЗпт);
        last.Value := Value;
        last.T := T;
        КлючСлед_Получ
      КОНЕЦ
    КОНЕЦ;
    ЕСЛИ мСкан.сущность = мКонст.ксТИПЫ ТОГДА
      мЦепь.Очистить(PtrBases);
      модуль.typedecl := ИСТИНА;
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDTYPE, ПУСТО, ПУСТО, Export, 0);
        last := модуль.Idents.следующ(туСущность);
        модуль.ExportType := Export;
        Ключ_Проверить(мКонст.опРавно);
        КлючСлед_Получ;
        НОВ(NewType);
        мПам.Мало(NewType = ПУСТО);
        last.T := NewType;
        T := StructType(ЛОЖЬ, NewType);
        Ключ_Проверить(мКонст.опТчкЗпт);
        КлючСлед_Получ
      КОНЕЦ
    КОНЕЦ;
    LinkPtr;
    модуль.typedecl := ЛОЖЬ;
    модуль.ExportType := ЛОЖЬ;
    ЕСЛИ мСкан.сущность = мКонст.ксПЕРЕМ ТОГДА
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDVAR, ПУСТО, ПУСТО, Export, 0);
        ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
          КлючСлед_Получ;
          Ключ_Проверить(lxIDENT)
        АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
          КлючСлед_Получ;
          Коорд_Уст(line, col);
          T := ParseType(line, col);
          мПров.Тест(T # ПУСТО, line, col, 42);
          SetVars(T);
          Ключ_Проверить(мКонст.опТчкЗпт);
          КлючСлед_Получ
        ИНАЧЕ
          мПров.Тест2(ЛОЖЬ, 85)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ;
    ПОКА мСкан.сущность = мКонст.ксПРОЦЕДУРА ДЕЛАТЬ
      КлючСлед_Получ;
      Коорд_Уст(line, col);
      ЕСЛИ CallFlag(Call) ТОГДА
        мПров.Тест(модуль.уровень = 3, line, col, 45);
        мПров.Тест(модуль.системный, line, col, 111)
      КОНЕЦ;
      Ключ_Проверить(lxIDENT);
      IdentDef;
      PushIdent(Name, line, col, IDPROC, Тип_Создать(мКонст.типПРОЦЕДУРА, 0, 4, 0, sttypes[мКонст.TVOID], ИСТИНА, ПУСТО), ПУСТО, Export, 0);
      id := модуль.Idents.следующ(туСущность);
      ЕСЛИ id.Export & main ТОГДА
        ЕСЛИ цКодОС = 6 ТОГДА
          мПров.Тест((Name # мСкан._START) & (Name # мСкан._version), line, col, 133)
        КОНЕЦ;
        мАсм86.ProcExport(id.Number, Name, мАсм86.NewLabel())
      КОНЕЦ;
      id.Parent := curBlock;
      curBlock := id;
      Охрана_Создать;
      FormalList(ПУСТО, curBlock.T.Base);
      id.T.вызов := Call;
      Ключ_Проверить(мКонст.опТчкЗпт);
      КлючСлед_Получ;
      DeclSeq;
      id.LocalSize := id.VarSize - id.ParamSize;
      мАсм86.ProcBeg(id.Number, id.LocalSize, ЛОЖЬ);
      ЕСЛИ мСкан.сущность = мКонст.ксНАЧАЛО ТОГДА
        КлючСлед_Получ;
        OpSeq
      КОНЕЦ;
      func := curBlock.T.Base.тип_ном # мКонст.TVOID;
      ЕСЛИ func ТОГДА
        Ключ_Проверить(мКонст.ксВЕРНУТЬ);
        мУтиль.КодСтрока_Уст(UnitNumber, мСкан.цСтрока);
        КлючСлед_Получ;
        Коорд_Уст(line, col);
        Expr(e);
        мПров.Тест(AssComp(e, curBlock.T.Base, ЛОЖЬ), line, col, 125);
        ЕСЛИ e.eType = eVAR ТОГДА
          мАсм86.Load(e.T.тип_ном)
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест2(мСкан.сущность # мКонст.ксВЕРНУТЬ, 123)
      КОНЕЦ;
      Ключ_Проверить(мКонст.ксКОНЕЦ);
      КлючСлед_Получ;
      Ключ_Проверить(lxIDENT);
      мПров.Тест2(мСкан.id = Name, 87);
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опТчкЗпт);
      КлючСлед_Получ;
      мАсм86.ProcEnd(id.Number, (id.ParamSize + (id.Level - 3) * 4) * ORD(curBlock.T.вызов В {stdcall, winapi, defcall}), func, curBlock.T.Base.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ});
      PopBlock;
      curBlock := curBlock.Parent
    КОНЕЦ
  КОНЕЦ DeclSeq;

ПРОЦЕДУРА Rtl_Добав(u: туМодуль);

    ПРОЦЕДУРА AddProc(name: мСтр.тСтрока; num: ЦЕЛОЕ);
      ПЕРЕМ
        id: туСущность;
      НАЧАЛО
        id := GetQIdent(u, мУзел.Добавить(name));
        ЕСЛИ id = ПУСТО ТОГДА
          мОш.Сообщ(158);
          мПроц.Закончить(1)
        КОНЕЦ;
        мАсм86.AddRtlProc(num, id.Number)
      КОНЕЦ AddProc;

  НАЧАЛО
    AddProc("_newrec", мАсм86._newrec);
    AddProc("_disprec", мАсм86._disprec);
    AddProc("_rset", мАсм86._rset);
    AddProc("_inset", мАсм86._inset);
    AddProc("_saverec", мАсм86._saverec);
    AddProc("_checktype", мАсм86._checktype);
    AddProc("_strcmp", мАсм86._strcmp);
    AddProc("_lstrcmp", мАсм86._lstrcmp);
    AddProc("_rstrcmp", мАсм86._rstrcmp);
    AddProc("_savearr", мАсм86._savearr);
    AddProc("_arrayidx", мАсм86._arrayidx);
    AddProc("_arrayidx1", мАсм86._arrayidx1);
    AddProc("_arrayrot", мАсм86._arrayrot);
    AddProc("_assrt", мАсм86._assrt);
    AddProc("_strcopy", мАсм86._strcopy);
    AddProc("_init", мАсм86._init);
    AddProc("_close", мАсм86._close);
    AddProc("_halt", мАсм86._halt);
    AddProc("_length", мАсм86._length);
  КОНЕЦ Rtl_Добав;

ПРОЦЕДУРА ImportList;
   ПЕРЕМ
      cond, col, line, namecol, nameline: ЦЕЛОЕ;
      name, alias: мУзел.туУзел;
      u, self: туМодуль;
      FName: мСтр.тСтрока;

   ПРОЦЕДУРА Модуль_Добавить(newcond: ЦЕЛОЕ);
      ПЕРЕМ
         str: туПунктСтр;
      НАЧАЛО
         u := Модуль_Получ(name);
         ЕСЛИ u = ПУСТО ТОГДА
        self := модуль;
        мСкан.Сохранить(модуль.сканер);
        COPY(name.имя_стр, FName);
        ЕСЛИ ~((~self.Std & пМодуль_Читать(Path, FName, мКонст.расшир)) ИЛИ
                            пМодуль_Читать(Std, FName, мКонст.расшир)) ТОГДА
          ЕСЛИ FName = "SYSTEM" ТОГДА
            модуль := мод_систем;
            self.системный := ИСТИНА
          ИНАЧЕ
            мПров.Тест(ЛОЖЬ, nameline, namecol, 32)
          КОНЕЦ
        КОНЕЦ;
        мСкан.Откатить(self.сканер);
        u := модуль;
        модуль := self;
        мФайл.Имя_Уст(модуль.файл_стр)
      ИНАЧЕ
          мПров.Тест(u.закрыт, nameline, namecol, 31)
      КОНЕЦ;
      PushIdent(alias, line, col, IDMOD, sttypes[мКонст.TVOID], u, ЛОЖЬ, 0);
      НОВ(str);
      мПам.Мало(str = ПУСТО);
      str.Str := name.имя_стр;
      мЦепь.Добавить(модуль.импорт_спис, str);
      cond := newcond
      КОНЕЦ Модуль_Добавить;

  НАЧАЛО
    cond := 0;
    ПОКА cond # 4 ДЕЛАТЬ
      КлючСлед_Получ;
      ВЫБОР cond ИЗ
      |0: Ключ_Проверить(lxIDENT);
          name := мСкан.id;
          Коорд_Уст(line, col);
          Коорд_Уст(nameline, namecol);
          alias := name;
          cond := 1
      |1: ВЫБОР мСкан.сущность ИЗ
          |мКонст.опЗапятая:  Модуль_Добавить(0)
          |мКонст.опТчкЗпт:   Модуль_Добавить(4); КлючСлед_Получ
          |lxAssign: cond := 2
          ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 28)
          КОНЕЦ
      |2: Ключ_Проверить(lxIDENT);
          name := мСкан.id;
          Коорд_Уст(nameline, namecol);
          cond := 3
      |3: ВЫБОР мСкан.сущность ИЗ
          |мКонст.опЗапятая: Модуль_Добавить(0)
          |мКонст.опТчкЗпт:  Модуль_Добавить(4); КлючСлед_Получ
          ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 29)
          КОНЕЦ
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ ImportList;

ПРОЦЕДУРА Header(Name: мУзел.туУзел);
   НАЧАЛО
      НОВ(модуль);
      мПам.Мало(модуль = ПУСТО);
      модуль.Idents := мЦепь.Создать();
      мПам.Мало(модуль.Idents = ПУСТО);
      модуль.уровень := 0;
      модуль.уУзел := Name;
      Охрана_Создать;
      Охрана_Создать;
      PushIdent(модуль.уУзел, 0, 0, IDMOD, sttypes[мКонст.TVOID], модуль, ЛОЖЬ, 0);
      Охрана_Создать;
      модуль.IdentBegin := модуль.Idents.следующ(туСущность);
      модуль.закрыт := ИСТИНА
    КОНЕЦ Header;

ПРОЦЕДУРА Псевдо_Добав;
  ПЕРЕМ
    модуль_псевдо: туМодуль;
  НАЧАЛО
    модуль_псевдо := модуль;
    Header(мУзел.Добавить("SYSTEM"));
    PushSysProc("ADR",     мКонст.sysADR);
    PushSysProc("SIZE",    мКонст.sysSIZE);
    PushSysProc("TYPEID",  мКонст.sysTYPEID);
    PushSysProc("BIT",     мКонст.sysBIT);
    PushSysProc("GET",     мКонст.sysGET);
    PushSysProc("PUT",     мКонст.sysPUT);
    PushSysProc("CODE",    мКонст.sysCODE);
    PushSysProc("MOVE",    мКонст.sysMOVE);
    PushSysType("CARD16",  мКонст.TCARD16); (* псевдотип, не очень хорошо, но есть *)
    мод_систем := модуль;
    модуль := модуль_псевдо
  КОНЕЦ Псевдо_Добав;

ПРОЦЕДУРА Модуль_Читать(Path, Name1, Ext: мСтр.тСтрока): БУЛЕВО;
   ПЕРЕМ
      FHandle: ЦЕЛОЕ;
      name, Name, b: мСтр.тСтрока;
      idmod: туСущность;
      Res, temp: БУЛЕВО;
   НАЧАЛО
      Res := ЛОЖЬ;
      name := Name1;
      Name := Name1;
      мСтр.Сложить(Path, Name, b);
      мСтр.Сложить(b, Ext, Name);
      ЕСЛИ мСкан.Файл_Открыть(Name, FHandle) ТОГДА
         НОВ(модуль);
         мПам.Мало(модуль = ПУСТО);
         модуль.системный := ЛОЖЬ;
         модуль.Std := Path = Std;
         мЦепь.Добавить(prog, модуль);
         модуль.Idents := мЦепь.Создать();
         мПам.Мало(модуль.Idents = ПУСТО);
         модуль.импорт_спис := мЦепь.Создать();
         мПам.Мало(модуль.импорт_спис = ПУСТО);
         НОВ(модуль.сканер);
         мПам.Мало(модуль.сканер = ПУСТО);
         модуль.закрыт := ЛОЖЬ;
         модуль.уровень := 0;
         модуль.typedecl := ЛОЖЬ;
         модуль.ExportType := ЛОЖЬ;
         COPY(Name, модуль.файл_стр);
         мФайл.Имя_Уст(модуль.файл_стр);
         StIdent;
         КлючСлед_Получ; Ключ_Проверить(мКонст.ксМОДУЛЬ);
        
         КлючСлед_Получ; Ключ_Проверить(lxIDENT);
         мПров.Тест2(мСтр.Сравнить(мСкан.id.имя_стр, name), 33);
         модуль.уУзел := мСкан.id;
         PushIdent(модуль.уУзел, мСкан.цСтрока, мСкан.col, IDMOD, sttypes[мКонст.TVOID], модуль, ЛОЖЬ, 0);
         idmod := модуль.Idents.следующ(туСущность);
         Охрана_Создать;
         КлючСлед_Получ; Ключ_Проверить(мКонст.опТчкЗпт);
         КлючСлед_Получ;
         ЕСЛИ мСкан.сущность = мКонст.ксИМПОРТ ТОГДА
            temp := main;
            main := ЛОЖЬ;
            ImportList;
            main := temp
         КОНЕЦ;
         мВинКонс.Цвет_Уст(14, 0);
         мКонс.Строка_Печать("Компилирую: "); мКонс.Строка_Печать(модуль.уУзел.имя_стр); мКонс.Строка_Печать("."); мКонс.НовСтр;
         мВинКонс.Цвет_Уст(7, 0);
         мАсм86.Module(idmod.уУзел.имя_стр, idmod.Number);
         UnitNumber := idmod.Number;
         модуль.IdentBegin := модуль.Idents.следующ(туСущность);
         curBlock := idmod;
         DeclSeq;
         мАсм86.ProcBeg(idmod.Number, 0, ИСТИНА);
         ЕСЛИ мСкан.сущность = мКонст.ксНАЧАЛО ТОГДА
            КлючСлед_Получ;
            OpSeq
         КОНЕЦ;
         Ключ_Проверить(мКонст.ксКОНЕЦ);
         КлючСлед_Получ; Ключ_Проверить(lxIDENT);
         мПров.Тест2(мСкан.id = модуль.уУзел, 26);
         КлючСлед_Получ; Ключ_Проверить(lxDot);
         мАсм86.Leave;
         модуль.закрыт := ИСТИНА;
         мЦепь.Очистить(модуль.импорт_спис);
         Res := ИСТИНА
      КОНЕЦ
      ВЕРНУТЬ Res
  КОНЕЦ Модуль_Читать;

ПРОЦЕДУРА Код_Настроить*(StdPath, FilePath, NameFile, ExtFile: мСтр.тСтрока; windows: БУЛЕВО;
    OpSeqProc: тПроцедура; ExprProc: тПроцедураПер; AssCompProc: тПроцедураСвязь; ПЕР stypes: туТипНабор);
  НАЧАЛО
    winplatf := windows;
    Path := FilePath;
    Main := NameFile;
    ExtMain := ExtFile;
    Std := StdPath;
    OpSeq := OpSeqProc;
    Expr := ExprProc;
    AssComp := AssCompProc;
    prog := мЦепь.Создать();
    мПам.Мало(prog = ПУСТО);
    PtrBases := мЦепь.Создать();
    мПам.Мало(PtrBases = ПУСТО);
    types := мЦепь.Создать();
    мПам.Мало(types = ПУСТО);
    StTypes;
    строки := мЦепь.Создать();
    мПам.Мало(строки = ПУСТО);
    Псевдо_Добав;
    stypes := sttypes
  КОНЕЦ Код_Настроить;

ПРОЦЕДУРА delfirstchar(ПЕР s: мСтр.тСтрока);
  ПЕРЕМ i: ЦЕЛОЕ;
  НАЧАЛО
    ДЛЯ i := 0 ДО ДЛИНСТР(s) - 1 ДЕЛАТЬ
      s[i] := s[i + 1]
    КОНЕЦ
  КОНЕЦ delfirstchar;

ПРОЦЕДУРА Компилировать*(цКодОС_, цСтекРазмер_: ЦЕЛОЕ);
  ПЕРЕМ
    full, path, name, ext, temp, path2: мСтр.тСтрока;
  НАЧАЛО
    цКодОС := цКодОС_;
    main := ЛОЖЬ;
    ЕСЛИ Модуль_Читать(Std, "RTL", мКонст.расшир) ТОГДА
      Rtl_Добав(модуль)
    ИНАЧЕ
      мОш.Сообщ(65);
      мПроц.Закончить(1)
    КОНЕЦ;
    main := ИСТИНА;
    ЕСЛИ ~Модуль_Читать(Path, Main, ExtMain) ТОГДА
      path2 := Path;
      мУтиль.СтрПарам(full, 0);
      мСтр.Разделить(full, path, name, ext);
      ЕСЛИ path[0] # 0X ТОГДА
        path[ДЛИНСТР(path) - 1] := 0X
      КОНЕЦ;
      ЕСЛИ Path[0] = мКонст.слэш ТОГДА
        delfirstchar(Path)
      КОНЕЦ;
      мСтр.Сложить(path, мКонст.слэш, path);
      мСтр.Сложить(path, Path, full);
      Path := full;
      ЕСЛИ (мКонст.ОС = "WIN") & (Path[0] = мКонст.слэш) ТОГДА
        delfirstchar(Path)
      КОНЕЦ;
      ЕСЛИ ~Модуль_Читать(Path, Main, ExtMain) ТОГДА
        мОш.Сообщ(64);
        мКонс.Строка_Печать(path2);
        мКонс.Строка_Печать(Main);
        мКонс.Строка_Печать(ExtMain);
        мКонс.НовСтр;
        мПроц.Закончить(1)
      КОНЕЦ
    КОНЕЦ;
    temp := Path;
    мСтр.Сложить(temp, Main, temp);
    ЕСЛИ цКодОС_ IN {2, 3} ТОГДА
      мСтр.Сложить(temp, ".exe", temp)
    АЕСЛИ цКодОС_ = 1 ТОГДА
      мСтр.Сложить(temp, ".dll", temp)
    АЕСЛИ цКодОС_ = 4 ТОГДА
      мСтр.Сложить(temp, ".kex", temp)
    АЕСЛИ цКодОС_ = 6 ТОГДА
      мСтр.Сложить(temp, ".obj", temp)
    КОНЕЦ;
    ЕСЛИ цКодОС_ В {1, 2, 3, 4} ТОГДА
      цСтекРазмер_ := цСтекРазмер_ * 100000H
    КОНЕЦ;
    мАсм86.Эпилог(ProgSize, temp, цСтекРазмер_)
  КОНЕЦ Компилировать;

НАЧАЛО
  pParseType := ParseType;
  пМодуль_Читать := Модуль_Читать
КОНЕЦ модДецл.
