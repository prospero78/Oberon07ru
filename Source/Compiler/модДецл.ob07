(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
  *)

МОДУЛЬ модДецл;

ИМПОРТ мСкан := модСканер,
    мУтиль := модУтиль,
    X86 := модАсм86_32,
    mSys := SYSTEM,
    мТипы := модТипы,
    мФайл := модФайл,
    мКонст := модКонстанты,
    мКонс := модКонсоль,
    мПам := модПамять,
    мПроц := модПроцесс,
    мОш := модОшибки,
    мСтр := модСтроки,
    мСпис := модСписок,
    мПров := модПроверка;

КОНСТ

  lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
  lxBY = 3;
  lxDIV = 6;
  lxMOD = 17;

  lxLRound = 60; lxCaret = 63;
  lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
  lxLE = 75; lxGE = 76;

  lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
  lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

  IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

  stABS = 1; stODD = 2; stLEN = 3; stLSL = 4; stASR = 5; stROR = 6; stFLOOR = 7; stFLT = 8;
  stORD = 9; stCHR = 10; stLONG = 11; stSHORT = 12; stINC = 13; stDEC = 14; stINCL = 15;
  stEXCL = 16; stCOPY = 17; stNEW = 18; stASSERT = 19; stPACK = 20; stUNPK = 21; stDISPOSE = 22;
  stBITS = 23; stLSR = 24; stLENGTH = 25;

  sysADR = 101; sysSIZE = 102; sysBIT = 103; sysGET = 104; sysPUT = 105; sysCODE = 106;
  sysTYPEID = 107; sysMOVE = 108;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7; TNIL = 8;
  TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  paramvar* = 1; param* = 2;

  defcall = 0; stdcall = 1; cdecl = 2; winapi* = 3;

  record = 0; union = 1; noalign = 2;

  eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

  IOVER* = lxERR5 - lxERR0;
  FOVER* = lxERR7 - lxERR0;
  UNDER* = lxERR9 - lxERR0;

ТИПЫ

  туТип* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      tType*, размер*, Len*, Number*, Align, Call*, Rec: ЦЕЛОЕ;
      Base*: туТип;
      Fields*: мТипы.туСписок
    КОНЕЦ;

  туИмя* = УКАЗАТЕЛЬ НА тИмя;

  тМодуль* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      Name: мТипы.туУзел;
      File: мСтр.тСтрока;
      Idents: мТипы.туСписок;
      Import: мТипы.туСписок;
      IdentBegin: туИмя;
      scanner: мТипы.туСканер;
      Level*: ЦЕЛОЕ;
      Closed, typedecl, ExportType, Std, sys: БУЛЕВО
    КОНЕЦ;

  тИмя* = ЗАПИСЬ (мТипы.тПункт)
      Name: мТипы.туУзел;
      T*: туТип;
      Unit*: тМодуль;
      Parent*: туИмя;
      Value*: ДЛИНВЕЩ;
      line*, col*, Number*, iType*, StProc*, VarSize, ParamSize*,
      LocalSize*, Offset*, VarKind*, Level*, ParamCount*: ЦЕЛОЕ;
      Export: БУЛЕВО
    КОНЕЦ;

  PTRBASE = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      Name: мТипы.туУзел;
      line, col: ЦЕЛОЕ;
      Ptr: туТип
    КОНЕЦ;

  туПунктСтр = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      Str: мСтр.тСтрока
    КОНЕЦ;

  туПоле* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      Name: мТипы.туУзел;
      T*: туТип;
      Offset*: ЦЕЛОЕ;
      ByRef*, Export*: БУЛЕВО;
      Unit*: тМодуль
    КОНЕЦ;

  туКонстСтр* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мТипы.тПункт)
      стр*: мСтр.тСтрока;
      длина*, номер*: ЦЕЛОЕ
    КОНЕЦ;

  тВыражение* = ЗАПИСЬ
      id*: туИмя;
      T*: туТип;
      eType*: ЦЕЛОЕ;
      Value*: ДЛИНВЕЩ;
      Read*, vparam*, deref*: БУЛЕВО
    КОНЕЦ;

  тПроцедура = ПРОЦЕДУРА;
  тПроцедураПер = ПРОЦЕДУРА (ПЕР e: тВыражение);
  тПроцедураСвязь = ПРОЦЕДУРА (e: тВыражение; T: туТип; param: БУЛЕВО): БУЛЕВО;

  туТипНабор* = МАССИВ 11 ИЗ туТип;

ПЕРЕМ

  sttypes: туТипНабор;
  unit*, sys: тМодуль;
  curBlock*: туИмя;
  Path, Main, Std, ExtMain: мСтр.тСтрока;
  NamePtrBase: мТипы.туУзел; ProgSize*, RecCount, UnitNumber*: ЦЕЛОЕ;
  PtrBases, строки, types, prog: мТипы.туСписок;
  OpSeq: тПроцедура;
  Expr: тПроцедураПер;
  AssComp: тПроцедураСвязь;
  main, sizefunc, winplatf, Const*: БУЛЕВО;
  pParseType: ПРОЦЕДУРА (ПЕР line, col: ЦЕЛОЕ): туТип;
  пМодуль_Читать: ПРОЦЕДУРА (Path, Name, Ext: мСтр.тСтрока): БУЛЕВО;
  Platform: ЦЕЛОЕ;

ПРОЦЕДУРА ПроцедурРазм_Уст*;
  НАЧАЛО
    sizefunc := ИСТИНА
  КОНЕЦ ПроцедурРазм_Уст;

ПРОЦЕДУРА ПамОш_Проверить*(err: БУЛЕВО);
  НАЧАЛО
    ЕСЛИ err ТОГДА
      мПам.Ошибка(err)
    КОНЕЦ
  КОНЕЦ ПамОш_Проверить;

ПРОЦЕДУРА Стр_Получ*(adr: ДЛИНВЕЩ): туКонстСтр;
    ПЕРЕМ
        стр: туКонстСтр;
    НАЧАЛО
        mSys.PUT(mSys.ADR(стр), FLOOR(adr))
        ВЕРНУТЬ стр
    КОНЕЦ Стр_Получ;

ПРОЦЕДУРА Стр_Создать*(стр_: мСтр.тСтрока): туКонстСтр;
    ПЕРЕМ
        стр_нов: туКонстСтр;
    НАЧАЛО
        НОВ(стр_нов);
        ПамОш_Проверить(стр_нов = ПУСТО);
        COPY(стр_, стр_нов.стр);
        стр_нов.длина := мСкан.count - 1;
        стр_нов.номер := X86.NewLabel();
        мСпис.Добавить(строки, стр_нов);
        X86.String(стр_нов.номер, стр_нов.длина, стр_нов.стр)
        ВЕРНУТЬ стр_нов
    КОНЕЦ Стр_Создать;

ПРОЦЕДУРА СтрМоно_Создать*(c: СИМВ): туКонстСтр;
  ПЕРЕМ
    nov: туКонстСтр;
  НАЧАЛО
    НОВ(nov);
    ПамОш_Проверить(nov = ПУСТО);
    nov.стр[0] := c;
    nov.стр[1] := 0X;
    nov.длина := 1;
    nov.номер := X86.NewLabel();
    мСпис.Добавить(строки, nov);
    X86.String(nov.номер, nov.длина, nov.стр)
    ВЕРНУТЬ nov
  КОНЕЦ СтрМоно_Создать;

ПРОЦЕДУРА Коорд_Уст*(ПЕР line, col: ЦЕЛОЕ);
  НАЧАЛО
    line := мСкан.line;
    col := мСкан.col
  КОНЕЦ Коорд_Уст;

ПРОЦЕДУРА Модуль_Получ(Name: мТипы.туУзел): тМодуль;
  ПЕРЕМ
    cur, res: тМодуль;
  НАЧАЛО
    res := ПУСТО;
    cur := prog.предыдущ(тМодуль);
    ПОКА (cur # ПУСТО) & мУтиль.streq(cur.Name.имя, Name.имя) ДЕЛАТЬ
      res := cur;
      cur := ПУСТО
    АЕСЛИ cur # ПУСТО ДЕЛАТЬ
      cur := cur.следующ(тМодуль)
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Модуль_Получ;

ПРОЦЕДУРА КлючСлед_Получ*;
  НАЧАЛО
    мСкан.Лексема_Получ;
    ЕСЛИ (мСкан.сущность > lxERR0) & (мСкан.сущность < lxERR20) ТОГДА
      мПров.Тест(ЛОЖЬ, мСкан.line, мСкан.col + мСкан.count, мСкан.сущность - lxERR0)
    КОНЕЦ;
    мПров.Тест2(мСкан.сущность # lxEOF, 27)
  КОНЕЦ КлючСлед_Получ;

ПРОЦЕДУРА Ключ_Проверить*(key: ЦЕЛОЕ);
    ПЕРЕМ
      code: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ мСкан.сущность # key ТОГДА
        ВЫБОР key ИЗ
          |мКонст.ксМОДУЛЬ:  code := 21
          |lxIDENT:   code := 22
          |мКонст.опТчкЗпт:    code := 23
          |мКонст.ксКОНЕЦ:     code := 24
          |lxDot:     code := 25
          |мКонст.опРавно:      code := 35
          |мКонст.опСкобкаПрКр:  code := 38
          |мКонст.ксДО:      code := 40
          |мКонст.ксИЗ:      code := 41
          |lxRCurly:  code := 51
          |lxLRound:  code := 56
          |мКонст.опЗапятая:   code := 61
          |мКонст.ксТОГДА:    code := 98
          |мКонст.опСкобкаПрКв: code := 109
          |мКонст.ксДЕЛАТЬ:      code := 118
          |мКонст.ксПОКАНЕ:   code := 119
          |lxAssign:  code := 120
          |мКонст.ксВЕРНУТЬ:  code := 124
          |мКонст.опДвоеточ:   code := 157
        ИНАЧЕ
        КОНЕЦ;
        мПров.Тест2(ЛОЖЬ, code)
      КОНЕЦ
    КОНЕЦ Ключ_Проверить;

ПРОЦЕДУРА CheckIdent(Name: мТипы.туУзел): БУЛЕВО;
  ПЕРЕМ
    cur: туИмя;
  НАЧАЛО
    cur := unit.Idents.следующ(туИмя);
    ПОКА (cur.iType # IDGUARD) & (cur.Name # Name) ДЕЛАТЬ
      cur := cur.предыдущ(туИмя)
    КОНЕЦ
    ВЕРНУТЬ cur.iType = IDGUARD
  КОНЕЦ CheckIdent;

ПРОЦЕДУРА Охрана_Создать;
  ПЕРЕМ
    ident: туИмя;
  НАЧАЛО
    НОВ(ident);
    ПамОш_Проверить(ident = ПУСТО);
    ident.Name := ПУСТО;
    ident.iType := IDGUARD;
    ident.T := sttypes[TVOID];
    мСпис.Добавить(unit.Idents, ident);
    ДОБ(unit.Level)
  КОНЕЦ Охрана_Создать;

ПРОЦЕДУРА PushIdent(Name: мТипы.туУзел; line, col, iType: ЦЕЛОЕ; T: туТип; u: тМодуль; Export: БУЛЕВО; StProc: ЦЕЛОЕ);
  ПЕРЕМ
    ident: туИмя;
    i: ЦЕЛОЕ;
  НАЧАЛО
    мПров.Тест(CheckIdent(Name), line, col, 30);
    НОВ(ident);
    ПамОш_Проверить(ident = ПУСТО);
    ident.Name := Name;
    ident.line := line;
    ident.col := col;
    ЕСЛИ iType IN {IDPROC, IDMOD} ТОГДА
      ident.Number := X86.NewLabel();
      i := X86.NewLabel();
      i := X86.NewLabel();
      i := X86.NewLabel()
    КОНЕЦ;
    ident.iType := iType;
    ident.T := T;
    ident.Unit := u;
    ident.Export := Export;
    ident.StProc := StProc;
    ident.Level := unit.Level;
    мСпис.Добавить(unit.Idents, ident)
  КОНЕЦ PushIdent;

ПРОЦЕДУРА StTypes;
  ПЕРЕМ
    type: туТип; i: ЦЕЛОЕ;
  НАЧАЛО
    sttypes[0] := ПУСТО;
    ДЛЯ i := TINTEGER ДО TSTRING ДЕЛАТЬ
        НОВ(type);
        ПамОш_Проверить(type = ПУСТО);
        type.tType := i;
        мСпис.Добавить(types, type);
        sttypes[i] := type
    КОНЕЦ;
    sttypes[TINTEGER].размер := 4;
    sttypes[TREAL].размер := 4;
    sttypes[TLONGREAL].размер := 8;
    sttypes[TBOOLEAN].размер := 1;
    sttypes[TCHAR].размер := 1;
    sttypes[TSET].размер := 4;
    sttypes[TVOID].размер := 0;
    sttypes[TSTRING].размер := 0;
    sttypes[TNIL].размер := 4;
    sttypes[TCARD16].размер := 2;
    ДЛЯ i := TINTEGER ДО TSTRING ДЕЛАТЬ
      sttypes[i].Align := sttypes[i].размер
    КОНЕЦ
  КОНЕЦ StTypes;

ПРОЦЕДУРА PushStProc(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мСкан.Узел_Добав(Name), 0, 0, IDSTPROC, sttypes[TVOID], ПУСТО, ЛОЖЬ, StProc)
  КОНЕЦ PushStProc;

ПРОЦЕДУРА PushStType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мСкан.Узел_Добав(Name), 0, 0, IDTYPE, sttypes[T], ПУСТО, ЛОЖЬ, 0)
  КОНЕЦ PushStType;

ПРОЦЕДУРА PushSysProc(Name: мСтр.тСтрока; StProc: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мСкан.Узел_Добав(Name), 0, 0, IDSYSPROC, sttypes[TVOID], ПУСТО, ИСТИНА, StProc)
  КОНЕЦ PushSysProc;

ПРОЦЕДУРА PushSysType(Name: мСтр.тСтрока; T: ЦЕЛОЕ);
  НАЧАЛО
    PushIdent(мСкан.Узел_Добав(Name), 0, 0, IDTYPE, sttypes[T], ПУСТО, ИСТИНА, 0)
  КОНЕЦ PushSysType;

ПРОЦЕДУРА StIdent;
  НАЧАЛО
    Охрана_Создать;
    PushStProc("ABS",      stABS);
    PushStProc("ASR",      stASR);
    
    PushStProc("ASSERT",   stASSERT);
    PushStProc("ЗАЩИТА",   stASSERT);
    
    PushStType("BOOLEAN",  TBOOLEAN);
    PushStType("БУЛЕВО",  TBOOLEAN);
    
    PushStType("CHAR",     TCHAR);
    PushStType("СИМВ",     TCHAR);
    PushStProc("CHR",      stCHR);
    PushStProc("COPY",     stCOPY);
    
    PushStProc("DEC",      stDEC);
    PushStProc("ВЫЧ",      stDEC);
    
    PushStProc("DISPOSE",  stDISPOSE);
    PushStProc("EXCL",     stEXCL);
    PushStProc("FLOOR",    stFLOOR);
    PushStProc("FLT",      stFLT);
    
    PushStProc("INC",      stINC);
    PushStProc("ДОБ",      stINC);
    
    PushStProc("INCL",     stINCL);
    
    PushStType("INTEGER",  TINTEGER);
    PushStType("ЦЕЛОЕ",  TINTEGER);
    
    PushStProc("LEN",      stLEN);
    PushStProc("LSL",      stLSL);
    
    PushStProc("LONG",     stLONG);
    PushStProc("ДЛИН",     stLONG);
    
    PushStType("LONGREAL", TLONGREAL);
    PushStType("ДЛИНВЕЩ", TLONGREAL);
    
    PushStProc("NEW",      stNEW);
    PushStProc("НОВ",      stNEW);
    
    PushStProc("ODD",      stODD);
    PushStProc("ORD",      stORD);
    PushStProc("PACK",     stPACK);
    
    PushStType("REAL",     TREAL);
    PushStType("ВЕЩ",     TREAL);
    
    PushStProc("ROR",      stROR);
    PushStType("SET",      TSET);
    
    PushStProc("SHORT",    stSHORT);
    PushStProc("КОРОТ",    stSHORT);
    
    PushStProc("UNPK",     stUNPK);
    PushStProc("BITS",     stBITS);
    PushStProc("LSR",      stLSR);
    
    PushStProc("LENGTH",   stLENGTH);
    PushStProc("ДЛИНА",   stLENGTH);
    Охрана_Создать
  КОНЕЦ StIdent;

ПРОЦЕДУРА GetQIdent*(Unit: тМодуль; Name: мТипы.туУзел): туИмя;
  ПЕРЕМ
    cur, res: туИмя;
    line, col: ЦЕЛОЕ;
  НАЧАЛО
    res := ПУСТО;
    Коорд_Уст(line, col);
    cur := Unit.IdentBegin.следующ(туИмя);
    ПОКА (cur # ПУСТО) & (cur.iType # IDGUARD) ДЕЛАТЬ
      ЕСЛИ cur.Name = Name ТОГДА
        ЕСЛИ (Unit # unit) & ~cur.Export ТОГДА
          res := ПУСТО
        ИНАЧЕ
          res := cur
        КОНЕЦ;
        cur := ПУСТО
      ИНАЧЕ
        cur := cur.следующ(туИмя)
      КОНЕЦ
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ GetQIdent;

ПРОЦЕДУРА GetIdent*(Name: мТипы.туУзел): туИмя;
  ПЕРЕМ
    cur, res: туИмя;
    line, col: ЦЕЛОЕ;
  НАЧАЛО
    res := ПУСТО;
    Коорд_Уст(line, col);
    cur := unit.Idents.следующ(туИмя);
    ПОКА (cur # ПУСТО) & (cur.Name = Name) ДЕЛАТЬ
      res := cur;
      cur := ПУСТО
    АЕСЛИ cur # ПУСТО ДЕЛАТЬ
      cur := cur.предыдущ(туИмя)
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ GetIdent;

ПРОЦЕДУРА Relation*(Op: ЦЕЛОЕ): БУЛЕВО;
  ПЕРЕМ Res: БУЛЕВО;
  НАЧАЛО
    ВЫБОР Op ИЗ
    |мКонст.опРавно, мКонст.опНеРавно, мКонст.опМеньше, мКонст.опБольше,
     lxLE, lxGE, мКонст.ксВ, мКонст.ксЕСТЬ:
      Res := ИСТИНА
    ИНАЧЕ
      Res := ЛОЖЬ
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ Relation;

ПРОЦЕДУРА Arith(a, b: ДЛИНВЕЩ; T: туТип; Op, line, col: ЦЕЛОЕ): ДЛИНВЕЩ;
  CONST max = мСкан.maxDBL;
  ПЕРЕМ res: ДЛИНВЕЩ;
  НАЧАЛО
    ВЫБОР Op ИЗ
    |мКонст.опПлюс: res := a + b
    |мКонст.опМинус: res := a - b
    |мКонст.опУмнож: res := a * b
    |мКонст.опДелен:
      мПров.Тест(b # 0.0D0, line, col, 46);
      res := a / b
    |lxDIV:
      мПров.Тест(~((a = ДЛИН(FLT(мКонст.целое_мин))) & (b = -1.0D0)), line, col, IOVER);
      res := ДЛИН(FLT(FLOOR(a) DIV FLOOR(b)))
    |lxMOD:
      res := ДЛИН(FLT(FLOOR(a) MOD FLOOR(b)))
    ИНАЧЕ
    КОНЕЦ;
    мПров.Тест(~мУтиль.ЕслиБесконеч(res), line, col, FOVER);
    ВЫБОР T.tType ИЗ
    |TINTEGER: 
      мПров.Тест((res <= ДЛИН(FLT(мКонст.целое_макс))) & (res >= ДЛИН(FLT(мКонст.целое_мин))), line, col, IOVER)
    |TREAL:     
      мПров.Тест((res <= ДЛИН(мКонст.вещ_макс)) & (res >= -ДЛИН(мКонст.вещ_макс)), line, col, FOVER)
    |TLONGREAL: 
      мПров.Тест((res <= max) & (res >= -max), line, col, FOVER)
    ИНАЧЕ
    КОНЕЦ;
    ЕСЛИ (res = 0.0D0) & (T.tType IN {TREAL, TLONGREAL}) ИЛИ (ABS(res) < ДЛИН(мКонст.вещ_мин)) & (T.tType = TREAL) ТОГДА
      ВЫБОР Op ИЗ
      |мКонст.опПлюс:  мПров.Тест(a = -b, line, col, UNDER)
      |мКонст.опМинус: мПров.Тест(a = b, line, col, UNDER)
      |мКонст.опУмнож:  мПров.Тест((a = 0.0D0) ИЛИ (b = 0.0D0), line, col, UNDER)
      |мКонст.опДелен: мПров.Тест((a = 0.0D0), line, col, UNDER)
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Arith;

ПРОЦЕДУРА strcmp(a, b: ДЛИНВЕЩ; Op: ЦЕЛОЕ): ДЛИНВЕЩ;
  ПЕРЕМ
    sa, sb: туКонстСтр;
    Res: ДЛИНВЕЩ;
  НАЧАЛО
    sa := Стр_Получ(a);
    sb := Стр_Получ(b);
    ВЫБОР Op ИЗ
    |мКонст.опРавно, мКонст.опНеРавно: Res := ДЛИН(FLT(ORD(sa.стр = sb.стр)))
    |мКонст.опМеньше, мКонст.опБольше: Res := ДЛИН(FLT(ORD(sa.стр < sb.стр)))
    |lxLE, lxGE: Res := ДЛИН(FLT(ORD(sa.стр <= sb.стр)))
    ИНАЧЕ
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ strcmp;

ПРОЦЕДУРА Calc*(a, b: ДЛИНВЕЩ; Ta, Tb: туТип; Op, line, col: ЦЕЛОЕ; ПЕР Res: ДЛИНВЕЩ; ПЕР TRes: туТип);
  ПЕРЕМ c: ДЛИНВЕЩ; ai, bi: ЦЕЛОЕ;
  НАЧАЛО
    ai := FLOOR(a);
    bi := FLOOR(b);
    ЕСЛИ Op # мКонст.ксВ ТОГДА
      мПров.Тест(Ta = Tb, line, col, 37)
    КОНЕЦ;
    ВЫБОР Op ИЗ
    |мКонст.опПлюс, мКонст.опМинус, мКонст.опУмнож, мКонст.опДелен:
      мПров.Тест(~((Op = мКонст.опДелен) & (Ta.tType = TINTEGER)), line, col, 37);
      ЕСЛИ Ta.tType IN {TINTEGER, TREAL, TLONGREAL} ТОГДА
        Res := Arith(a, b, Ta, Op, line, col)
      АЕСЛИ Ta.tType = TSET ТОГДА
        ВЫБОР Op ИЗ
        |мКонст.опПлюс:  Res := ДЛИН(FLT(ORD(BITS(ai) + BITS(bi))))
        |мКонст.опМинус: Res := ДЛИН(FLT(ORD(BITS(ai) - BITS(bi))))
        |мКонст.опУмнож:  Res := ДЛИН(FLT(ORD(BITS(ai) * BITS(bi))))
        |мКонст.опДелен: Res := ДЛИН(FLT(ORD(BITS(ai) / BITS(bi))))
        ИНАЧЕ
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест(ЛОЖЬ, line, col, 37)
      КОНЕЦ;
      TRes := Ta
    |lxDIV, lxMOD:
      мПров.Тест(Ta.tType = TINTEGER, line, col, 37);
      мПров.Тест(bi # 0, line, col, 48);
      TRes := Ta;
      Res := Arith(a, b, Ta, Op, line, col)
    |мКонст.опИ:
      мПров.Тест(Ta.tType = TBOOLEAN, line, col, 37);
      Res := ДЛИН(FLT(ORD((ai # 0) & (bi # 0))))
    |мКонст.lxOR:
      мПров.Тест(Ta.tType = TBOOLEAN, line, col, 37);
      Res := ДЛИН(FLT(ORD((ai # 0) ИЛИ (bi # 0))))
    |мКонст.опРавно, мКонст.опНеРавно:
      ЕСЛИ Ta.tType = TSTRING ТОГДА
        Res := strcmp(a, b, Op)
      ИНАЧЕ
        Res := ДЛИН(FLT(ORD(a = b)))
      КОНЕЦ;
      ЕСЛИ Op = мКонст.опНеРавно ТОГДА
        Res := ДЛИН(FLT(ORD(Res = 0.0D0)))
      КОНЕЦ
    |мКонст.опМеньше, мКонст.опБольше:
      ЕСЛИ Op = мКонст.опБольше ТОГДА
        c := a;
        a := b;
        b := c
      КОНЕЦ;
      мПров.Тест(Ta.tType IN {TSTRING, TINTEGER, TREAL, TLONGREAL}, line, col, 37);
      ЕСЛИ Ta.tType = TSTRING ТОГДА
        Res := strcmp(a, b, Op)
      ИНАЧЕ
        Res := ДЛИН(FLT(ORD(a < b)))
      КОНЕЦ
    |lxLE, lxGE:
      ЕСЛИ Op = lxGE ТОГДА
        c := a;
        a := b;
        b := c
      КОНЕЦ;
      мПров.Тест(Ta.tType IN {TSTRING, TINTEGER, TREAL, TLONGREAL, TSET}, line, col, 37);
      ЕСЛИ Ta.tType = TSTRING ТОГДА
        Res := strcmp(a, b, Op)
      АЕСЛИ Ta.tType = TSET ТОГДА
        Res := ДЛИН(FLT(ORD(BITS(FLOOR(a)) <= BITS(FLOOR(b)))))
      ИНАЧЕ
        Res := ДЛИН(FLT(ORD(a <= b)))
      КОНЕЦ
    |мКонст.ксВ:
      мПров.Тест((Ta.tType = TINTEGER) & (Tb.tType = TSET), line, col, 37);
      мПров.Тест(ASR(ai, 5) = 0, line, col, 49);
      Res := ДЛИН(FLT(ORD(ai IN BITS(bi))))
    ИНАЧЕ
    КОНЕЦ;
    ЕСЛИ Relation(Op) ИЛИ (Op = мКонст.опИ) ИЛИ (Op = мКонст.lxOR) ТОГДА
      TRes := sttypes[TBOOLEAN]
    КОНЕЦ
  КОНЕЦ Calc;

ПРОЦЕДУРА ConstExpr*(ПЕР Value: ДЛИНВЕЩ; ПЕР T: туТип);
  ПЕРЕМ
    e: тВыражение;
    line, col: ЦЕЛОЕ;
  НАЧАЛО
    Const := ИСТИНА;
    Коорд_Уст(line, col);
    sizefunc := ЛОЖЬ;
    Expr(e);
    мПров.Тест(~sizefunc & (e.eType = eCONST), line, col, 62);
    Value := e.Value;
    T := e.T;
    Const := ЛОЖЬ
  КОНЕЦ ConstExpr;

ПРОЦЕДУРА IdType*(ПЕР line, col: ЦЕЛОЕ): туТип;
  ПЕРЕМ
    id: туИмя;
    Name: мТипы.туУзел;
    Unit: тМодуль;
    Res: туТип;
  НАЧАЛО
    Res := ПУСТО;
    Name := мСкан.id;
    id := GetIdent(Name);
    ЕСЛИ id = ПУСТО ТОГДА
      Коорд_Уст(line, col);
      NamePtrBase := Name;
      КлючСлед_Получ
    ИНАЧЕ
      ЕСЛИ id.iType = IDTYPE ТОГДА
        Коорд_Уст(line, col);
        КлючСлед_Получ;
        Res := id.T
      АЕСЛИ id.iType = IDMOD ТОГДА
        Unit := id.Unit;
        КлючСлед_Получ;
        Ключ_Проверить(lxDot);
        КлючСлед_Получ;
        Ключ_Проверить(lxIDENT);
        Name := мСкан.id;
        NamePtrBase := Name;
        id := GetQIdent(Unit, Name);
        ЕСЛИ Unit # unit ТОГДА
          мПров.Тест2(id # ПУСТО, 42);
          мПров.Тест2(id.iType = IDTYPE, 77);
          Коорд_Уст(line, col);
          КлючСлед_Получ;
          Res := id.T
        ИНАЧЕ
          ЕСЛИ id = ПУСТО ТОГДА
            мПров.Тест2((unit.Level = 3) & unit.typedecl, 42);
            Коорд_Уст(line, col);
            КлючСлед_Получ;
            Res := ПУСТО
          ИНАЧЕ
            мПров.Тест2(id.iType = IDTYPE, 77);
            Коорд_Уст(line, col);
            КлючСлед_Получ;
            Res := id.T
          КОНЕЦ
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 77)
      КОНЕЦ
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ IdType;

ПРОЦЕДУРА FieldOffset(Align, RecSize: ЦЕЛОЕ): ЦЕЛОЕ;
  НАЧАЛО
    мПров.Тест2(RecSize <= мКонст.целое_макс - (Align - RecSize MOD Align) MOD Align, 83)
    ВЕРНУТЬ RecSize + (Align - RecSize MOD Align) MOD Align
  КОНЕЦ FieldOffset;

ПРОЦЕДУРА Dim*(T: туТип): ЦЕЛОЕ;
  ПЕРЕМ n: ЦЕЛОЕ;
  НАЧАЛО
    n := 0;
    ПОКА (T.tType = TARRAY) & (T.Len = 0) ДЕЛАТЬ
      ДОБ(n);
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ n
  КОНЕЦ Dim;

ПРОЦЕДУРА SetFields(Tr, Tf: туТип; Rec: БУЛЕВО);
  ПЕРЕМ
    cur: туПоле;
  НАЧАЛО
    cur := Tr.Fields.предыдущ(туПоле);
    ПОКА cur.T # ПУСТО ДЕЛАТЬ
      cur := cur.следующ(туПоле)
    КОНЕЦ;
    ПОКА cur # ПУСТО ДЕЛАТЬ
      cur.T := Tf;
      ЕСЛИ Rec ТОГДА
        ЕСЛИ Tf.Align > Tr.Align ТОГДА
          Tr.Align := Tf.Align
        КОНЕЦ;
        ЕСЛИ Tr.Rec = record ТОГДА
          cur.Offset := FieldOffset(Tf.Align, Tr.размер);
          мПров.Тест2(cur.Offset <= мКонст.целое_макс - Tf.размер, 83);
          Tr.размер := cur.Offset + Tf.размер
        АЕСЛИ Tr.Rec = noalign ТОГДА
          cur.Offset := FieldOffset(1, Tr.размер);
          мПров.Тест2(cur.Offset <= мКонст.целое_макс - Tf.размер, 83);
          Tr.размер := cur.Offset + Tf.размер
        АЕСЛИ Tr.Rec = union ТОГДА
          ЕСЛИ Tf.размер > Tr.размер ТОГДА
            Tr.размер := Tf.размер
          КОНЕЦ;
          cur.Offset := 0
        КОНЕЦ
      ИНАЧЕ
        Tr.Len := Tr.Len + 4 * (ORD((Tf.tType = TRECORD) & cur.ByRef) + Dim(Tf) + ORD((Tf.tType = TLONGREAL) & ~cur.ByRef) + 1)
      КОНЕЦ;
      cur := cur.следующ(туПоле)
    КОНЕЦ
  КОНЕЦ SetFields;

ПРОЦЕДУРА GetField*(T: туТип; Name: мТипы.туУзел): туПоле;
  ПЕРЕМ
    cur, Res: туПоле;
  НАЧАЛО
    Res := ПУСТО;
    cur := T.Fields.предыдущ(туПоле);
    ПОКА (cur # ПУСТО) & (cur.Name = Name) ДЕЛАТЬ
      Res := cur;
      cur := ПУСТО
    АЕСЛИ cur # ПУСТО ДЕЛАТЬ
      cur := cur.следующ(туПоле)
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ GetField;

ПРОЦЕДУРА Unique(T: туТип; Name: мТипы.туУзел): БУЛЕВО;
  ПЕРЕМ
    field: туПоле;
    res: БУЛЕВО;
  НАЧАЛО
    res := ИСТИНА;
    ПОКА (T # ПУСТО) & res ДЕЛАТЬ
      field := GetField(T, Name);
      ЕСЛИ field # ПУСТО ТОГДА
        ЕСЛИ (field.Unit = unit) ИЛИ field.Export ТОГДА
          res := ЛОЖЬ
        КОНЕЦ
      КОНЕЦ;
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Unique;

ПРОЦЕДУРА notrecurs(id: БУЛЕВО; T: туТип): БУЛЕВО;
    ВЕРНУТЬ ~(id & (unit.Idents.следующ(туИмя).iType = IDTYPE) & (unit.Idents.следующ(туИмя).T = T) &
            (T.tType IN {TRECORD, TARRAY}))
  КОНЕЦ notrecurs;

ПРОЦЕДУРА ReadFields(T: туТип);
  ПЕРЕМ
    Name: мТипы.туУзел;
    field: туПоле;
    Tf: туТип;
    line, col: ЦЕЛОЕ;
    id_T: БУЛЕВО;
  НАЧАЛО
    ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
      Name := мСкан.id;
      мПров.Тест2(Unique(T, Name), 30);
      НОВ(field);
      ПамОш_Проверить(field = ПУСТО);
      мСпис.Добавить(T.Fields, field);
      field.Name := Name;
      field.T := ПУСТО;
      field.Export := ЛОЖЬ;
      field.Unit := unit;
      КлючСлед_Получ;
      ЕСЛИ мСкан.сущность = мКонст.опУмнож ТОГДА
        мПров.Тест2(unit.Level = 3, 89);
        мПров.Тест2(unit.typedecl, 91);
        мПров.Тест2(unit.ExportType, 92);
        field.Export := ИСТИНА;
        КлючСлед_Получ
      КОНЕЦ;
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        КлючСлед_Получ;
        Ключ_Проверить(lxIDENT)
      АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
        КлючСлед_Получ;
        Коорд_Уст(line, col);
        id_T := мСкан.сущность = lxIDENT;
        Tf:= pParseType(line, col);
        мПров.Тест(Tf # ПУСТО, line, col, 42);
        мПров.Тест(notrecurs(id_T, Tf), line, col, 96);
        SetFields(T, Tf, ИСТИНА);
        ЕСЛИ мСкан.сущность = мКонст.опТчкЗпт ТОГДА
          КлючСлед_Получ;
          Ключ_Проверить(lxIDENT)
        ИНАЧЕ
          мПров.Тест2(мСкан.сущность = мКонст.ксКОНЕЦ, 86)
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 85)
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ ReadFields;

ПРОЦЕДУРА OpenBase*(T: туТип): туТип;
  НАЧАЛО
    ПОКА (T.tType = TARRAY) & (T.Len = 0) ДЕЛАТЬ
      T := T.Base
    КОНЕЦ
    ВЕРНУТЬ T
  КОНЕЦ OpenBase;

ПРОЦЕДУРА SetVars(T: туТип);
  ПЕРЕМ
    cur: туИмя;
    n: ЦЕЛОЕ;
  НАЧАЛО
    cur := unit.Idents.следующ(туИмя);
    ПОКА cur.T = ПУСТО ДЕЛАТЬ
      cur := cur.предыдущ(туИмя)
    КОНЕЦ;
    cur := cur.следующ(туИмя);
    ПОКА cur # ПУСТО ДЕЛАТЬ
      cur.T := T;
      ЕСЛИ cur.Export ТОГДА
        мПров.Тест(~(T.tType IN {TRECORD, TARRAY}), cur.line, cur.col, 90)
      КОНЕЦ;
      ЕСЛИ(cur.VarKind = paramvar) ИЛИ (cur.VarKind = param) & (T.tType IN {TRECORD, TARRAY}) ТОГДА
        n := 4 * (1 + Dim(T) + ORD((cur.VarKind = paramvar) & (T.tType = TRECORD)))
      ИНАЧЕ
        n := T.размер;
        мПров.Тест2(n <= мКонст.целое_макс - мПам.Выровнять(n), 93);
        n := n + мПам.Выровнять(n)
      КОНЕЦ;
      ЕСЛИ cur.Level = 3 ТОГДА
        cur.Offset := ProgSize;
        мПров.Тест2(ProgSize <= мКонст.целое_макс - n, 93);
        ProgSize := ProgSize + n;
        мПров.Тест2(ProgSize <= мКонст.целое_макс - мПам.Выровнять(ProgSize), 93);
        ProgSize := ProgSize + мПам.Выровнять(ProgSize)
      ИНАЧЕ
        ЕСЛИ cur.VarKind = 0 ТОГДА
          cur.Offset := curBlock.ParamSize - curBlock.VarSize - n
        ИНАЧЕ
          cur.Offset := curBlock.VarSize - 8 + 4 * (cur.Level + ORD((cur.VarKind = paramvar) & (T.tType = TRECORD)))
        КОНЕЦ
      КОНЕЦ;
      мПров.Тест2(curBlock.VarSize <= мКонст.целое_макс - n, 93);
      curBlock.VarSize := curBlock.VarSize + n;
      мПров.Тест2(curBlock.VarSize <= мКонст.целое_макс - мПам.Выровнять(curBlock.VarSize), 93);
      curBlock.VarSize := curBlock.VarSize + мПам.Выровнять(curBlock.VarSize);
      ЕСЛИ cur.VarKind # 0 ТОГДА
        curBlock.ParamSize := curBlock.VarSize
      КОНЕЦ;
      cur := cur.следующ(туИмя)
    КОНЕЦ
  КОНЕЦ SetVars;

ПРОЦЕДУРА Тип_Создать(tType, Len, Size, Number: ЦЕЛОЕ; Base: туТип; Fields: БУЛЕВО; NewType: туТип): туТип;
  ПЕРЕМ
    nov: туТип;
  НАЧАЛО
    ЕСЛИ NewType = ПУСТО ТОГДА
      НОВ(nov);
      ПамОш_Проверить(nov = ПУСТО)
    ИНАЧЕ
      nov := NewType
    КОНЕЦ;
    мСпис.Добавить(types, nov);
    nov.tType := tType;
    nov.Len := Len;
    nov.размер := Size;
    nov.Base := Base;
    nov.Fields := ПУСТО;
    nov.Number := Number;
    ЕСЛИ Fields ТОГДА
      nov.Fields := мСпис.Создать();
      ПамОш_Проверить(nov.Fields = ПУСТО)
    КОНЕЦ
    ВЕРНУТЬ nov
  КОНЕЦ Тип_Создать;

ПРОЦЕДУРА FormalType(ПЕР line, col: ЦЕЛОЕ): туТип;
  ПЕРЕМ
    TA: туТип;
  НАЧАЛО
    ЕСЛИ мСкан.сущность = мКонст.ксМАССИВ ТОГДА
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.ксИЗ);
      КлючСлед_Получ;
      TA := Тип_Создать(TARRAY, 0, 0, 0, FormalType(line, col), ЛОЖЬ, ПУСТО)
    ИНАЧЕ
      Ключ_Проверить(lxIDENT);
      TA := IdType(line, col);
      мПров.Тест(TA # ПУСТО, line, col, 42);
    КОНЕЦ
    ВЕРНУТЬ TA
  КОНЕЦ FormalType;

ПРОЦЕДУРА Section(T: туТип);
  ПЕРЕМ
      Name: мТипы.туУзел;
      ByRef, cont: БУЛЕВО;
      field: туПоле;
      Tf: туТип;
      fp: туИмя;
      line, col: ЦЕЛОЕ;
      proc: БУЛЕВО;
  НАЧАЛО
    proc := T = ПУСТО;
    ЕСЛИ proc ТОГДА
      T := curBlock.T
    КОНЕЦ;
    мПров.Тест2((мСкан.сущность = lxIDENT) ИЛИ (мСкан.сущность = мКонст.ксПЕРЕМ), 84);
    ByRef := ЛОЖЬ;
    ЕСЛИ мСкан.сущность = мКонст.ксПЕРЕМ ТОГДА
      ByRef := ИСТИНА;
      КлючСлед_Получ;
      Ключ_Проверить(lxIDENT)
    КОНЕЦ;
    cont := ИСТИНА;
    ПОКА cont ДЕЛАТЬ
      Name := мСкан.id;
      мПров.Тест2(GetField(T, Name) = ПУСТО, 30);
      НОВ(field);
      ПамОш_Проверить(field = ПУСТО);
      мСпис.Добавить(T.Fields, field);
      field.Name := Name;
      field.T := ПУСТО;
      field.ByRef := ByRef;
      ЕСЛИ proc ТОГДА
        PushIdent(Name, line, col, IDVAR, ПУСТО, ПУСТО, ЛОЖЬ, 0);
        ДОБ(curBlock.ParamCount);
        fp := unit.Idents.следующ(туИмя);
        ЕСЛИ ByRef ТОГДА
          fp.VarKind := paramvar
        ИНАЧЕ
          fp.VarKind := param
        КОНЕЦ
      КОНЕЦ;
      КлючСлед_Получ;
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        КлючСлед_Получ;
        Ключ_Проверить(lxIDENT)
      АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
        КлючСлед_Получ;
        Tf := FormalType(line, col);
        мПров.Тест(Dim(Tf) <= X86.ADIM, line, col, 110);
        SetFields(T, Tf, ЛОЖЬ);
        ЕСЛИ proc ТОГДА
          SetVars(Tf)
        КОНЕЦ;
        cont := ЛОЖЬ
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 85)
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ Section;

ПРОЦЕДУРА ParamType(T: туТип);
  ПЕРЕМ break: БУЛЕВО;
  НАЧАЛО
    ЕСЛИ (мСкан.сущность = lxIDENT) ИЛИ (мСкан.сущность = мКонст.ксПЕРЕМ) ТОГДА
      break := ЛОЖЬ;
      ПОВТОРЯТЬ
        Section(T);
        ЕСЛИ мСкан.сущность = мКонст.опТчкЗпт ТОГДА
          КлючСлед_Получ
        ИНАЧЕ
          break := ИСТИНА
        КОНЕЦ
      ПОКАНЕ break
    КОНЕЦ
  КОНЕЦ ParamType;

ПРОЦЕДУРА AddPtrBase(Name: мТипы.туУзел; line, col: ЦЕЛОЕ; T: туТип);
  ПЕРЕМ nov: PTRBASE;
  НАЧАЛО
    НОВ(nov);
    ПамОш_Проверить(nov = ПУСТО);
    nov.Name := Name;
    nov.line := line;
    nov.col := col;
    nov.Ptr := T;
    мСпис.Добавить(PtrBases, nov)
  КОНЕЦ AddPtrBase;

ПРОЦЕДУРА FormalList(T: туТип; ПЕР Res: туТип);
  ПЕРЕМ line, col: ЦЕЛОЕ;
  НАЧАЛО
    ЕСЛИ мСкан.сущность = lxLRound ТОГДА
      КлючСлед_Получ;
      ParamType(T);
      Ключ_Проверить(мКонст.опСкобкаПрКр);
      КлючСлед_Получ;
      ЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
        КлючСлед_Получ;
        Ключ_Проверить(lxIDENT);
        Res := IdType(line, col);
        мПров.Тест(Res # ПУСТО, line, col, 42);
        мПров.Тест(~(Res.tType IN {TRECORD, TARRAY}), line, col, 82)
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ FormalList;

ПРОЦЕДУРА CallFlag(ПЕР Call: ЦЕЛОЕ): БУЛЕВО;
  ПЕРЕМ
    flag: мСтр.тСтрока;
    res: БУЛЕВО;
  НАЧАЛО
    res := мСкан.сущность = мКонст.опСкобкаЛевКв;
    ЕСЛИ res ТОГДА
      КлючСлед_Получ;
      мСкан.GetLexStr(flag);
      ЕСЛИ flag = "cdecl" ТОГДА
        Call := cdecl
      АЕСЛИ flag = "stdcall" ТОГДА
        Call := stdcall
      АЕСЛИ flag = "winapi" ТОГДА
        мПров.Тест2(winplatf, 50);
        Call := winapi
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 44)
      КОНЕЦ;
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опСкобкаПрКв);
      КлючСлед_Получ;
    ИНАЧЕ
      Call := defcall
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ CallFlag;

ПРОЦЕДУРА RecFlag(ПЕР rec: ЦЕЛОЕ): БУЛЕВО;
  ПЕРЕМ
    flag: мСтр.тСтрока;
    res: БУЛЕВО;
  НАЧАЛО
    res := мСкан.сущность = мКонст.опСкобкаЛевКв;
    ЕСЛИ res ТОГДА
      КлючСлед_Получ;
      мСкан.GetLexStr(flag);
      ЕСЛИ flag = "union" ТОГДА
        rec := union
      АЕСЛИ flag = "noalign" ТОГДА
        rec := noalign
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 103)
      КОНЕЦ;
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опСкобкаПрКв);
      КлючСлед_Получ;
    ИНАЧЕ
      rec := record
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ RecFlag;

ПРОЦЕДУРА StructType(Comma: БУЛЕВО; NewType: туТип): туТип;
  ПЕРЕМ
    v: ДЛИНВЕЩ;
    T, nov: туТип;
    line, col, line2, col2: ЦЕЛОЕ;
    id_T: БУЛЕВО;
  НАЧАЛО
    ВЫБОР мСкан.сущность ИЗ
    |мКонст.ксМАССИВ, мКонст.опЗапятая:
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        мПров.Тест2(Comma, 39)
      КОНЕЦ;
      КлючСлед_Получ;
      Коорд_Уст(line, col);
      ConstExpr(v, T);
      мПров.Тест(T.tType = TINTEGER, line, col, 52);
      мПров.Тест(v > 0.0D0, line, col, 78);
      nov := Тип_Создать(TARRAY, FLOOR(v), 0, 0, ПУСТО, ЛОЖЬ, NewType);
      ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
        nov.Base := StructType(ИСТИНА, ПУСТО)
      АЕСЛИ мСкан.сущность = мКонст.ксИЗ ТОГДА
        КлючСлед_Получ;
        Коорд_Уст(line, col);
        id_T := мСкан.сущность = lxIDENT;
        nov.Base := pParseType(line, col);
        мПров.Тест(nov.Base # ПУСТО, line, col, 42);
        мПров.Тест(notrecurs(id_T, nov.Base), line, col, 96)
      ИНАЧЕ
        мПров.Тест2(ЛОЖЬ, 79)
      КОНЕЦ;
      мПров.Тест2(nov.Base.размер <= мКонст.целое_макс DIV nov.Len, 83);
      nov.размер := nov.Base.размер * nov.Len;
      nov.Align := nov.Base.Align
    |мКонст.ксЗАПИСЬ:
      КлючСлед_Получ;
      ДОБ(RecCount);
      nov := Тип_Создать(TRECORD, 0, 0, RecCount, ПУСТО, ИСТИНА, NewType);
      nov.Align := 1;
      Коорд_Уст(line, col);
      ЕСЛИ RecFlag(nov.Rec) ТОГДА
        мПров.Тест(unit.sys, line, col, 111)
      КОНЕЦ;
      Коорд_Уст(line, col);
      ЕСЛИ мСкан.сущность = lxLRound ТОГДА
        КлючСлед_Получ;
        Коорд_Уст(line2, col2);
        Ключ_Проверить(lxIDENT);
        nov.Base := IdType(line, col);
        мПров.Тест(nov.Base # ПУСТО, line, col, 42);
        мПров.Тест(nov.Base.tType = TRECORD, line, col, 80);
        мПров.Тест(notrecurs(ИСТИНА, nov.Base), line, col, 96);
        nov.размер := nov.Base.размер;
        nov.Align := nov.Base.Align;
        Ключ_Проверить(мКонст.опСкобкаПрКр);
        КлючСлед_Получ;
        мПров.Тест(nov.Rec = record, line, col, 112);
        мПров.Тест(nov.Base.Rec = record, line2, col2, 113)
      КОНЕЦ;
      ReadFields(nov);
      Ключ_Проверить(мКонст.ксКОНЕЦ);
      nov.размер := X86.Align(nov.размер, nov.Align);
      ЕСЛИ nov.Base # ПУСТО ТОГДА
        X86.AddRec(nov.Base.Number)
      ИНАЧЕ
        X86.AddRec(0)
      КОНЕЦ;
      КлючСлед_Получ
    |мКонст.ксУКАЗАТЕЛЬ:
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.ксДО);
      КлючСлед_Получ;
      nov := Тип_Создать(TPOINTER, 0, 4, 0, ПУСТО, ЛОЖЬ, NewType);
      nov.Align := 4;
      Коорд_Уст(line, col);
      nov.Base := pParseType(line, col);
      ЕСЛИ nov.Base = ПУСТО ТОГДА
        мПров.Тест(unit.typedecl, line, col, 42);
        AddPtrBase(NamePtrBase, line, col, nov)
      ИНАЧЕ
        мПров.Тест(nov.Base.tType = TRECORD, line, col, 81)
      КОНЕЦ
    |мКонст.ксПРОЦЕДУРА:
      КлючСлед_Получ;
      nov := Тип_Создать(TPROC, 0, 4, 0, sttypes[TVOID], ИСТИНА, NewType);
      Коорд_Уст(line, col);
      ЕСЛИ CallFlag(nov.Call) ТОГДА
        мПров.Тест(unit.sys, line, col, 111)
      КОНЕЦ;
      nov.Align := 4;
      FormalList(nov, nov.Base)
    ИНАЧЕ
      мПров.Тест2(ЛОЖЬ, 39)
    КОНЕЦ
    ВЕРНУТЬ nov
  КОНЕЦ StructType;

ПРОЦЕДУРА ParseType(ПЕР line, col: ЦЕЛОЕ): туТип;
  ПЕРЕМ
    Res: туТип;
  НАЧАЛО
    ЕСЛИ мСкан.сущность = lxIDENT ТОГДА
      Res := IdType(line, col)
    ИНАЧЕ
      Res := StructType(ЛОЖЬ, ПУСТО)
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ ParseType;

ПРОЦЕДУРА PopBlock;
  ПЕРЕМ
    cur: туИмя;
    n: ЦЕЛОЕ;
  НАЧАЛО
    cur := unit.Idents.следующ(туИмя);
    n := 0;
    ПОКА cur.iType # IDGUARD ДЕЛАТЬ
      cur := cur.предыдущ(туИмя);
      ДОБ(n)
    КОНЕЦ;
    cur := cur.предыдущ(туИмя);
    ДОБ(n);
    unit.Idents.счетчик := unit.Idents.счетчик - n;
    unit.Idents.следующ := cur;
    cur.следующ := ПУСТО;
    ВЫЧ(unit.Level)
  КОНЕЦ PopBlock;

ПРОЦЕДУРА LinkPtr;
  ПЕРЕМ
    cur: PTRBASE;
    id: туИмя;
  НАЧАЛО
    cur := PtrBases.предыдущ(PTRBASE);
    ПОКА cur # ПУСТО ДЕЛАТЬ
      id := GetIdent(cur.Name);
      мПров.Тест(id # ПУСТО, cur.line, cur.col, 42);
      мПров.Тест(id.T.tType = TRECORD, cur.line, cur.col, 81);
      cur.Ptr.Base := id.T;
      cur := cur.следующ(PTRBASE)
    КОНЕЦ;
    мСпис.Очистить(PtrBases)
  КОНЕЦ LinkPtr;

ПРОЦЕДУРА DeclSeq;
  ПЕРЕМ
    Value: ДЛИНВЕЩ;
    T, NewType: туТип;
    Name: мТипы.туУзел;
    line, col, Call: ЦЕЛОЕ;
    Export, func: БУЛЕВО;
    last, id: туИмя;
    e: тВыражение;

    ПРОЦЕДУРА IdentDef;
    НАЧАЛО
      Name := мСкан.id;
      Коорд_Уст(line, col);
      КлючСлед_Получ;
      Export := ЛОЖЬ;
      ЕСЛИ мСкан.сущность = мКонст.опУмнож ТОГДА
        мПров.Тест2(unit.Level = 3, 89);
        Export := ИСТИНА;
        КлючСлед_Получ
      КОНЕЦ
    КОНЕЦ IdentDef;

  НАЧАЛО
    ЕСЛИ мСкан.сущность = мКонст.ксКОНСТ ТОГДА
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDCONST, ПУСТО, ПУСТО, Export, 0);
        last := unit.Idents.следующ(туИмя);
        Ключ_Проверить(мКонст.опРавно);
        КлючСлед_Получ;
        ConstExpr(Value, T);
        Ключ_Проверить(мКонст.опТчкЗпт);
        last.Value := Value;
        last.T := T;
        КлючСлед_Получ
      КОНЕЦ
    КОНЕЦ;
    ЕСЛИ мСкан.сущность = мКонст.ксТИПЫ ТОГДА
      мСпис.Очистить(PtrBases);
      unit.typedecl := ИСТИНА;
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDTYPE, ПУСТО, ПУСТО, Export, 0);
        last := unit.Idents.следующ(туИмя);
        unit.ExportType := Export;
        Ключ_Проверить(мКонст.опРавно);
        КлючСлед_Получ;
        НОВ(NewType);
        ПамОш_Проверить(NewType = ПУСТО);
        last.T := NewType;
        T := StructType(ЛОЖЬ, NewType);
        Ключ_Проверить(мКонст.опТчкЗпт);
        КлючСлед_Получ
      КОНЕЦ
    КОНЕЦ;
    LinkPtr;
    unit.typedecl := ЛОЖЬ;
    unit.ExportType := ЛОЖЬ;
    ЕСЛИ мСкан.сущность = мКонст.ксПЕРЕМ ТОГДА
      КлючСлед_Получ;
      ПОКА мСкан.сущность = lxIDENT ДЕЛАТЬ
        IdentDef;
        PushIdent(Name, line, col, IDVAR, ПУСТО, ПУСТО, Export, 0);
        ЕСЛИ мСкан.сущность = мКонст.опЗапятая ТОГДА
          КлючСлед_Получ;
          Ключ_Проверить(lxIDENT)
        АЕСЛИ мСкан.сущность = мКонст.опДвоеточ ТОГДА
          КлючСлед_Получ;
          Коорд_Уст(line, col);
          T := ParseType(line, col);
          мПров.Тест(T # ПУСТО, line, col, 42);
          SetVars(T);
          Ключ_Проверить(мКонст.опТчкЗпт);
          КлючСлед_Получ
        ИНАЧЕ
          мПров.Тест2(ЛОЖЬ, 85)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ;
    ПОКА мСкан.сущность = мКонст.ксПРОЦЕДУРА ДЕЛАТЬ
      КлючСлед_Получ;
      Коорд_Уст(line, col);
      ЕСЛИ CallFlag(Call) ТОГДА
        мПров.Тест(unit.Level = 3, line, col, 45);
        мПров.Тест(unit.sys, line, col, 111)
      КОНЕЦ;
      Ключ_Проверить(lxIDENT);
      IdentDef;
      PushIdent(Name, line, col, IDPROC, Тип_Создать(TPROC, 0, 4, 0, sttypes[TVOID], ИСТИНА, ПУСТО), ПУСТО, Export, 0);
      id := unit.Idents.следующ(туИмя);
      ЕСЛИ id.Export & main ТОГДА
        ЕСЛИ Platform = 6 ТОГДА
          мПров.Тест((Name # мСкан._START) & (Name # мСкан._version), line, col, 133)
        КОНЕЦ;
        X86.ProcExport(id.Number, Name, X86.NewLabel())
      КОНЕЦ;
      id.Parent := curBlock;
      curBlock := id;
      Охрана_Создать;
      FormalList(ПУСТО, curBlock.T.Base);
      id.T.Call := Call;
      Ключ_Проверить(мКонст.опТчкЗпт);
      КлючСлед_Получ;
      DeclSeq;
      id.LocalSize := id.VarSize - id.ParamSize;
      X86.ProcBeg(id.Number, id.LocalSize, ЛОЖЬ);
      ЕСЛИ мСкан.сущность = мКонст.ксНАЧАЛО ТОГДА
        КлючСлед_Получ;
        OpSeq
      КОНЕЦ;
      func := curBlock.T.Base.tType # TVOID;
      ЕСЛИ func ТОГДА
        Ключ_Проверить(мКонст.ксВЕРНУТЬ);
        мУтиль.КодСтрока_Уст(UnitNumber, мСкан.line);
        КлючСлед_Получ;
        Коорд_Уст(line, col);
        Expr(e);
        мПров.Тест(AssComp(e, curBlock.T.Base, ЛОЖЬ), line, col, 125);
        ЕСЛИ e.eType = eVAR ТОГДА
          X86.Load(e.T.tType)
        КОНЕЦ
      ИНАЧЕ
        мПров.Тест2(мСкан.сущность # мКонст.ксВЕРНУТЬ, 123)
      КОНЕЦ;
      Ключ_Проверить(мКонст.ксКОНЕЦ);
      КлючСлед_Получ;
      Ключ_Проверить(lxIDENT);
      мПров.Тест2(мСкан.id = Name, 87);
      КлючСлед_Получ;
      Ключ_Проверить(мКонст.опТчкЗпт);
      КлючСлед_Получ;
      X86.ProcEnd(id.Number, (id.ParamSize + (id.Level - 3) * 4) * ORD(curBlock.T.Call IN {stdcall, winapi, defcall}), func, curBlock.T.Base.tType IN {TREAL, TLONGREAL});
      PopBlock;
      curBlock := curBlock.Parent
    КОНЕЦ
  КОНЕЦ DeclSeq;

ПРОЦЕДУРА Rtl_Добав(u: тМодуль);

    ПРОЦЕДУРА AddProc(name: мСтр.тСтрока; num: ЦЕЛОЕ);
      ПЕРЕМ
        id: туИмя;
      НАЧАЛО
        id := GetQIdent(u, мСкан.Узел_Добав(name));
        ЕСЛИ id = ПУСТО ТОГДА
          мОш.Сообщ(158);
          мПроц.Закончить(1)
        КОНЕЦ;
        X86.AddRtlProc(num, id.Number)
      КОНЕЦ AddProc;

  НАЧАЛО
    AddProc("_newrec", X86._newrec);
    AddProc("_disprec", X86._disprec);
    AddProc("_rset", X86._rset);
    AddProc("_inset", X86._inset);
    AddProc("_saverec", X86._saverec);
    AddProc("_checktype", X86._checktype);
    AddProc("_strcmp", X86._strcmp);
    AddProc("_lstrcmp", X86._lstrcmp);
    AddProc("_rstrcmp", X86._rstrcmp);
    AddProc("_savearr", X86._savearr);
    AddProc("_arrayidx", X86._arrayidx);
    AddProc("_arrayidx1", X86._arrayidx1);
    AddProc("_arrayrot", X86._arrayrot);
    AddProc("_assrt", X86._assrt);
    AddProc("_strcopy", X86._strcopy);
    AddProc("_init", X86._init);
    AddProc("_close", X86._close);
    AddProc("_halt", X86._halt);
    AddProc("_length", X86._length);
  КОНЕЦ Rtl_Добав;

ПРОЦЕДУРА ImportList;
  ПЕРЕМ
    cond, col, line, namecol, nameline: ЦЕЛОЕ;
    name, alias: мТипы.туУзел;
    u, self: тМодуль;
    FName: мСтр.тСтрока;

  ПРОЦЕДУРА Модуль_Добавить(newcond: ЦЕЛОЕ);
    ПЕРЕМ
      str: туПунктСтр;
    НАЧАЛО
      u := Модуль_Получ(name);
      ЕСЛИ u = ПУСТО ТОГДА
        self := unit;
        мСкан.Сохранить(unit.scanner);
        COPY(name.имя, FName);
        ЕСЛИ ~((~self.Std & пМодуль_Читать(Path, FName, мКонст.расшир)) ИЛИ
                            пМодуль_Читать(Std, FName, мКонст.расшир)) ТОГДА
          ЕСЛИ FName = "SYSTEM" ТОГДА
            unit := sys;
            self.sys := ИСТИНА
          ИНАЧЕ
            мПров.Тест(ЛОЖЬ, nameline, namecol, 32)
          КОНЕЦ
        КОНЕЦ;
        мСкан.Откатить(self.scanner);
        u := unit;
        unit := self;
        мФайл.Имя_Уст(unit.File)
      ИНАЧЕ
        мПров.Тест(u.Closed, nameline, namecol, 31)
      КОНЕЦ;
      PushIdent(alias, line, col, IDMOD, sttypes[TVOID], u, ЛОЖЬ, 0);
      НОВ(str);
      ПамОш_Проверить(str = ПУСТО);
      str.Str := name.имя;
      мСпис.Добавить(unit.Import, str);
      cond := newcond
    КОНЕЦ Модуль_Добавить;

  НАЧАЛО
    cond := 0;
    ПОКА cond # 4 ДЕЛАТЬ
      КлючСлед_Получ;
      ВЫБОР cond ИЗ
      |0: Ключ_Проверить(lxIDENT);
          name := мСкан.id;
          Коорд_Уст(line, col);
          Коорд_Уст(nameline, namecol);
          alias := name;
          cond := 1
      |1: ВЫБОР мСкан.сущность ИЗ
          |мКонст.опЗапятая:  Модуль_Добавить(0)
          |мКонст.опТчкЗпт:   Модуль_Добавить(4); КлючСлед_Получ
          |lxAssign: cond := 2
          ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 28)
          КОНЕЦ
      |2: Ключ_Проверить(lxIDENT);
          name := мСкан.id;
          Коорд_Уст(nameline, namecol);
          cond := 3
      |3: ВЫБОР мСкан.сущность ИЗ
          |мКонст.опЗапятая: Модуль_Добавить(0)
          |мКонст.опТчкЗпт:  Модуль_Добавить(4); КлючСлед_Получ
          ИНАЧЕ
            мПров.Тест2(ЛОЖЬ, 29)
          КОНЕЦ
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ
  КОНЕЦ ImportList;

ПРОЦЕДУРА Header(Name: мТипы.туУзел);
  НАЧАЛО
    НОВ(unit);
    ПамОш_Проверить(unit = ПУСТО);
    unit.Idents := мСпис.Создать();
    ПамОш_Проверить(unit.Idents = ПУСТО);
    unit.Level := 0;
    unit.Name := Name;
    Охрана_Создать;
    Охрана_Создать;
    PushIdent(unit.Name, 0, 0, IDMOD, sttypes[TVOID], unit, ЛОЖЬ, 0);
    Охрана_Создать;
    unit.IdentBegin := unit.Idents.следующ(туИмя);
    unit.Closed := ИСТИНА
  КОНЕЦ Header;

ПРОЦЕДУРА Псевдо_Добав;
  ПЕРЕМ
    модуль: тМодуль;
  НАЧАЛО
    модуль := unit;
    Header(мСкан.Узел_Добав("SYSTEM"));
    PushSysProc("ADR",     sysADR);
    PushSysProc("SIZE",    sysSIZE);
    PushSysProc("TYPEID",  sysTYPEID);
    PushSysProc("BIT",     sysBIT);
    PushSysProc("GET",     sysGET);
    PushSysProc("PUT",     sysPUT);
    PushSysProc("CODE",    sysCODE);
    PushSysProc("MOVE",    sysMOVE);
    PushSysType("CARD16",  TCARD16);
    sys := unit;
    unit := модуль
  КОНЕЦ Псевдо_Добав;

ПРОЦЕДУРА Модуль_Читать(Path, Name1, Ext: мСтр.тСтрока): БУЛЕВО;
  ПЕРЕМ
    FHandle: ЦЕЛОЕ;
    name, Name, b: мСтр.тСтрока;
    idmod: туИмя;
    Res, temp: БУЛЕВО;
  НАЧАЛО
    Res := ЛОЖЬ;
    name := Name1;
    Name := Name1;
    мСтр.Сложить(Path, Name, b);
    мСтр.Сложить(b, Ext, Name);
    ЕСЛИ мСкан.Файл_Открыть(Name, FHandle) ТОГДА
      НОВ(unit);
      ПамОш_Проверить(unit = ПУСТО);
      unit.sys := ЛОЖЬ;
      unit.Std := Path = Std;
      мСпис.Добавить(prog, unit);
      unit.Idents := мСпис.Создать();
      ПамОш_Проверить(unit.Idents = ПУСТО);
      unit.Import := мСпис.Создать();
      ПамОш_Проверить(unit.Import = ПУСТО);
      НОВ(unit.scanner);
      ПамОш_Проверить(unit.scanner = ПУСТО);
      unit.Closed := ЛОЖЬ;
      unit.Level := 0;
      unit.typedecl := ЛОЖЬ;
      unit.ExportType := ЛОЖЬ;
      COPY(Name, unit.File);
      мФайл.Имя_Уст(unit.File);
      StIdent;
      КлючСлед_Получ; Ключ_Проверить(мКонст.ксМОДУЛЬ);
      
      КлючСлед_Получ; Ключ_Проверить(lxIDENT);
      мПров.Тест2(мУтиль.streq(мСкан.id.имя, name), 33);
      unit.Name := мСкан.id;
      PushIdent(unit.Name, мСкан.line, мСкан.col, IDMOD, sttypes[TVOID], unit, ЛОЖЬ, 0);
      idmod := unit.Idents.следующ(туИмя);
      Охрана_Создать;
      КлючСлед_Получ; Ключ_Проверить(мКонст.опТчкЗпт);
      КлючСлед_Получ;
      ЕСЛИ мСкан.сущность = мКонст.ксИМПОРТ ТОГДА
        temp := main;
        main := ЛОЖЬ;
        ImportList;
        main := temp
      КОНЕЦ;
      мКонс.Строка_Печать("Компилирую: "); мКонс.Строка_Печать(unit.Name.имя); мКонс.Строка_Печать("."); мКонс.НовСтр;
      X86.Module(idmod.Name.имя, idmod.Number);
      UnitNumber := idmod.Number;
      unit.IdentBegin := unit.Idents.следующ(туИмя);
      curBlock := idmod;
      DeclSeq;
      X86.ProcBeg(idmod.Number, 0, ИСТИНА);
      ЕСЛИ мСкан.сущность = мКонст.ксНАЧАЛО ТОГДА
        КлючСлед_Получ;
        OpSeq
      КОНЕЦ;
      Ключ_Проверить(мКонст.ксКОНЕЦ);
      КлючСлед_Получ; Ключ_Проверить(lxIDENT);
      мПров.Тест2(мСкан.id = unit.Name, 26);
      КлючСлед_Получ; Ключ_Проверить(lxDot);
      X86.Leave;
      unit.Closed := ИСТИНА;
      мСпис.Очистить(unit.Import);
      Res := ИСТИНА
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ Модуль_Читать;

ПРОЦЕДУРА Код_Настроить*(StdPath, FilePath, NameFile, ExtFile: мСтр.тСтрока; windows: БУЛЕВО;
    OpSeqProc: тПроцедура; ExprProc: тПроцедураПер; AssCompProc: тПроцедураСвязь; ПЕР stypes: туТипНабор);
  НАЧАЛО
    winplatf := windows;
    Path := FilePath;
    Main := NameFile;
    ExtMain := ExtFile;
    Std := StdPath;
    OpSeq := OpSeqProc;
    Expr := ExprProc;
    AssComp := AssCompProc;
    prog := мСпис.Создать();
    ПамОш_Проверить(prog = ПУСТО);
    PtrBases := мСпис.Создать();
    ПамОш_Проверить(PtrBases = ПУСТО);
    types := мСпис.Создать();
    ПамОш_Проверить(types = ПУСТО);
    StTypes;
    строки := мСпис.Создать();
    ПамОш_Проверить(строки = ПУСТО);
    Псевдо_Добав;
    stypes := sttypes
  КОНЕЦ Код_Настроить;

ПРОЦЕДУРА delfirstchar(ПЕР s: мСтр.тСтрока);
  ПЕРЕМ i: ЦЕЛОЕ;
  НАЧАЛО
    ДЛЯ i := 0 ДО ДЛИНА(s) - 1 ДЕЛАТЬ
      s[i] := s[i + 1]
    КОНЕЦ
  КОНЕЦ delfirstchar;

ПРОЦЕДУРА Компилировать*(platform, stksize: ЦЕЛОЕ);
  ПЕРЕМ
    full, path, name, ext, temp, path2: мСтр.тСтрока;
  НАЧАЛО
    Platform := platform;
    main := ЛОЖЬ;
    ЕСЛИ Модуль_Читать(Std, "RTL", мКонст.расшир) ТОГДА
      Rtl_Добав(unit)
    ИНАЧЕ
      мОш.Сообщ(65);
      мПроц.Закончить(1)
    КОНЕЦ;
    main := ИСТИНА;
    ЕСЛИ ~Модуль_Читать(Path, Main, ExtMain) ТОГДА
      path2 := Path;
      мУтиль.СтрПарам(full, 0);
      мСтр.Разделить(full, path, name, ext);
      ЕСЛИ path[0] # 0X ТОГДА
        path[ДЛИНА(path) - 1] := 0X
      КОНЕЦ;
      ЕСЛИ Path[0] = мКонст.слэш ТОГДА
        delfirstchar(Path)
      КОНЕЦ;
      мСтр.Сложить(path, мКонст.слэш, path);
      мСтр.Сложить(path, Path, full);
      Path := full;
      ЕСЛИ (мКонст.ОС = "WIN") & (Path[0] = мКонст.слэш) ТОГДА
        delfirstchar(Path)
      КОНЕЦ;
      ЕСЛИ ~Модуль_Читать(Path, Main, ExtMain) ТОГДА
        мОш.Сообщ(64);
        мКонс.Строка_Печать(path2);
        мКонс.Строка_Печать(Main);
        мКонс.Строка_Печать(ExtMain);
        мКонс.НовСтр;
        мПроц.Закончить(1)
      КОНЕЦ
    КОНЕЦ;
    temp := Path;
    мСтр.Сложить(temp, Main, temp);
    ЕСЛИ platform IN {2, 3} ТОГДА
      мСтр.Сложить(temp, ".exe", temp)
    АЕСЛИ platform = 1 ТОГДА
      мСтр.Сложить(temp, ".dll", temp)
    АЕСЛИ platform = 4 ТОГДА
      мСтр.Сложить(temp, ".kex", temp)
    АЕСЛИ platform = 6 ТОГДА
      мСтр.Сложить(temp, ".obj", temp)
    КОНЕЦ;
    ЕСЛИ platform IN {1, 2, 3, 4} ТОГДА
      stksize := stksize * 100000H
    КОНЕЦ;
    X86.Epilog(ProgSize, temp, stksize)
  КОНЕЦ Компилировать;

НАЧАЛО
  pParseType := ParseType;
  пМодуль_Читать := Модуль_Читать
КОНЕЦ модДецл.
