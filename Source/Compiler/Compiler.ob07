(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.
   *)
МОДУЛЬ Compiler;

ИМПОРТ мДецл := модДецл,
   мСкан := модСканер,
   мУтиль := модУтиль,
   X86 := модАсм86_32,
   mSys := SYSTEM,
   мЗвено := модЗвено,
   мТип := модТип,
   мКонст := модКонстанты,
   мКонс := модКонсоль,
   мОш := модОшибки,
   мОшКонст := модОшибкиКонст,
   мПроц := модПроцесс,
   мСтр := модСтроки,
   мЦепь := модЦепь,
   мПров := модПроверка,
   мУзел := модЗвеноСущ,
   мВинКонс := модВинКонсоль,
   мСтек := модСтек,
   мОС := модОС,
   мФайл := модФайл,
   мПам := модПамять;

КОНСТ

   lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;

   lxLRound = 60; lxCaret = 63;
   lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
   lxLE = 75; lxGE = 76;

   eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

   IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

ТИПЫ

   тМетка = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         a, b: ЦЕЛОЕ
      КОНЕЦ;

ПЕРЕМ
   пВыраж, pFactor: ПРОЦЕДУРА (ПЕР e: мДецл.тВыражение);
   pOpSeq: ПРОЦЕДУРА;
   стрСущн: мСтр.тСтрока;
   sttypes: мДецл.туТипНабор;

ПРОЦЕДУРА Выраж_Загрузить(выраж_: мДецл.тВыражение);
   НАЧАЛО
      ЕСЛИ выраж_.eType = eVAR ТОГДА
         X86.Load(выраж_.уТип.тип_ном)
      КОНЕЦ
   КОНЕЦ Выраж_Загрузить;

ПРОЦЕДУРА Стр_Длина(адр_: ДЛИНВЕЩ): ЦЕЛОЕ;
   ПЕРЕМ
      стр: мДецл.туКонстСтр;
   НАЧАЛО
      стр := мДецл.уКонстСтр_Получ(адр_)
      ВЕРНУТЬ стр.длина
   КОНЕЦ Стр_Длина;

ПРОЦЕДУРА BaseOf(тип0_, тип1_: мТип.туТип): БУЛЕВО;
   ПЕРЕМ
      типы_равны, тип0_указатель: БУЛЕВО;
   НАЧАЛО
      типы_равны := (тип0_.тип_ном = тип1_.тип_ном);
      тип0_указатель := (тип0_.тип_ном = мКонст.типУКАЗАТЕЛЬ);
        
      ЕСЛИ типы_равны & (тип0_.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типУКАЗАТЕЛЬ}) ТОГДА
         ЕСЛИ тип0_указатель ТОГДА
            тип0_ := тип0_.Base;
            тип1_ := тип1_.Base
         КОНЕЦ;
         ПОКА (тип1_ # ПУСТО) & (тип1_ # тип0_) ДЕЛАТЬ
            тип1_ := тип1_.Base
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ тип0_ = тип1_
   КОНЕЦ BaseOf;

ПРОЦЕДУРА Designator(ПЕР выраж_: мДецл.тВыражение);
   ПЕРЕМ
      id: мДецл.туСущность;
      уУзел: мУзел.туЗвеноСущ;
      выражение: мДецл.тВыражение;
      цСтрока, col, i, n, bases, glob, loc, idx: ЦЕЛОЕ;
      imp, бОстанов, бОхрана: БУЛЕВО;
      уПоле: мДецл.туПоле;
      уТип, BaseT: мТип.туТип;
      уСтр: мДецл.туКонстСтр;

   ПРОЦЕДУРА LoadVar;
      НАЧАЛО
         ЕСЛИ glob # -1 ТОГДА
            X86.GlobalAdr(glob);
            glob := -1
         АЕСЛИ loc # -1 ТОГДА
            X86.LocalAdr(loc, bases);
            loc := -1
         КОНЕЦ
      КОНЕЦ LoadVar;

   НАЧАЛО
      glob := -1;
      loc := -1;
      мДецл.Коорд_Уст(цСтрока, col);
      мДецл.Сущность_Проверить(lxIDENT);
      уУзел := мСкан.сущ_глоб;
      id := мДецл.GetIdent(уУзел);
      ЕСЛИ (id # ПУСТО) & (id.iType = IDMOD) ТОГДА
         мДецл.КлючСлед_Получ;
         мДецл.Сущность_Проверить(lxDot);
         мДецл.КлючСлед_Получ;
         мДецл.Сущность_Проверить(lxIDENT);
         мДецл.Коорд_Уст(цСтрока, col);
         уУзел := мСкан.сущ_глоб;
         imp := id.модуль # мДецл.модуль;
         id := мДецл.GetQIdent(id.модуль, уУзел)
      КОНЕЦ;
      мПров.Тест(id # ПУСТО, цСтрока, col, 42);
      выраж_.vparam := ЛОЖЬ;
      выраж_.deref := ЛОЖЬ;
      выраж_.id := id;
      мДецл.КлючСлед_Получ;
      ВЫБОР id.iType ИЗ
         |IDVAR:
            выраж_.eType := eVAR;
            выраж_.уТип := id.уТип;
            ЕСЛИ id.VarKind = 0 ТОГДА
               выраж_.Read := imp
            ИНАЧЕ
               выраж_.Read := (id.VarKind = мДецл.param) & (id.уТип.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типМАССИВ});
               выраж_.vparam := id.VarKind = мДецл.paramvar
            КОНЕЦ;
            bases := мДецл.модуль.цУровень - id.Level;
            ЕСЛИ id.Level = 3 ТОГДА
               glob := id.Offset
            АЕСЛИ (id.VarKind = 0) ИЛИ (id.VarKind = мДецл.param) & ~(id.уТип.тип_ном В {мКонст.типМАССИВ, мКонст.типЗАПИСЬ}) ТОГДА
               loc := id.Offset
            АЕСЛИ (id.VarKind = мДецл.paramvar) ИЛИ (id.уТип.тип_ном В {мКонст.типМАССИВ, мКонст.типЗАПИСЬ}) ТОГДА
               ЕСЛИ мДецл.Dim(выраж_.уТип) > 0 ТОГДА
                  n := мДецл.Dim(выраж_.уТип);
                  ДЛЯ i := n ДО 1 ПО -1 ДЕЛАТЬ
                     X86.LocalAdr(id.Offset + i * 4, bases);
                     X86.Load(мКонст.типЦЕЛОЕ)
                  КОНЕЦ
               КОНЕЦ;
               X86.LocalAdr(id.Offset, bases);
               X86.Load(мКонст.типЦЕЛОЕ)
            КОНЕЦ
         |IDCONST:
            мПров.Тест(id.уТип # ПУСТО, цСтрока, col, 75);
            выраж_.eType := eCONST;
            выраж_.уТип := id.уТип;
            выраж_.Value := id.Value;
            ЕСЛИ id.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типНАБОР, мКонст.типБУЛЕВО} ТОГДА
                X86.PushConst(КЦЕЛ(выраж_.Value))
            АЕСЛИ id.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ} ТОГДА
                X86.PushFlt(выраж_.Value)
            АЕСЛИ id.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
                уСтр := мДецл.уКонстСтр_Получ(выраж_.Value);
                ЕСЛИ уСтр.длина = 1 ТОГДА
                    X86.PushConst(НЛИТ(уСтр.стр[0]))
                ИНАЧЕ
                    X86.PushInt(уСтр.номер)
                КОНЕЦ
            КОНЕЦ
         |IDPROC:
            выраж_.eType := ePROC;
            выраж_.уТип := sttypes[мКонст.TVOID]
         |IDTYPE:
            мПров.Тест(ЛОЖЬ, цСтрока, col, 101)
         |IDSTPROC:
            выраж_.eType := eSTPROC;
            выраж_.уТип := sttypes[мКонст.TVOID]
         |IDSYSPROC:
            выраж_.eType := eSYSPROC;
            выраж_.уТип := sttypes[мКонст.TVOID]
      ИНАЧЕ
      КОНЕЦ;
      бОстанов := ЛОЖЬ;
      бОхрана := ЛОЖЬ;
      ПОВТОРЯТЬ
         ВЫБОР мСкан.цСущность ИЗ
            |lxDot:
               выраж_.deref := ЛОЖЬ;
               мПров.Тест2(выраж_.уТип.тип_ном В {мКонст.типУКАЗАТЕЛЬ, мКонст.типЗАПИСЬ}, 105);
               ЕСЛИ выраж_.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ ТОГДА
                  выраж_.Read := ЛОЖЬ;
                  LoadVar;
                  выраж_.уТип := выраж_.уТип.Base;
                  X86.Load(мКонст.типЦЕЛОЕ);
                  ЕСЛИ ~бОхрана ТОГДА
                     X86.CheckNIL
                  КОНЕЦ
               КОНЕЦ;
               мДецл.КлючСлед_Получ;
               мДецл.Сущность_Проверить(lxIDENT);
               мДецл.Коорд_Уст(цСтрока, col);
               уУзел := мСкан.сущ_глоб;
               уТип := выраж_.уТип;
               ПОВТОРЯТЬ
                  уПоле := мДецл.GetField(уТип, уУзел);
                  уТип := уТип.Base
               ПОКАНЕ (уПоле # ПУСТО) ИЛИ (уТип = ПУСТО);
               мПров.Тест(уПоле # ПУСТО, цСтрока, col, 99);
               ЕСЛИ уПоле.Unit # мДецл.модуль ТОГДА
                  мПров.Тест(уПоле.Export, цСтрока, col, 99)
               КОНЕЦ;
               ЕСЛИ glob # -1 ТОГДА
                  glob := glob + уПоле.Offset
               АЕСЛИ loc # -1 ТОГДА
                  loc := loc + уПоле.Offset
               ИНАЧЕ
                  X86.Field(уПоле.Offset)
               КОНЕЦ;
               выраж_.уТип := уПоле.уТип;
               выраж_.vparam := ЛОЖЬ;
               бОхрана := ЛОЖЬ;
               мДецл.КлючСлед_Получ
            |мКонст.опСкобкаЛевКв:
               LoadVar;
               ПОВТОРЯТЬ
                  мПров.Тест2(выраж_.уТип.тип_ном = мКонст.типМАССИВ, 102);
                  мДецл.КлючСлед_Получ;
                  мДецл.Коорд_Уст(цСтрока, col);
                  пВыраж(выражение);
                  мПров.Тест(выражение.уТип.тип_ном = мКонст.типЦЕЛОЕ, цСтрока, col, 52);
                  Выраж_Загрузить(выражение);
                  ЕСЛИ выраж_.уТип.длина = 0 ТОГДА
                     BaseT := мДецл.OpenBase(выраж_.уТип);
                     X86.PushConst(BaseT.размер);
                     X86.OpenIdx(мДецл.Dim(выраж_.уТип))
                  ИНАЧЕ
                     ЕСЛИ выражение.eType = eCONST ТОГДА
                        idx := КЦЕЛ(выражение.Value);
                        мПров.Тест((idx >= 0) & (idx < выраж_.уТип.длина), цСтрока, col, 159);
                        ЕСЛИ выраж_.уТип.Base.размер # 1 ТОГДА
                           X86.Drop;
                           X86.PushConst(выраж_.уТип.Base.размер * idx)
                        КОНЕЦ;
                        X86.Idx
                     ИНАЧЕ
                        X86.FixIdx(выраж_.уТип.длина, выраж_.уТип.Base.размер)
                     КОНЕЦ
                  КОНЕЦ;
                  выраж_.уТип := выраж_.уТип.Base
               ПОКАНЕ мСкан.цСущность # мКонст.опЗапятая;
               мДецл.Сущность_Проверить(мКонст.опСкобкаПрКв);
               выраж_.vparam := ЛОЖЬ;
               бОхрана := ЛОЖЬ;
               мДецл.КлючСлед_Получ
            |lxCaret:
               LoadVar;
               мПров.Тест2(выраж_.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ, 104);
               выраж_.Read := ЛОЖЬ;
               X86.Load(мКонст.типЦЕЛОЕ);
               ЕСЛИ ~бОхрана ТОГДА
                  X86.CheckNIL
               КОНЕЦ;
               выраж_.уТип := выраж_.уТип.Base;
               выраж_.vparam := ЛОЖЬ;
               выраж_.deref := ИСТИНА;
               бОхрана := ЛОЖЬ;
               мДецл.КлючСлед_Получ
            |lxLRound:
               LoadVar;
               ЕСЛИ выраж_.уТип.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типУКАЗАТЕЛЬ} ТОГДА
                  ЕСЛИ выраж_.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
                     мПров.Тест2(выраж_.vparam, 108)
                  КОНЕЦ;
                  мДецл.КлючСлед_Получ;
                  мДецл.Сущность_Проверить(lxIDENT);
                  мДецл.Коорд_Уст(цСтрока, col);
                  уТип := мДецл.IdType(цСтрока, col);
                  мПров.Тест(уТип # ПУСТО, цСтрока, col, 42);
                  ЕСЛИ выраж_.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
                     мПров.Тест(уТип.тип_ном = мКонст.типЗАПИСЬ, цСтрока, col, 106)
                  ИНАЧЕ
                     мПров.Тест(уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ, цСтрока, col, 107)
                  КОНЕЦ;
                  мПров.Тест(BaseOf(выраж_.уТип, уТип), цСтрока, col, 108);
                  выраж_.уТип := уТип;
                  мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
                  мДецл.КлючСлед_Получ;
                  ЕСЛИ выраж_.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ ТОГДА
                     ЕСЛИ (мСкан.цСущность = lxDot) ИЛИ (мСкан.цСущность = lxCaret) ТОГДА
                        X86.DupLoadCheck
                     ИНАЧЕ
                        X86.DupLoad
                     КОНЕЦ;
                     бОхрана := ИСТИНА;
                     уТип := уТип.Base
                  ИНАЧЕ
                     X86.LocalAdr(выраж_.id.Offset, мДецл.модуль.цУровень - выраж_.id.Level)
                  КОНЕЦ;
                  X86.Guard(уТип.номер, ЛОЖЬ)
               ИНАЧЕ
                  бОстанов := ИСТИНА
               КОНЕЦ
         ИНАЧЕ
            бОстанов := ИСТИНА
         КОНЕЦ
      ПОКАНЕ бОстанов;
      LoadVar
   КОНЕЦ Designator;

ПРОЦЕДУРА Set(ПЕР e: мДецл.тВыражение);
   ПЕРЕМ
      a, b: мДецл.тВыражение;
      line, col: ЦЕЛОЕ;
      s: SET; flag: БУЛЕВО;
   НАЧАЛО
      мДецл.КлючСлед_Получ;
      e.eType := eEXP;
      e.уТип := sttypes[мКонст.типНАБОР];
      e.Value := 0.0D0;
      e.vparam := ЛОЖЬ;
      s := {};
      flag := ИСТИНА;
      X86.PushConst(0);
      ПОКА мСкан.цСущность # lxRCurly ДЕЛАТЬ
         мДецл.Коорд_Уст(line, col);
         пВыраж(a);
         мПров.Тест(a.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
         ЕСЛИ a.eType = eCONST ТОГДА
            мПров.Тест(ЗСП(КЦЕЛ(a.Value), 5) = 0, line, col, 53)
         КОНЕЦ;
         Выраж_Загрузить(a);
         b := a;
         ЕСЛИ мСкан.цСущность = lxDbl ТОГДА
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            пВыраж(b);
            мПров.Тест(b.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            ЕСЛИ b.eType = eCONST ТОГДА
               мПров.Тест(ЗСП(КЦЕЛ(b.Value), 5) = 0, line, col, 53);
               мПров.Тест(a.Value <= b.Value, line, col, 54)
            КОНЕЦ;
            Выраж_Загрузить(b)
         ИНАЧЕ
            X86.Dup
         КОНЕЦ;
         X86.rset;
         X86.Set(мКонст.опПлюс);
         flag := (a.eType = eCONST) & (b.eType = eCONST) & flag;
         ЕСЛИ flag ТОГДА
            s := s + {КЦЕЛ(a.Value) .. КЦЕЛ(b.Value)}
         КОНЕЦ;
         ЕСЛИ мСкан.цСущность = мКонст.опЗапятая ТОГДА
            мДецл.КлючСлед_Получ;
            мПров.Тест2(мСкан.цСущность # lxRCurly, 36)
         ИНАЧЕ
            мДецл.Сущность_Проверить(lxRCurly)
         КОНЕЦ
      КОНЕЦ;
      ЕСЛИ flag ТОГДА
         e.Value := УДЛИН(КВЕЩ(НЛИТ(s)));
         e.eType := eCONST
      КОНЕЦ;
      мДецл.КлючСлед_Получ
   КОНЕЦ Set;

ПРОЦЕДУРА ЕслиСтрока(a: мДецл.тВыражение): БУЛЕВО;
      ВЕРНУТЬ (a.уТип.тип_ном = мКонст.типСТРОКА) ИЛИ (a.уТип.тип_ном = мКонст.типМАССИВ) & (a.уТип.Base.тип_ном = мКонст.типЛИТЕРА)
   КОНЕЦ ЕслиСтрока;

ПРОЦЕДУРА Str(e: мДецл.тВыражение);
   ПЕРЕМ
      A: X86.TIDX;
   НАЧАЛО
      ЕСЛИ (e.уТип.тип_ном = мКонст.типМАССИВ) & (e.уТип.Base.тип_ном = мКонст.типЛИТЕРА) & (e.уТип.длина # 0) ТОГДА
         A[0] := e.уТип.длина;
         X86.OpenArray(A, 1)
      АЕСЛИ e.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
         A[0] := Стр_Длина(e.Value) + 1;
         ЕСЛИ A[0] # 2 ТОГДА
            X86.OpenArray(A, 1)
         КОНЕЦ
      КОНЕЦ
   КОНЕЦ Str;

ПРОЦЕДУРА StFunc(ПЕР e: мДецл.тВыражение; func: ЦЕЛОЕ);
   ПЕРЕМ
      line, col, line2, col2, a, b, p: ЦЕЛОЕ;
      e1, e2: мДецл.тВыражение;
      T: мТип.туТип;
      str, str2: мДецл.туКонстСтр;
   НАЧАЛО
      e.vparam := ЛОЖЬ;
      e.eType := eEXP;
      мДецл.Коорд_Уст(line2, col2);
      мДецл.Сущность_Проверить(lxLRound);
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      ВЫБОР func ИЗ
         |мКонст.процАБС:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, line, col, 57);
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               e.Value := ABS(e1.Value);
               e.eType := eCONST;
               мПров.Тест(~((e1.уТип.тип_ном = мКонст.типЦЕЛОЕ) & (e1.Value = УДЛИН(КВЕЩ(мКонст.целое_мин)))), line, col, мДецл.IOVER)
            КОНЕЦ;
            ЕСЛИ e1.уТип.тип_ном = мКонст.типЦЕЛОЕ ТОГДА
               X86.StFunc(мКонст.процАБС)
            ИНАЧЕ
               X86.StFunc(мКонст.процАБСВ)
            КОНЕЦ;
            e.уТип := e1.уТип
         |мКонст.процЧЁТ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               e.Value := УДЛИН(КВЕЩ(НЛИТ(ЧЁТ(КЦЕЛ(e1.Value)))));
               e.eType := eCONST
            КОНЕЦ;
            X86.StFunc(мКонст.процЧЁТ);
            e.уТип := sttypes[мКонст.типБУЛЕВО]
         |мКонст.процДЛИН:
            Designator(e1);
            мПров.Тест((e1.eType = eVAR) & (e1.уТип.тип_ном = мКонст.типМАССИВ), line, col, 102);
            ЕСЛИ e1.уТип.длина > 0 ТОГДА
               X86.Len(-e1.уТип.длина)
            ИНАЧЕ
               X86.Len(мДецл.Dim(e1.уТип))
            КОНЕЦ;
            e.уТип := sttypes[мКонст.типЦЕЛОЕ]
         |мКонст.процЛСЛ, мКонст.процЗСП, мКонст.процЦСП, мКонст.процЛСП:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            пВыраж(e2);
            мПров.Тест(e2.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e2);
            ЕСЛИ (e1.eType = eCONST) & (e2.eType = eCONST) ТОГДА
               a := КЦЕЛ(e1.Value);
               b := КЦЕЛ(e2.Value);
               ВЫБОР func ИЗ
                  |мКонст.процЛСЛ: a := ЛСЛ(a, b)
                  |мКонст.процЗСП: a := ЗСП(a, b)
                  |мКонст.процЦСП: a := ЦСП(a, b)
                  |мКонст.процЛСП: a := ЛСП(a, b)
               ИНАЧЕ
               КОНЕЦ;
               e.Value := УДЛИН(КВЕЩ(a));
               e.eType := eCONST
            КОНЕЦ;
            ВЫБОР func ИЗ
               |мКонст.процЛСЛ: X86.StFunc(мКонст.процЛСЛ)
               |мКонст.процЗСП: X86.StFunc(мКонст.процЗСП)
               |мКонст.процЦСП: X86.StFunc(мКонст.процЦСП)
               |мКонст.процЛСП: X86.StFunc(мКонст.процЛСП)
            ИНАЧЕ
            КОНЕЦ;
            e.уТип := sttypes[мКонст.типЦЕЛОЕ]
         |мКонст.процКЦЕЛ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, line, col, 66);
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               мПров.Тест((e1.Value - 1.0D0 < УДЛИН(КВЕЩ(мКонст.целое_макс))) & (e1.Value >= УДЛИН(КВЕЩ(мКонст.целое_мин))), line, col, 74);
               e.Value := УДЛИН(КВЕЩ(КЦЕЛ(e1.Value)));
               e.eType := eCONST
            КОНЕЦ;
            X86.StFunc(мКонст.процКЦЕЛ);
            e.уТип := sttypes[мКонст.типЦЕЛОЕ]
         |мКонст.процКВЕЩ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               e.Value := e1.Value;
               e.eType := eCONST
            КОНЕЦ;
            X86.StFunc(мКонст.процКВЕЩ);
            e.уТип := sttypes[мКонст.типВЕЩ]
         |мКонст.процНЛИТ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном В {мКонст.типЛИТЕРА, мКонст.типБУЛЕВО, мКонст.типНАБОР, мКонст.типСТРОКА}, line, col, 68);
            ЕСЛИ e1.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
               мПров.Тест(Стр_Длина(e1.Value) = 1, line, col, 94)
            КОНЕЦ;
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               ЕСЛИ e1.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
                  str := мДецл.уКонстСтр_Получ(e1.Value);
                  e.Value := УДЛИН(КВЕЩ(НЛИТ(str.стр[0])))
               ИНАЧЕ
                  e.Value := e1.Value
               КОНЕЦ;
               e.eType := eCONST
            КОНЕЦ;
            ЕСЛИ e1.уТип.тип_ном = мКонст.типБУЛЕВО ТОГДА
               X86.StFunc(мКонст.процНЛИТ)
            КОНЕЦ;
            e.уТип := sttypes[мКонст.типЦЕЛОЕ]
         |мКонст.процБИТ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            ЕСЛИ e1.eType = eCONST ТОГДА
               e.Value := e1.Value;
               e.eType := eCONST
            КОНЕЦ;
            e.уТип := sttypes[мКонст.типНАБОР]
         |мКонст.процВЛИТ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            e.уТип := sttypes[мКонст.типЛИТЕРА];
            ЕСЛИ e1.eType = eCONST ТОГДА
               мПров.Тест(ЗСП(КЦЕЛ(e1.Value), 8) = 0, line, col, 76);
               str2 := мДецл.СтрМоно_Создать(ВЛИТ(КЦЕЛ(e1.Value)));
               mSys.GET(mSys.ADR(str2), p);
               e.Value := УДЛИН(КВЕЩ(p));
               e.уТип := sttypes[мКонст.типСТРОКА];
               e.eType := eCONST
            КОНЕЦ
         |мКонст.процУДЛИН:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типВЕЩ, line, col, 71);
            ЕСЛИ e1.eType = eCONST ТОГДА
               e.Value := e1.Value;
               e.eType := eCONST
            КОНЕЦ;
            Выраж_Загрузить(e1);
            e.уТип := sttypes[мКонст.типДЛИНВЕЩ]
         |мКонст.процУКОРОТ:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типДЛИНВЕЩ, line, col, 70);
            ЕСЛИ e1.eType = eCONST ТОГДА
               мПров.Тест(ABS(e1.Value) <= УДЛИН(мКонст.вещ_макс), line, col, мДецл.FOVER);
               мПров.Тест(ABS(e1.Value) >= УДЛИН(мКонст.вещ_мин), line, col, мДецл.UNDER);
               e.Value := e1.Value;
               e.eType := eCONST
            КОНЕЦ;
            Выраж_Загрузить(e1);
            e.уТип := sttypes[мКонст.типВЕЩ]
         |мКонст.процДЛИНСТР:
            пВыраж(e1);
            мПров.Тест(ЕслиСтрока(e1), line, col, 141);
            ЕСЛИ e1.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
               str := мДецл.уКонстСтр_Получ(e1.Value);
               ЕСЛИ str.длина = 1 ТОГДА
                  X86.Mono(str.номер);
                  X86.StrMono
               КОНЕЦ;
               e.Value := УДЛИН(КВЕЩ(ДЛИНСТР(str.стр)));
               e.eType := eCONST
            КОНЕЦ;
            Str(e1);
            e.уТип := sttypes[мКонст.типЦЕЛОЕ];
            X86.StFunc(мКонст.процДЛИНСТР)
         |мКонст.sysADR:
            мПров.Тест((мСкан.цСущность = lxIDENT) ИЛИ (мСкан.цСущность = lxSTRING) ИЛИ (мСкан.цСущность = lxCHX), line, col, 43);
            ЕСЛИ мСкан.цСущность = lxIDENT ТОГДА
               Designator(e1);
               мПров.Тест((e1.eType = eVAR) ИЛИ (e1.eType = ePROC) ИЛИ (e1.уТип = sttypes[мКонст.типСТРОКА]), line, col, 43);
               ЕСЛИ e1.eType = ePROC ТОГДА
                  X86.PushInt(e1.id.Number)
               КОНЕЦ
            ИНАЧЕ
               pFactor(e1)
            КОНЕЦ;
            ЕСЛИ e1.уТип = sttypes[мКонст.типСТРОКА] ТОГДА
               str := мДецл.уКонстСтр_Получ(e1.Value);
               ЕСЛИ str.длина = 1 ТОГДА
                  X86.Drop;
                  X86.PushInt(str.номер)
               КОНЕЦ
            КОНЕЦ;
            e.уТип := sttypes[мКонст.типЦЕЛОЕ];
            X86.ADR(мДецл.Dim(e1.уТип))
         |мКонст.sysBIT:
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            пВыраж(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            X86.StFunc(мКонст.sysBIT);
            e.уТип := sttypes[мКонст.типБУЛЕВО]
         |мКонст.sysSIZE, мКонст.sysTYPEID:
            мДецл.ПроцедурРазм_Уст;
            мДецл.Сущность_Проверить(lxIDENT);
            T := мДецл.IdType(line, col);
            мПров.Тест(T # ПУСТО, line, col, 42);
            e.eType := eCONST;
            e.уТип := sttypes[мКонст.типЦЕЛОЕ];
            ЕСЛИ func = мКонст.sysTYPEID ТОГДА
               мПров.Тест(T.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типУКАЗАТЕЛЬ}, line, col, 47);
               ЕСЛИ T.тип_ном = мКонст.типУКАЗАТЕЛЬ ТОГДА
                  T := T.Base
               КОНЕЦ;
               e.Value := УДЛИН(КВЕЩ(T.номер));
               X86.PushConst(T.номер)
            ИНАЧЕ
               e.Value := УДЛИН(КВЕЩ(T.размер));
               X86.PushConst(T.размер)
            КОНЕЦ
      ИНАЧЕ
         мПров.Тест(ЛОЖЬ, line2, col2, 73)
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
      мДецл.КлючСлед_Получ
   КОНЕЦ StFunc;

ПРОЦЕДУРА ProcTypeComp(T1, T2: мТип.туТип): БУЛЕВО;
   ПЕРЕМ
      sp: ЦЕЛОЕ;
      stk: МАССИВ 100, 2 ИЗ мТип.туТип;

   ПРОЦЕДУРА ProcTypeComp1(T1, T2: мТип.туТип): БУЛЕВО;
      ПЕРЕМ
         fp, ft: мДецл.туПоле;
         Res: БУЛЕВО;

      ПРОЦЕДУРА TypeComp(T1, T2: мТип.туТип): БУЛЕВО;
         ПЕРЕМ
            Res: БУЛЕВО;
         НАЧАЛО
            ЕСЛИ (T1.тип_ном = мКонст.типМАССИВ) & (T2.тип_ном = мКонст.типМАССИВ) & (T1.длина = 0) & (T2.длина = 0) ТОГДА
               Res := TypeComp(T1.Base, T2.Base)
            ИНАЧЕ
              Res := ProcTypeComp1(T1, T2)
            КОНЕЦ
            ВЕРНУТЬ Res
         КОНЕЦ TypeComp;

      ПРОЦЕДУРА Check(): БУЛЕВО;
         ПЕРЕМ
            i: ЦЕЛОЕ;
            res: БУЛЕВО;
         НАЧАЛО
            i := 0;
            res := ЛОЖЬ;
            ПОКА (i < sp) & ~res ДЕЛАТЬ
               res := ((stk[i][0] = T1) & (stk[i][1] = T2)) ИЛИ ((stk[i][0] = T2) & (stk[i][1] = T1));
               ДОБ(i)
            КОНЕЦ
            ВЕРНУТЬ res
         КОНЕЦ Check;

        НАЧАЛО
          ДОБ(sp);
          stk[sp][0] := T1;
          stk[sp][1] := T2;
          ЕСЛИ Check() ТОГДА
            Res := ИСТИНА
          ИНАЧЕ
            ЕСЛИ (T1.тип_ном = мКонст.типПРОЦЕДУРА) & (T2.тип_ном = мКонст.типПРОЦЕДУРА) & (T1 # T2) ТОГДА
              Res := (T1.вызов = T2.вызов) & (T1.поля.счётчик = T2.поля.счётчик) & ProcTypeComp1(T1.Base, T2.Base);
              fp := T1.поля.предыдущ(мДецл.туПоле);
              ft := T2.поля.предыдущ(мДецл.туПоле);
              ПОКА Res & (fp # ПУСТО) ДЕЛАТЬ
                Res := (fp.ByRef = ft.ByRef) & TypeComp(fp.уТип, ft.уТип);
                fp := fp.следующ(мДецл.туПоле);
                ft := ft.следующ(мДецл.туПоле)
              КОНЕЦ
            ИНАЧЕ
              Res := T1 = T2
            КОНЕЦ
          КОНЕЦ;
          ВЫЧ(sp)
          ВЕРНУТЬ Res
        КОНЕЦ ProcTypeComp1;

   НАЧАЛО
      sp := -1
      ВЕРНУТЬ ProcTypeComp1(T1, T2)
   КОНЕЦ ProcTypeComp;

ПРОЦЕДУРА ArrComp(Ta, Tf: мТип.туТип): БУЛЕВО;
   ПЕРЕМ
      Res: БУЛЕВО;
   НАЧАЛО
      ЕСЛИ (Tf.тип_ном = мКонст.типМАССИВ) & (Tf.длина = 0) & (Ta.тип_ном = мКонст.типМАССИВ) ТОГДА
        Res := ArrComp(Ta.Base, Tf.Base)
      ИНАЧЕ
        Res := ProcTypeComp(Ta, Tf)
      КОНЕЦ
      ВЕРНУТЬ Res
   КОНЕЦ ArrComp;

ПРОЦЕДУРА AssComp(e: мДецл.тВыражение; T: мТип.туТип; param: БУЛЕВО): БУЛЕВО;
   ПЕРЕМ
      Res: БУЛЕВО;
   НАЧАЛО
      ВЫБОР T.тип_ном ИЗ
         |мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типНАБОР, мКонст.типБУЛЕВО, мКонст.TCARD16:
            Res := e.уТип = T
         |мКонст.типЛИТЕРА:
            ЕСЛИ e.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
               Res := Стр_Длина(e.Value) = 1
            ИНАЧЕ
               Res := e.уТип.тип_ном = мКонст.типЛИТЕРА
            КОНЕЦ
         |мКонст.типМАССИВ:
            ЕСЛИ param ТОГДА
               ЕСЛИ T.длина = 0 ТОГДА
                  ЕСЛИ (T.Base.тип_ном = мКонст.типЛИТЕРА) & (e.уТип.тип_ном = мКонст.типСТРОКА) ТОГДА
                     Res := ИСТИНА
                  ИНАЧЕ
                     Res := ArrComp(e.уТип, T)
                  КОНЕЦ
               ИНАЧЕ
                  ЕСЛИ (T.Base.тип_ном = мКонст.типЛИТЕРА) & (e.уТип.тип_ном = мКонст.типСТРОКА) ТОГДА
                     Res := Стр_Длина(e.Value) <= T.длина
                  ИНАЧЕ
                     Res := e.уТип = T
                  КОНЕЦ
               КОНЕЦ
               ИНАЧЕ
               ЕСЛИ T.длина = 0 ТОГДА
                  Res := ЛОЖЬ
               АЕСЛИ (T.Base.тип_ном = мКонст.типЛИТЕРА) & (e.уТип.тип_ном = мКонст.типСТРОКА) ТОГДА
                  Res := Стр_Длина(e.Value) <= T.длина
               ИНАЧЕ
                  Res := e.уТип = T
               КОНЕЦ
            КОНЕЦ
         |мКонст.типЗАПИСЬ: Res := BaseOf(T, e.уТип)
         |мКонст.типУКАЗАТЕЛЬ: Res := BaseOf(T, e.уТип) ИЛИ (e.уТип.тип_ном = мКонст.типПУСТО)
         |мКонст.типПРОЦЕДУРА: Res := (e.уТип.тип_ном = мКонст.типПУСТО) ИЛИ (e.eType = ePROC) & ProcTypeComp(e.id.уТип, T) ИЛИ
            (e.eType # ePROC) & ProcTypeComp(e.уТип, T)
      ИНАЧЕ
         Res := ЛОЖЬ
      КОНЕЦ
      ВЕРНУТЬ Res
   КОНЕЦ AssComp;

ПРОЦЕДУРА ParamComp(e: мДецл.тВыражение; T: мТип.туТип; ByRef: БУЛЕВО): БУЛЕВО;
   ПЕРЕМ
      Res: БУЛЕВО;
   НАЧАЛО
      ЕСЛИ ByRef ТОГДА
         ЕСЛИ e.eType = eVAR ТОГДА
            ВЫБОР T.тип_ном ИЗ
               |мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типЛИТЕРА,
                  мКонст.типНАБОР, мКонст.типБУЛЕВО, мКонст.типУКАЗАТЕЛЬ, мКонст.TCARD16:
                  Res := e.уТип = T
               |мКонст.типМАССИВ:
                  ЕСЛИ T.длина > 0 ТОГДА
                      Res := e.уТип = T
                  ИНАЧЕ
                      Res := ArrComp(e.уТип, T)
                  КОНЕЦ
               |мКонст.типЗАПИСЬ:
                  Res := BaseOf(T, e.уТип)
               |мКонст.типПРОЦЕДУРА:
                  Res := ProcTypeComp(e.уТип, T)
            ИНАЧЕ
            КОНЕЦ
         ИНАЧЕ
            Res := ЛОЖЬ
         КОНЕЦ
      ИНАЧЕ
         Res := AssComp(e, T, ИСТИНА)
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ ParamComp;

ПРОЦЕДУРА Call(param: мДецл.туПоле);
   ПЕРЕМ
      line, col, i, n: ЦЕЛОЕ;
      e1: мДецл.тВыражение;
      s: мДецл.туКонстСтр;
      A: X86.TIDX;
      TA: мТип.туТип;
   НАЧАЛО
      ПОКА param # ПУСТО ДЕЛАТЬ
         мДецл.Коорд_Уст(line, col);
         X86.Param;
         пВыраж(e1);
         мПров.Тест(ParamComp(e1, param.уТип, param.ByRef), line, col, 114);
         мПров.Тест(~(param.ByRef & e1.Read), line, col, 115);
         мПров.Тест(~((e1.eType = ePROC) & (e1.id.Level > 3)), line, col, 116);
         ЕСЛИ (e1.eType = eVAR) & ~param.ByRef ТОГДА
            X86.Load(e1.уТип.тип_ном)
         КОНЕЦ;
         ЕСЛИ param.ByRef & (e1.уТип.тип_ном = мКонст.типЗАПИСЬ) ТОГДА
            ЕСЛИ e1.vparam ТОГДА
               X86.LocalAdr(e1.id.Offset - 4, мДецл.модуль.цУровень - e1.id.Level);
               X86.Load(мКонст.типЦЕЛОЕ)
            АЕСЛИ e1.deref ТОГДА
               X86.DerefType(0)
            ИНАЧЕ
               X86.PushConst(e1.уТип.номер)
            КОНЕЦ
         КОНЕЦ;
         ЕСЛИ ~param.ByRef & (param.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}) ТОГДА
            X86.DropFpu(param.уТип.тип_ном = мКонст.типДЛИНВЕЩ)
         КОНЕЦ;
         ЕСЛИ (e1.уТип.тип_ном = мКонст.типСТРОКА) & (param.уТип.тип_ном = мКонст.типМАССИВ) ТОГДА
            s := мДецл.уКонстСтр_Получ(e1.Value);
            ЕСЛИ s.длина = 1 ТОГДА
               X86.Mono(s.номер)
            КОНЕЦ;
            ЕСЛИ param.уТип.длина = 0 ТОГДА
               A[0] := s.длина + 1;
               X86.OpenArray(A, 1)
            КОНЕЦ
         КОНЕЦ;
         ЕСЛИ (e1.уТип.тип_ном = мКонст.типМАССИВ) & (мДецл.Dim(param.уТип) > мДецл.Dim(e1.уТип)) ТОГДА
            n := мДецл.Dim(param.уТип) - мДецл.Dim(e1.уТип);
            TA := мДецл.OpenBase(e1.уТип);
            ДЛЯ i := 0 ДО n - 1 ДЕЛАТЬ
               A[i] := TA.длина;
               TA := TA.Base
            КОНЕЦ;
            ЕСЛИ мДецл.Dim(e1.уТип) = 0 ТОГДА
               X86.OpenArray(A, n)
            ИНАЧЕ
               X86.ExtArray(A, n, мДецл.Dim(e1.уТип))
            КОНЕЦ
         КОНЕЦ;
         param := param.следующ(мДецл.туПоле);
         ЕСЛИ param # ПУСТО ТОГДА
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ
         КОНЕЦ
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
      мДецл.КлючСлед_Получ
   КОНЕЦ Call;

ПРОЦЕДУРА Factor(ПЕР e: мДецл.тВыражение);
   ПЕРЕМ
      line, col, ccall, p: ЦЕЛОЕ;
      begcall: X86.туЗвеноАсм;
      s, str2: мДецл.туКонстСтр;
   НАЧАЛО
      e.eType := eCONST;
      e.vparam := ЛОЖЬ;
      ВЫБОР мСкан.цСущность ИЗ
      |lxIDENT:
         begcall := X86.current;
         Designator(e);
         ЕСЛИ e.eType = ePROC ТОГДА
            ЕСЛИ мСкан.цСущность = lxLRound ТОГДА
               мПров.Тест2(e.id.уТип.Base.тип_ном # мКонст.TVOID, 73);
               мДецл.КлючСлед_Получ;
               X86.PushCall(begcall);
               Call(e.id.уТип.поля.предыдущ(мДецл.туПоле));
               X86.Вызов_Закончить;
               e.eType := eEXP;
               e.уТип := e.id.уТип.Base;
               ЕСЛИ e.id.Level = 3 ТОГДА
                  ccall := 0
               АЕСЛИ e.id.Level > мДецл.curBlock.Level ТОГДА
                  ccall := 1
               ИНАЧЕ
                  ccall := 2
               КОНЕЦ;
               X86.Call(e.id.Number, ИСТИНА, e.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, e.id.уТип.вызов, ccall, e.id.Level - 3,
               мДецл.curBlock.Level - 3, e.id.ParamSize, мДецл.curBlock.LocalSize)
            ИНАЧЕ
               X86.PushInt(e.id.Number)
            КОНЕЦ
         АЕСЛИ (e.eType = eVAR) & (e.уТип.тип_ном = мКонст.типПРОЦЕДУРА) & (мСкан.цСущность = lxLRound) ТОГДА
            мПров.Тест2(e.уТип.Base.тип_ном # мКонст.TVOID, 73);
            мДецл.КлючСлед_Получ;
            X86.PushCall(begcall);
            Call(e.уТип.поля.предыдущ(мДецл.туПоле));
            X86.Вызов_Закончить;
            e.eType := eEXP;
            X86.CallVar(ИСТИНА, e.уТип.Base.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, e.уТип.вызов, e.уТип.длина, мДецл.curBlock.LocalSize);
            e.уТип := e.уТип.Base;
         АЕСЛИ e.eType В {eSTPROC, eSYSPROC} ТОГДА
            StFunc(e, e.id.StProc)
         КОНЕЦ
      |мКонст.ксПУСТО:
         e.уТип := sttypes[мКонст.типПУСТО];
         e.Value := 0.0D0;
         X86.PushConst(0);
         мДецл.КлючСлед_Получ
      |мКонст.ксИСТИНА:
         e.уТип := sttypes[мКонст.типБУЛЕВО];
         e.Value := 1.0D0;
         X86.PushConst(1);
         мДецл.КлючСлед_Получ
      |мКонст.ксЛОЖЬ:
         e.уТип := sttypes[мКонст.типБУЛЕВО];
         e.Value := 0.0D0;
         X86.PushConst(0);
         мДецл.КлючСлед_Получ
      |lxCHX, lxSTRING:
         ЕСЛИ мСкан.цСущность = lxSTRING ТОГДА
            мСкан.GetLexStr(стрСущн);
            str2 := мДецл.Стр_Создать(стрСущн);
            mSys.GET(mSys.ADR(str2), p);
            e.Value := УДЛИН(КВЕЩ(p));
            s := мДецл.уКонстСтр_Получ(e.Value);
            ЕСЛИ s.длина = 1 ТОГДА
               X86.PushConst(НЛИТ(s.стр[0]))
            ИНАЧЕ
               X86.PushInt(s.номер)
            КОНЕЦ
         ИНАЧЕ
            str2 := мДецл.СтрМоно_Создать(мСкан.vCHX);
            mSys.GET(mSys.ADR(str2), p);
            e.Value := УДЛИН(КВЕЩ(p));
            X86.PushConst(НЛИТ(мСкан.vCHX))
         КОНЕЦ;
         e.уТип := sttypes[мКонст.типСТРОКА];
         мДецл.КлючСлед_Получ
      |lxREAL:
         e.уТип := sttypes[мКонст.типВЕЩ];
         e.Value := мСкан.vFLT;
         X86.PushFlt(мСкан.vFLT);
         мДецл.КлючСлед_Получ
      |lxLONGREAL:
         e.уТип := sttypes[мКонст.типДЛИНВЕЩ];
         e.Value := мСкан.vFLT;
         X86.PushFlt(мСкан.vFLT);
         мДецл.КлючСлед_Получ
      |lxINT, lxHEX:
         e.уТип := sttypes[мКонст.типЦЕЛОЕ];
         e.Value := УДЛИН(КВЕЩ(мСкан.vINT));
         X86.PushConst(мСкан.vINT);
         мДецл.КлючСлед_Получ
      |lxLRound:
         мДецл.КлючСлед_Получ;
         пВыраж(e);
         мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
         мДецл.КлючСлед_Получ
      |мКонст.опОтриц:
         мДецл.КлючСлед_Получ;
         мДецл.Коорд_Уст(line, col);
         Factor(e);
         мПров.Тест(e.уТип.тип_ном = мКонст.типБУЛЕВО, line, col, 37);
         Выраж_Загрузить(e);
         ЕСЛИ e.eType = eCONST ТОГДА
            e.Value := УДЛИН(КВЕЩ(НЛИТ(e.Value = 0.0D0)))
         ИНАЧЕ
            e.eType := eEXP
         КОНЕЦ;
         X86.Not;
         e.vparam := ЛОЖЬ
      |мКонст.опСкобкаЛевФиг:
         Set(e)
      ИНАЧЕ
         мПров.Тест2(ЛОЖЬ, 36)
      КОНЕЦ
   КОНЕЦ Factor;

ПРОЦЕДУРА IsChr(a: мДецл.тВыражение): БУЛЕВО;
      ВЕРНУТЬ (a.уТип.тип_ном = мКонст.типСТРОКА) & (Стр_Длина(a.Value) = 1) ИЛИ (a.уТип.тип_ном = мКонст.типЛИТЕРА)
   КОНЕЦ IsChr;

ПРОЦЕДУРА StrRel(a, b: мДецл.тВыражение; Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ ~(IsChr(a) ИЛИ IsChr(b)) ТОГДА
         X86.strcmp(Op, 0)
      АЕСЛИ IsChr(a) & IsChr(b) ТОГДА
         X86.CmpInt(Op)
      АЕСЛИ IsChr(a) ТОГДА
         X86.strcmp(Op, 1)
      ИНАЧЕ
         X86.strcmp(Op, -1)
      КОНЕЦ
   КОНЕЦ StrRel;

ПРОЦЕДУРА log2(n: ЦЕЛОЕ): ЦЕЛОЕ;
   ПЕРЕМ
      x, i: ЦЕЛОЕ;
   НАЧАЛО
      x := 1;
      i := 0;
      ПОКА (x # n) & (i < 31) ДЕЛАТЬ
         x := ЛСЛ(x, 1);
         ДОБ(i)
      КОНЕЦ;
      ЕСЛИ x # n ТОГДА
         i := -1
      КОНЕЦ
      ВЕРНУТЬ i
   КОНЕЦ log2;

ПРОЦЕДУРА Operation(ПЕР a, b: мДецл.тВыражение; Op, line, col: ЦЕЛОЕ);
   ПЕРЕМ
      n, m: ЦЕЛОЕ;
   НАЧАЛО
      ВЫБОР Op ИЗ
      |мКонст.опПлюс, мКонст.опМинус, мКонст.опУмнож, мКонст.опДелен:
         мПров.Тест((a.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типНАБОР}) & (a.уТип.тип_ном = b.уТип.тип_ном), line, col, 37);
         мПров.Тест(~((Op = мКонст.опДелен) & (a.уТип.тип_ном = мКонст.типЦЕЛОЕ)), line, col, 37);
         ВЫБОР a.уТип.тип_ном ИЗ
            |мКонст.типЦЕЛОЕ: X86.Int(Op)
            |мКонст.типНАБОР: X86.Set(Op)
            |мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ: X86.farith(Op)
         ИНАЧЕ
         КОНЕЦ
      |мКонст.ксДЕЛ, мКонст.ксОСТ:
         мПров.Тест((a.уТип.тип_ном = мКонст.типЦЕЛОЕ) & (b.уТип.тип_ном = мКонст.типЦЕЛОЕ), line, col, 37);
         ЕСЛИ b.eType = eCONST ТОГДА
         m := КЦЕЛ(b.Value);
         мПров.Тест(m # 0, line, col, 48);
         n := log2(m);
         ЕСЛИ n = -1 ТОГДА
            X86.idivmod(Op = мКонст.ксОСТ)
         ИНАЧЕ
            X86.Drop;
            ЕСЛИ Op = мКонст.ксОСТ ТОГДА
               n := НЛИТ(-БИТ(ЛСЛ(-1, n)));
               X86.PushConst(n);
               X86.Set(мКонст.опУмнож)
            ИНАЧЕ
               X86.PushConst(n);
               X86.StFunc(мКонст.процЗСП)
            КОНЕЦ
         КОНЕЦ
      ИНАЧЕ
         X86.idivmod(Op = мКонст.ксОСТ)
      КОНЕЦ
      |мКонст.опИ, мКонст.ксИЛИ:
         мПров.Тест((a.уТип.тип_ном = мКонст.типБУЛЕВО) & (b.уТип.тип_ном = мКонст.типБУЛЕВО), line, col, 37)
      |мКонст.ксВ:
          мПров.Тест((a.уТип.тип_ном = мКонст.типЦЕЛОЕ) & (b.уТип.тип_ном = мКонст.типНАБОР), line, col, 37);
          X86.inset
      |мКонст.опМеньше, lxLE, мКонст.опБольше, lxGE:
         мПров.Тест(((a.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}) & (a.уТип.тип_ном = b.уТип.тип_ном)) ИЛИ
         (IsChr(a) ИЛИ ЕслиСтрока(a)) & (IsChr(b) ИЛИ ЕслиСтрока(b)) ИЛИ
         (a.уТип.тип_ном = мКонст.типНАБОР) & (b.уТип.тип_ном = мКонст.типНАБОР) & ((Op = lxLE) ИЛИ (Op = lxGE)), line, col, 37);
         ЕСЛИ a.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ} ТОГДА
            X86.fcmp(Op)
         АЕСЛИ a.уТип.тип_ном = мКонст.типНАБОР ТОГДА
            X86.Inclusion(Op)
         АЕСЛИ ЕслиСтрока(a) ИЛИ ЕслиСтрока(b) ТОГДА
            StrRel(a, b, Op)
         ИНАЧЕ
            X86.CmpInt(Op)
         КОНЕЦ
      |мКонст.опРавно, мКонст.опНеРавно:
         мПров.Тест(((a.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типНАБОР, мКонст.типБУЛЕВО}) & (a.уТип.тип_ном = b.уТип.тип_ном)) ИЛИ
         (IsChr(a) ИЛИ ЕслиСтрока(a)) & (IsChr(b) ИЛИ ЕслиСтрока(b)) ИЛИ
         (a.уТип.тип_ном В {мКонст.типУКАЗАТЕЛЬ, мКонст.типПРОЦЕДУРА, мКонст.типПУСТО}) & (b.уТип.тип_ном = мКонст.типПУСТО) ИЛИ
         (b.уТип.тип_ном В {мКонст.типУКАЗАТЕЛЬ, мКонст.типПРОЦЕДУРА, мКонст.типПУСТО}) & (a.уТип.тип_ном = мКонст.типПУСТО) ИЛИ
         (a.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ) & (b.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ) & (BaseOf(a.уТип, b.уТип) ИЛИ BaseOf(b.уТип, a.уТип)) ИЛИ
         (a.уТип.тип_ном = мКонст.типПРОЦЕДУРА) & ProcTypeComp(b.уТип, a.уТип) ИЛИ (a.eType = ePROC) & ProcTypeComp(b.уТип, a.id.уТип) ИЛИ
         (b.eType = ePROC) & ProcTypeComp(a.уТип, b.id.уТип), line, col, 37);
         ЕСЛИ a.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ} ТОГДА
            X86.fcmp(Op)
         АЕСЛИ ЕслиСтрока(a) ИЛИ ЕслиСтрока(b) ТОГДА
            StrRel(a, b, Op)
         ИНАЧЕ
            X86.CmpInt(Op)
         КОНЕЦ
      ИНАЧЕ
      КОНЕЦ;
      ЕСЛИ (a.eType # eCONST) ИЛИ (b.eType # eCONST) ТОГДА
         a.eType := eEXP;
         ЕСЛИ мДецл.Relation(Op) ТОГДА
            a.уТип := sttypes[мКонст.типБУЛЕВО]
         КОНЕЦ
      ИНАЧЕ
         мДецл.Calc(a.Value, b.Value, a.уТип, b.уТип, Op, line, col, a.Value, a.уТип)
      КОНЕЦ;
      a.vparam := ЛОЖЬ
   КОНЕЦ Operation;

ПРОЦЕДУРА Term(ПЕР e: мДецл.тВыражение);
   ПЕРЕМ
      a: мДецл.тВыражение;
      Op, line, col, L: ЦЕЛОЕ;
   НАЧАЛО
      Factor(e);
      ПОКА (мСкан.цСущность = мКонст.опУмнож) ИЛИ (мСкан.цСущность = мКонст.опДелен) ИЛИ
               (мСкан.цСущность = мКонст.ксДЕЛ) ИЛИ (мСкан.цСущность = мКонст.ксОСТ) ИЛИ
               (мСкан.цСущность = мКонст.опИ) ДЕЛАТЬ
         Выраж_Загрузить(e);
         мДецл.Коорд_Уст(line, col);
         Op := мСкан.цСущность;
         мДецл.КлючСлед_Получ;
         ЕСЛИ Op = мКонст.опИ ТОГДА
            L := X86.NewLabel();
            X86.IfWhile(L, ЛОЖЬ)
         КОНЕЦ;
         Factor(a);
         Выраж_Загрузить(a);
         ЕСЛИ Op = мКонст.опИ ТОГДА
            X86.Label(L)
         КОНЕЦ;
         Operation(e, a, Op, line, col)
      КОНЕЦ
   КОНЕЦ Term;

ПРОЦЕДУРА Simple(ПЕР e: мДецл.тВыражение);
   ПЕРЕМ
      a: мДецл.тВыражение;
      Op, line, col, uOp, uline, ucol, L: ЦЕЛОЕ;
   НАЧАЛО
      uOp := 0;
      ЕСЛИ (мСкан.цСущность = мКонст.опПлюс) ИЛИ (мСкан.цСущность = мКонст.опМинус) ТОГДА
         мДецл.Коорд_Уст(uline, ucol);
         uOp := мСкан.цСущность;
         мДецл.КлючСлед_Получ
      КОНЕЦ;
      Term(e);
      ЕСЛИ uOp # 0 ТОГДА
         мПров.Тест(e.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типНАБОР}, uline, ucol, 37);
         Выраж_Загрузить(e);
         ЕСЛИ uOp = мКонст.опМинус ТОГДА
            ВЫБОР e.уТип.тип_ном ИЗ
               |мКонст.типЦЕЛОЕ: X86.NegInt
               |мКонст.типНАБОР: X86.NegSet
               |мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ: X86.fneg
            ИНАЧЕ
            КОНЕЦ
         КОНЕЦ;
         ЕСЛИ (uOp = мКонст.опМинус) & (e.eType = eCONST) ТОГДА
            ВЫБОР e.уТип.тип_ном ИЗ
               |мКонст.типЦЕЛОЕ:
                  мПров.Тест(e.Value # УДЛИН(КВЕЩ(мКонст.целое_мин)), uline, ucol, мДецл.IOVER)
               |мКонст.типНАБОР:
                  e.Value := -УДЛИН(КВЕЩ(НЛИТ(-БИТ(КЦЕЛ(e.Value)))))
            ИНАЧЕ
            КОНЕЦ;
            e.Value := -e.Value
         КОНЕЦ;
         ЕСЛИ e.eType # eCONST ТОГДА
            e.eType := eEXP
         КОНЕЦ;
         e.vparam := ЛОЖЬ
      КОНЕЦ;
      ПОКА (мСкан.цСущность = мКонст.опПлюс) ИЛИ (мСкан.цСущность = мКонст.опМинус) ИЛИ (мСкан.цСущность = мКонст.ксИЛИ) ДЕЛАТЬ
         Выраж_Загрузить(e);
         мДецл.Коорд_Уст(line, col);
         Op := мСкан.цСущность;
         мДецл.КлючСлед_Получ;
         ЕСЛИ Op = мКонст.ксИЛИ ТОГДА
            L := X86.NewLabel();
            X86.IfWhile(L, ИСТИНА)
         КОНЕЦ;
         Term(a);
         Выраж_Загрузить(a);
         ЕСЛИ Op = мКонст.ксИЛИ ТОГДА
            X86.Label(L)
         КОНЕЦ;
         Operation(e, a, Op, line, col)
      КОНЕЦ
   КОНЕЦ Simple;

ПРОЦЕДУРА Expr(ПЕР e: мДецл.тВыражение);
   ПЕРЕМ
      a: мДецл.тВыражение;
      Op, line, col, line2, col2, fpu: ЦЕЛОЕ;
      T: мТип.туТип;
      beg: X86.туЗвеноАсм;
      s: мДецл.туКонстСтр;
   НАЧАЛО
      fpu := X86.fpu;
      beg := X86.current;
      Simple(e);
      ЕСЛИ мДецл.Relation(мСкан.цСущность) ТОГДА
         мДецл.Коорд_Уст(line, col);
         Op := мСкан.цСущность;
         мДецл.КлючСлед_Получ;
         ЕСЛИ Op = мКонст.ксЕСТЬ ТОГДА
            мПров.Тест(e.уТип.тип_ном В {мКонст.типЗАПИСЬ, мКонст.типУКАЗАТЕЛЬ}, line, col, 37);
            ЕСЛИ e.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
               мПров.Тест(e.vparam, line, col, 37)
            КОНЕЦ;
            мДецл.Сущность_Проверить(lxIDENT);
            мДецл.Коорд_Уст(line2, col2);
            T := мДецл.IdType(line2, col2);
            мПров.Тест(T # ПУСТО, line2, col2, 42);
            ЕСЛИ e.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
               мПров.Тест(T.тип_ном = мКонст.типЗАПИСЬ, line2, col2, 106)
            ИНАЧЕ
               мПров.Тест(T.тип_ном = мКонст.типУКАЗАТЕЛЬ, line2, col2, 107)
            КОНЕЦ;
            мПров.Тест(BaseOf(e.уТип, T), line, col, 37);
            ЕСЛИ e.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
               X86.Drop;
               X86.LocalAdr(e.id.Offset, мДецл.модуль.цУровень - e.id.Level)
            КОНЕЦ;
            Выраж_Загрузить(e);
            ЕСЛИ e.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ ТОГДА
               T := T.Base
            КОНЕЦ;
            X86.Guard(T.номер, ИСТИНА);
            e.уТип := sttypes[мКонст.типБУЛЕВО];
            e.eType := eEXP;
            e.vparam := ЛОЖЬ
         ИНАЧЕ
            Выраж_Загрузить(e);
            Str(e);
            Simple(a);
            Выраж_Загрузить(a);
            Str(a);
            Operation(e, a, Op, line, col)
         КОНЕЦ
      КОНЕЦ;
      ЕСЛИ e.eType = eCONST ТОГДА
         X86.Del(beg);
         X86.Setfpu(fpu);
         ЕСЛИ ~мДецл.Const ТОГДА
            ВЫБОР e.уТип.тип_ном ИЗ
               |мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ:
                  X86.PushFlt(e.Value)
               |мКонст.типЦЕЛОЕ, мКонст.типНАБОР, мКонст.типБУЛЕВО, мКонст.типПУСТО:
                  X86.PushConst(КЦЕЛ(e.Value))
               |мКонст.типСТРОКА:
                  s := мДецл.уКонстСтр_Получ(e.Value);
                  ЕСЛИ s.длина = 1 ТОГДА
                    X86.PushConst(НЛИТ(s.стр[0]))
                  ИНАЧЕ
                    X86.PushInt(s.номер)
                  КОНЕЦ
            ИНАЧЕ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
   КОНЕЦ Expr;

ПРОЦЕДУРА IfWhileOper(wh: БУЛЕВО);
   ПЕРЕМ
      e: мДецл.тВыражение;
      line, col, L, L3: ЦЕЛОЕ;
   НАЧАЛО
      L := X86.NewLabel();
      ЕСЛИ wh ТОГДА
        X86.Label(L)
      КОНЕЦ;
      ПОВТОРЯТЬ
         мДецл.КлючСлед_Получ;
         мДецл.Коорд_Уст(line, col);
         Expr(e);
         мПров.Тест(e.уТип.тип_ном = мКонст.типБУЛЕВО, line, col, 117);
         Выраж_Загрузить(e);
         ЕСЛИ wh ТОГДА
            мДецл.Сущность_Проверить(мКонст.ксДЕЛАТЬ)
         ИНАЧЕ
            мДецл.Сущность_Проверить(мКонст.ксТОГДА)
         КОНЕЦ;
         L3 := X86.NewLabel();
         X86.ifwh(L3);
         мДецл.КлючСлед_Получ;
         pOpSeq;
         X86.jmp(X86.JMP, L);
         X86.Label(L3)
      ПОКАНЕ мСкан.цСущность # мКонст.ксАЕСЛИ;
      ЕСЛИ ~wh & (мСкан.цСущность = мКонст.ксИНАЧЕ) ТОГДА
         мДецл.КлючСлед_Получ;
         pOpSeq
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.ксКОНЕЦ);
      ЕСЛИ ~wh ТОГДА
         X86.Label(L)
      КОНЕЦ;
      мДецл.КлючСлед_Получ
   КОНЕЦ IfWhileOper;

ПРОЦЕДУРА КлСлово_ПОВТОР;
   ПЕРЕМ
      e: мДецл.тВыражение;
      line, col, L: ЦЕЛОЕ;
   НАЧАЛО
      мДецл.КлючСлед_Получ;
      L := X86.NewLabel();
      X86.Label(L);
      pOpSeq;
      мДецл.Сущность_Проверить(мКонст.ксПОКАНЕ);
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      Expr(e);
      мПров.Тест(e.уТип.тип_ном = мКонст.типБУЛЕВО, line, col, 117);
      Выраж_Загрузить(e);
      X86.ifwh(L)
   КОНЕЦ КлСлово_ПОВТОР;

ПРОЦЕДУРА КлСлово_ДЛЯ;
   ПЕРЕМ
      e: мДецл.тВыражение;
      line, col, LBeg, LEnd, iValue: ЦЕЛОЕ;
      Value: ДЛИНВЕЩ;
      T: мТип.туТип;
      name: мУзел.туЗвеноСущ;
      id: мДецл.туСущность;
   НАЧАЛО
      мДецл.КлючСлед_Получ;
      мДецл.Сущность_Проверить(lxIDENT);
      name := мСкан.сущ_глоб;
      id := мДецл.GetIdent(name);
      мПров.Тест2(id # ПУСТО, 42);
      мПров.Тест2(id.iType = IDVAR, 126);
      мПров.Тест2(id.VarKind = 0, 127);
      мПров.Тест2(id.уТип.тип_ном = мКонст.типЦЕЛОЕ, 128);
      мПров.Тест2(id.Level = мДецл.модуль.цУровень, 129);
      мДецл.КлючСлед_Получ;
      мДецл.Сущность_Проверить(lxAssign);
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      ЕСЛИ id.Level = 3 ТОГДА
         X86.GlobalAdr(id.Offset)
      ИНАЧЕ
         X86.LocalAdr(id.Offset, 0)
      КОНЕЦ;
      X86.Dup;
      Expr(e);
      мПров.Тест(e.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
      Выраж_Загрузить(e);
      X86.Save(мКонст.типЦЕЛОЕ);
      мДецл.Сущность_Проверить(мКонст.ксДО);
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      Expr(e);
      мПров.Тест(e.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
      Выраж_Загрузить(e);
      iValue := 1;
      ЕСЛИ мСкан.цСущность = мКонст.ксПО ТОГДА
         мДецл.КлючСлед_Получ;
         мДецл.Коорд_Уст(line, col);
         мДецл.ConstExpr(Value, T);
         мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
         iValue := КЦЕЛ(Value);
         мПров.Тест(iValue # 0, line, col, 122)
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.ксДЕЛАТЬ);
      мДецл.КлючСлед_Получ;
      X86.For(iValue > 0, LBeg, LEnd);
      pOpSeq;
      X86.NextFor(iValue, LBeg, LEnd);
      мДецл.Сущность_Проверить(мКонст.ксКОНЕЦ);
      мДецл.КлючСлед_Получ
   КОНЕЦ КлСлово_ДЛЯ;

ПРОЦЕДУРА Метка_Проверить(a, b: ЦЕЛОЕ; Labels: мЦепь.туЦепь): БУЛЕВО;
   ПЕРЕМ 
      cur: тМетка;
   НАЧАЛО
      cur := Labels.предыдущ(тМетка);
      ПОКА (cur # ПУСТО) & ((b < cur.a) ИЛИ (a > cur.b)) ДЕЛАТЬ
        cur := cur.следующ(тМетка)
      КОНЕЦ
      ВЕРНУТЬ cur = ПУСТО
   КОНЕЦ Метка_Проверить;

ПРОЦЕДУРА LabelVal(ПЕР a: ЦЕЛОЕ; int: БУЛЕВО);
   ПЕРЕМ
      Value: ДЛИНВЕЩ;
      T: мТип.туТип;
      s: мДецл.туКонстСтр;
      line, col: ЦЕЛОЕ;
   НАЧАЛО
      мДецл.Коорд_Уст(line, col);
      мДецл.ConstExpr(Value, T);
      ЕСЛИ int ТОГДА
         мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 161);
         a := КЦЕЛ(Value)
      ИНАЧЕ
         мПров.Тест(T.тип_ном = мКонст.типСТРОКА, line, col, 55);
         s := мДецл.уКонстСтр_Получ(Value);
         мПров.Тест(s.длина = 1, line, col, 94);
         a := НЛИТ(s.стр[0])
      КОНЕЦ
   КОНЕЦ LabelVal;

ПРОЦЕДУРА Label(int: БУЛЕВО; Labels: мЦепь.туЦепь; LBeg: ЦЕЛОЕ);
   ПЕРЕМ
      a, b: ЦЕЛОЕ;
      label: тМетка;
      line, col: ЦЕЛОЕ;
   НАЧАЛО
      мДецл.Коорд_Уст(line, col);
      LabelVal(a, int);
      b := a;
      ЕСЛИ мСкан.цСущность = lxDbl ТОГДА
         мДецл.КлючСлед_Получ;
         LabelVal(b, int)
      КОНЕЦ;
      мПров.Тест(a <= b, line, col, 54);
      мПров.Тест(Метка_Проверить(a, b, Labels), line, col, 100);
      НОВ(label);
      мПам.Мало(label = ПУСТО);
      label.a := a;
      label.b := b;
      мЦепь.Добавить(Labels, label);
      X86.CaseLabel(a, b, LBeg)
   КОНЕЦ Label;

ПРОЦЕДУРА Variant(int: БУЛЕВО; Labels: мЦепь.туЦепь; EndCase: ЦЕЛОЕ);
   ПЕРЕМ
      LBeg, LEnd: ЦЕЛОЕ;
   НАЧАЛО
      LBeg := X86.NewLabel();
      LEnd := X86.NewLabel();
      ЕСЛИ ~((мСкан.цСущность = мКонст.опВыбор) ИЛИ (мСкан.цСущность = мКонст.ксКОНЕЦ)) ТОГДА
         Label(int, Labels, LBeg);
         ПОКА мСкан.цСущность = мКонст.опЗапятая ДЕЛАТЬ
            мДецл.КлючСлед_Получ;
            Label(int, Labels, LBeg)
         КОНЕЦ;
         мДецл.Сущность_Проверить(мКонст.опДвоеточ);
         мДецл.КлючСлед_Получ;
         X86.jmp(X86.JMP, LEnd);
         X86.Label(LBeg);
         pOpSeq;
         X86.jmp(X86.JMP, EndCase);
         X86.Label(LEnd)
      КОНЕЦ
   КОНЕЦ Variant;

ПРОЦЕДУРА КлСлово_ВЫБОР;
   ПЕРЕМ
      e: мДецл.тВыражение;
      int: БУЛЕВО;
      line, col, EndCase: ЦЕЛОЕ;
      Labels: мЦепь.туЦепь;
   НАЧАЛО
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      Expr(e);
      мПров.Тест(e.уТип.тип_ном В {мКонст.типЛИТЕРА, мКонст.типСТРОКА, мКонст.типЦЕЛОЕ}, line, col, 156);
      мПров.Тест(~((e.уТип.тип_ном = мКонст.типСТРОКА) & (Стр_Длина(e.Value) # 1)), line, col, 94);
      int := e.уТип.тип_ном = мКонст.типЦЕЛОЕ;
      мДецл.Сущность_Проверить(мКонст.ксИЗ);
      Выраж_Загрузить(e);
      X86.Drop;
      Labels := мЦепь.Создать();
      мПам.Мало(Labels = ПУСТО);
      мДецл.КлючСлед_Получ;
      EndCase := X86.NewLabel();
      Variant(int, Labels, EndCase);
      ПОКА мСкан.цСущность = мКонст.опВыбор ДЕЛАТЬ
         мДецл.КлючСлед_Получ;
         Variant(int, Labels, EndCase)
      КОНЕЦ;
      ЕСЛИ мСкан.цСущность = мКонст.ксИНАЧЕ ТОГДА
         мДецл.КлючСлед_Получ;
         pOpSeq
      ИНАЧЕ
         мУтиль.КодСтрока_Уст(мДецл.UnitNumber, мСкан.цСтрока);
         X86.OnError(7)
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.ксКОНЕЦ);
      X86.Label(EndCase);
      мДецл.КлючСлед_Получ;
      мЦепь.Очистить(Labels)
   КОНЕЦ КлСлово_ВЫБОР;

ПРОЦЕДУРА CheckCode(Code: мСтр.тСтрока; Len, line, col: ЦЕЛОЕ);
   ПЕРЕМ
      i: ЦЕЛОЕ;
   НАЧАЛО
      мПров.Тест(~ODD(Len), line, col, 34);
      ДЛЯ i := 0 ДО Len - 1 ДЕЛАТЬ
         мПров.Тест(мСкан.Число16_Получ(Code[i]), line, col, 34)
      КОНЕЦ
   КОНЕЦ CheckCode;

ПРОЦЕДУРА StProc(proc: ЦЕЛОЕ);
   ПЕРЕМ
      line, col, line2, col2, iValue: ЦЕЛОЕ;
      e1, e2: мДецл.тВыражение;
      Value: ДЛИНВЕЩ;
      T: мТип.туТип;
      str: мДецл.туКонстСтр;
      begcall: X86.туЗвеноАсм;
   НАЧАЛО
      мДецл.Коорд_Уст(line2, col2);
      мДецл.Сущность_Проверить(lxLRound);
      мДецл.КлючСлед_Получ;
      мДецл.Коорд_Уст(line, col);
      ВЫБОР proc ИЗ
         |мКонст.процДОБ, мКонст.процВЫЧ:
            Designator(e1);
            мПров.Тест(e1.eType = eVAR, line, col, 63);
            мПров.Тест(~e1.Read, line, col, 115);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 128);
            ЕСЛИ мСкан.цСущность = мКонст.опЗапятая ТОГДА
               мДецл.КлючСлед_Получ;
               мДецл.Коорд_Уст(line, col);
               мДецл.ConstExpr(Value, T);
               мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
               iValue := КЦЕЛ(Value);
               мПров.Тест(iValue # 0, line, col, 122);
               ЕСЛИ iValue < 0 ТОГДА
                  ЕСЛИ proc = мКонст.процДОБ ТОГДА
                     proc := мКонст.процВЫЧ
                  ИНАЧЕ
                     proc := мКонст.процДОБ
                  КОНЕЦ;
                  iValue := -iValue
               КОНЕЦ;
               ЕСЛИ iValue # 1 ТОГДА
                  X86.PushConst(iValue);
                  ЕСЛИ proc = мКонст.процВЫЧ ТОГДА
                     X86.StProc(мКонст.процВЫЧ)
                  ИНАЧЕ
                     X86.StProc(мКонст.процДОБ)
                  КОНЕЦ
               ИНАЧЕ
                  ЕСЛИ proc = мКонст.процВЫЧ ТОГДА
                     X86.StProc(мКонст.процЗНСЛОЖ)
                  ИНАЧЕ
                     X86.StProc(мКонст.процДОПОЛН)
                  КОНЕЦ
               КОНЕЦ
            ИНАЧЕ
               ЕСЛИ proc = мКонст.процВЫЧ ТОГДА
                  X86.StProc(мКонст.процЗНСЛОЖ)
               ИНАЧЕ
                  X86.StProc(мКонст.процДОПОЛН)
               КОНЕЦ
            КОНЕЦ
         |мКонст.процДОБВ, мКонст.процВЫЧВ:
            Designator(e1);
            мПров.Тест(e1.eType = eVAR, line, col, 63);
            мПров.Тест(~e1.Read, line, col, 115);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типНАБОР, line, col, 138);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            мДецл.ConstExpr(Value, T);
            мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            iValue := КЦЕЛ(Value);
            мПров.Тест(ЗСП(iValue, 5) = 0, line, col, 53);
            ЕСЛИ proc = мКонст.процДОБВ ТОГДА
               X86.PushConst(НЛИТ({iValue}));
               X86.StProc(мКонст.процДОБВ)
            ИНАЧЕ
               X86.PushConst(НЛИТ(-{iValue}));
               X86.StProc(мКонст.процВЫЧВ)
            КОНЕЦ
         |мКонст.процКОПИЯ:
            Expr(e1);
            мПров.Тест(ЕслиСтрока(e1), line, col, 141);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            ЕСЛИ e1.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
               str := мДецл.уКонстСтр_Получ(e1.Value);
               ЕСЛИ str.длина = 1 ТОГДА
                  X86.Mono(str.номер);
                  X86.StrMono
               КОНЕЦ
            КОНЕЦ;
            Str(e1);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            Designator(e2);
            мПров.Тест(e2.eType = eVAR, line, col, 63);
            мПров.Тест(ЕслиСтрока(e2), line, col, 143);
            мПров.Тест(~e2.Read, line, col, 115);
            Str(e2);
            X86.StProc(мКонст.процКОПИЯ)
         |мКонст.процНОВ, мКонст.процЛИШН:
            Designator(e1);
            мПров.Тест(e1.eType = eVAR, line, col, 63);
            мПров.Тест(~e1.Read, line, col, 115);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типУКАЗАТЕЛЬ, line, col, 145);
            ЕСЛИ proc = мКонст.процНОВ ТОГДА
               X86.PushConst(e1.уТип.Base.номер);
               X86.PushConst(X86.Align(e1.уТип.Base.размер + 8, 32));
               X86.newrec
            ИНАЧЕ
               X86.disprec
            КОНЕЦ
         |мКонст.процКОНТРОЛЬ:
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типБУЛЕВО, line, col, 117);
            Выраж_Загрузить(e1);
            ЕСЛИ мСкан.цСущность = мКонст.опЗапятая ТОГДА
               мДецл.КлючСлед_Получ;
               мДецл.Коорд_Уст(line, col);
               мДецл.ConstExpr(Value, T);
               мПров.Тест(T.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
               мПров.Тест((Value >= 0.0D0) & (Value <= 127.0D0), line, col, 95);
               X86.Assert(мКонст.процКОНТРОЛЬ, КЦЕЛ(Value))
            ИНАЧЕ
               X86.Assert(мКонст.процКОНТРПИ, 0)
            КОНЕЦ
         |мКонст.процУПАК, мКонст.процРАСП:
            Designator(e1);
            мПров.Тест(e1.eType = eVAR, line, col, 63);
            мПров.Тест(e1.уТип.тип_ном В {мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ}, line, col, 149);
            мПров.Тест(~e1.Read, line, col, 115);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            ЕСЛИ proc = мКонст.процРАСП ТОГДА
               Designator(e2);
               мПров.Тест(e2.eType = eVAR, line, col, 63);
               мПров.Тест(e2.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 128);
               мПров.Тест(~e2.Read, line, col, 115);
               ЕСЛИ e1.уТип.тип_ном = мКонст.типДЛИНВЕЩ ТОГДА
                  X86.StProc(мКонст.процРАСП)
               ИНАЧЕ
                  X86.StProc(мКонст.процРАСПСПЕЦ)
               КОНЕЦ
            ИНАЧЕ
               Expr(e2);
               мПров.Тест(e2.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
               Выраж_Загрузить(e2);
               ЕСЛИ e1.уТип.тип_ном = мКонст.типДЛИНВЕЩ ТОГДА
                  X86.StProc(мКонст.процУПАК)
               ИНАЧЕ
                  X86.StProc(мКонст.процУПАКСПЕЦ)
               КОНЕЦ
            КОНЕЦ
         |мКонст.sysBIT:
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1)
         |мКонст.sysPUT, мКонст.sysGET:
            begcall := X86.current;
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            ЕСЛИ proc = мКонст.sysGET ТОГДА
               X86.PushCall(begcall);
               X86.Param;
               Designator(e2);
               мПров.Тест(e2.eType = eVAR, line, col, 63);
               мПров.Тест(e2.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типЛИТЕРА, мКонст.типНАБОР, мКонст.типБУЛЕВО, мКонст.TCARD16}, line, col, 154);
               мПров.Тест(~e2.Read, line, col, 115);
               X86.Вызов_Закончить;
               X86.Load(e2.уТип.тип_ном);
               X86.Save(e2.уТип.тип_ном)
            ИНАЧЕ
               Expr(e2);
               мПров.Тест(e2.уТип.тип_ном В {мКонст.типЦЕЛОЕ, мКонст.типВЕЩ, мКонст.типДЛИНВЕЩ, мКонст.типЛИТЕРА, мКонст.типНАБОР, мКонст.типБУЛЕВО, мКонст.TCARD16, мКонст.типСТРОКА}, line, col, 153);
               ЕСЛИ e2.уТип.тип_ном = мКонст.типСТРОКА ТОГДА
                  мПров.Тест(Стр_Длина(e2.Value) = 1, line, col, 94)
               КОНЕЦ;
               Выраж_Загрузить(e2);
               X86.Save(e2.уТип.тип_ном)
            КОНЕЦ
         |мКонст.sysCODE:
            мПров.Тест(мСкан.цСущность = lxSTRING, line, col, 150);
            мСкан.GetLexStr(стрСущн);
            CheckCode(стрСущн, мСкан.счётчик - 1, line, col);
            X86.Asm(стрСущн);
            мДецл.КлючСлед_Получ
         |мКонст.sysMOVE:
            begcall := X86.current;
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            X86.PushCall(begcall);
            X86.Param;
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
            мДецл.Сущность_Проверить(мКонст.опЗапятая);
            X86.Вызов_Закончить;
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            Expr(e1);
            мПров.Тест(e1.уТип.тип_ном = мКонст.типЦЕЛОЕ, line, col, 52);
            Выраж_Загрузить(e1);
      ИНАЧЕ
         мПров.Тест(ЛОЖЬ, line2, col2, 132)
      КОНЕЦ;
      мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
      мДецл.КлючСлед_Получ;
      ЕСЛИ proc = мКонст.sysMOVE ТОГДА
         X86.StProc(мКонст.sysMOVE);
      АЕСЛИ proc = мКонст.sysBIT ТОГДА
         мДецл.Сущность_Проверить(lxAssign);
         мДецл.КлючСлед_Получ;
         мДецл.Коорд_Уст(line, col);
         Expr(e1);
         мПров.Тест(e1.уТип.тип_ном = мКонст.типБУЛЕВО, line, col, 117);
         Выраж_Загрузить(e1);
         X86.StProc(мКонст.sysBIT)
      КОНЕЦ
   КОНЕЦ StProc;

ПРОЦЕДУРА IdentOper;
   ПЕРЕМ
      e1, e2: мДецл.тВыражение;
      line, col, ccall: ЦЕЛОЕ;
      begcall: X86.туЗвеноАсм;
      s: мДецл.туКонстСтр;
   НАЧАЛО
      мДецл.Коорд_Уст(line, col);
      begcall := X86.current;
      Designator(e1);
      мПров.Тест(e1.eType # eCONST, line, col, 130);
      ЕСЛИ (e1.eType = eVAR) & (e1.уТип.тип_ном # мКонст.типПРОЦЕДУРА) ТОГДА
         мДецл.Сущность_Проверить(lxAssign);
         мПров.Тест(~e1.Read, line, col, 115);
         мДецл.КлючСлед_Получ;
         мДецл.Коорд_Уст(line, col);
         Expr(e2);
         мПров.Тест(AssComp(e2, e1.уТип, ЛОЖЬ), line, col, 131);
         Выраж_Загрузить(e2);
         ЕСЛИ e1.уТип.тип_ном = мКонст.типЗАПИСЬ ТОГДА
            X86.PushConst(e1.уТип.размер);
            X86.PushConst(e1.уТип.номер);
            ЕСЛИ e1.vparam ТОГДА
               X86.LocalAdr(e1.id.Offset - 4, мДецл.модуль.цУровень - e1.id.Level);
               X86.Load(мКонст.типЦЕЛОЕ)
            АЕСЛИ e1.deref ТОГДА
               X86.DerefType(12)
            ИНАЧЕ
               X86.PushConst(e1.уТип.номер)
            КОНЕЦ
         АЕСЛИ e2.уТип.тип_ном = мКонст.типМАССИВ ТОГДА
            X86.PushConst(e2.уТип.размер)
         АЕСЛИ (e2.уТип.тип_ном = мКонст.типСТРОКА) & (e1.уТип.тип_ном = мКонст.типМАССИВ) ТОГДА
            s := мДецл.уКонстСтр_Получ(e2.Value);
            ЕСЛИ s.длина = 1 ТОГДА
               X86.Mono(s.номер)
            КОНЕЦ;
            X86.PushConst(мУтиль.Минимум(s.длина + 1, e1.уТип.длина))
         КОНЕЦ;
         X86.Save(e1.уТип.тип_ном)
      АЕСЛИ e1.eType = ePROC ТОГДА
         мПров.Тест((e1.id.уТип.Base.тип_ном = мКонст.TVOID) ИЛИ (e1.id.уТип.вызов = мДецл.winapi), line, col, 132);
         ЕСЛИ e1.id.ParamCount > 0 ТОГДА
            мДецл.Сущность_Проверить(lxLRound);
            мДецл.КлючСлед_Получ;
            X86.PushCall(begcall);
            Call(e1.id.уТип.поля.предыдущ(мДецл.туПоле));
            X86.Вызов_Закончить
         АЕСЛИ мСкан.цСущность = lxLRound ТОГДА
            мДецл.КлючСлед_Получ;
            мДецл.Сущность_Проверить(мКонст.опСкобкаПрКр);
            мДецл.КлючСлед_Получ
         КОНЕЦ;
         ЕСЛИ e1.id.Level = 3 ТОГДА
            ccall := 0
         АЕСЛИ e1.id.Level > мДецл.curBlock.Level ТОГДА
            ccall := 1
         ИНАЧЕ
            ccall := 2
         КОНЕЦ;
         X86.Call(e1.id.Number, ЛОЖЬ, ЛОЖЬ, e1.id.уТип.вызов, ccall, e1.id.Level - 3, мДецл.curBlock.Level - 3, e1.id.ParamSize, мДецл.curBlock.LocalSize)
      АЕСЛИ e1.eType В {eSTPROC, eSYSPROC} ТОГДА
          StProc(e1.id.StProc)
      АЕСЛИ (e1.eType = eVAR) & (e1.уТип.тип_ном = мКонст.типПРОЦЕДУРА) ТОГДА
         ЕСЛИ мСкан.цСущность = lxLRound ТОГДА
            мДецл.КлючСлед_Получ;
            мПров.Тест((e1.уТип.Base.тип_ном = мКонст.TVOID) ИЛИ (e1.уТип.вызов = мДецл.winapi), line, col, 132);
            X86.PushCall(begcall);
            Call(e1.уТип.поля.предыдущ(мДецл.туПоле));
            X86.Вызов_Закончить;
            X86.CallVar(ЛОЖЬ, ЛОЖЬ, e1.уТип.вызов, e1.уТип.длина, мДецл.curBlock.LocalSize)
         АЕСЛИ мСкан.цСущность = lxAssign ТОГДА
            мПров.Тест(~e1.Read, line, col, 115);
            мДецл.КлючСлед_Получ;
            мДецл.Коорд_Уст(line, col);
            Expr(e2);
            мПров.Тест(AssComp(e2, e1.уТип, ЛОЖЬ), line, col, 131);
            мПров.Тест(~((e2.eType = ePROC) & (e2.id.Level > 3)), line, col, 116);
            ЕСЛИ e2.eType = eVAR ТОГДА
               X86.Load(мКонст.типПРОЦЕДУРА)
            КОНЕЦ;
            X86.Save(мКонст.типПРОЦЕДУРА)
         ИНАЧЕ
            мПров.Тест2(e1.уТип.поля.счётчик = 0, 155);
            мПров.Тест((e1.уТип.Base.тип_ном = мКонст.TVOID) ИЛИ (e1.уТип.вызов = мДецл.winapi), line, col, 132);
            X86.CallVar(ЛОЖЬ, ЛОЖЬ, e1.уТип.вызов, e1.уТип.длина, мДецл.curBlock.LocalSize)
         КОНЕЦ
      КОНЕЦ
   КОНЕЦ IdentOper;

ПРОЦЕДУРА КлСлово_Выбрать;
   НАЧАЛО
      мУтиль.КодСтрока_Уст(мДецл.UnitNumber, мСкан.цСтрока);
      ВЫБОР мСкан.цСущность ИЗ
         |lxIDENT: IdentOper
         |мКонст.ксЕСЛИ, мКонст.ксПОКА: IfWhileOper(мСкан.цСущность = мКонст.ксПОКА)
         |мКонст.ксПОВТОР: КлСлово_ПОВТОР
         |мКонст.ксДЛЯ: КлСлово_ДЛЯ
         |мКонст.ксВЫБОР: КлСлово_ВЫБОР
      ИНАЧЕ
      КОНЕЦ
   КОНЕЦ КлСлово_Выбрать;

ПРОЦЕДУРА OpSeq;
   НАЧАЛО
      КлСлово_Выбрать;
      ПОКА мСкан.цСущность = мКонст.опТчкЗпт ДЕЛАТЬ
         мДецл.КлючСлед_Получ;
         КлСлово_Выбрать
      КОНЕЦ
   КОНЕЦ OpSeq;

ПРОЦЕДУРА Старт;
   ПЕРЕМ
      сам_имя, сам_путь, CName, CExt, путь, StdPath,
      temp, felf: мСтр.тСтрока;
      стек: мСтек.тСтек;
      ОС: мОС.тОС;
      уФайл: мФайл.туФайл;

   ПРОЦЕДУРА getver(): ЦЕЛОЕ;
      ПЕРЕМ
         res, i: ЦЕЛОЕ;
         бОшибка: БУЛЕВО;

      ПРОЦЕДУРА Симв_Hex(c: ЛИТ): БУЛЕВО;
            ВЕРНУТЬ ("0" <= c) & (c <= "9") ИЛИ
                  ("A" <= c) & (c <= "F") ИЛИ
                  ("a" <= c) & (c <= "f")
         КОНЕЦ Симв_Hex;

      ПРОЦЕДУРА СимвНех_в_Целое(c: ЛИТ): ЦЕЛОЕ;
         ПЕРЕМ
            число: ЦЕЛОЕ;
         НАЧАЛО
            ЕСЛИ  ("0" <= c) & (c <= "9") ТОГДА
               число := НЛИТ(c) - НЛИТ("0")
            АЕСЛИ ("A" <= c) & (c <= "F") ТОГДА
               число := НЛИТ(c) - НЛИТ("A") + 10
            АЕСЛИ ("a" <= c) & (c <= "f") ТОГДА
               число := НЛИТ(c) - НЛИТ("a") + 10
            КОНЕЦ
               ВЕРНУТЬ число
         КОНЕЦ СимвНех_в_Целое;

      НАЧАЛО
         res := 0;
         i := 0;
         бОшибка := стек.стрРазмер[i] # "0";
         ДОБ(i);
         бОшибка := бОшибка ИЛИ (стек.стрРазмер[i] # "x");
         ДОБ(i);
         
         ПОКА ~бОшибка & Симв_Hex(стек.стрРазмер[i]) ДЕЛАТЬ
            ДОБ(i)
         КОНЕЦ;
               
         бОшибка := бОшибка ИЛИ (i = 2);
         
         ЕСЛИ стек.стрРазмер[i] <= 20X ТОГДА
            стек.стрРазмер[i] := 0X
         ИНАЧЕ
            бОшибка := ИСТИНА
         КОНЕЦ;
         i := 2;
         ПОКА ~бОшибка & (стек.стрРазмер[i] # 0X) ДЕЛАТЬ
            res := ЛСЛ(res, 4) + СимвНех_в_Целое(стек.стрРазмер[i]);
            ДОБ(i)
         КОНЕЦ;
         ЕСЛИ res = 0 ТОГДА
               res := 1
         КОНЕЦ
         ВЕРНУТЬ res
      КОНЕЦ getver;

   НАЧАЛО
      НОВ(уФайл);
      ЕСЛИ мУтиль.параметры_всего < 2 ТОГДА
         мОш.Сообщ(мОшКонст.ошМалоПарам);
         мПроц.Закончить(1)
      КОНЕЦ;
      мУтиль.СтрПарам(сам_имя, 0);
      мУтиль.СтрПарам(уФайл.стрИмяРасшир, 1);
      мУтиль.СтрПарам(ОС.стрИмя, 2);
      мУтиль.СтрПарам(стек.стрРазмер, 3);
      пВыраж := Expr;
      pFactor := Factor;
      pOpSeq := OpSeq;
      мСтр.Разделить(уФайл.стрИмяРасшир, путь, уФайл.стрИмя, уФайл.стрРасшир);
      ЕСЛИ уФайл.стрРасшир # мКонст.расшир ТОГДА
         мОш.Сообщ(121);
         мПроц.Закончить(1)
      КОНЕЦ;
      мСтр.Разделить(сам_имя, сам_путь, CName, CExt);
      temp := уФайл.стрИмя;
      ЕСЛИ мСтр.Сравнить(ОС.стрИмя, "obj") ТОГДА
         ОС.цКод := мКонст.сисОбъект;
      мСтр.Сложить(temp, ".obj", temp)
      АЕСЛИ мСтр.Сравнить(ОС.стрИмя, "elf") ТОГДА
         ОС.цКод := мКонст.сисЭльф;
         felf := сам_путь;
         мСтр.Сложить(felf, "Elf", felf);
         X86.setfelf(felf)
      АЕСЛИ мСтр.Сравнить(ОС.стрИмя, "kos") ТОГДА
         ОС.цКод := мКонст.сисКолибри;
         мСтр.Сложить(temp, ".kex", temp)
      АЕСЛИ мСтр.Сравнить(ОС.стрИмя, "con") ТОГДА
         ОС.цКод := мКонст.сисМсКонсоль;
         мСтр.Сложить(temp, ".exe", temp)
      АЕСЛИ мСтр.Сравнить(ОС.стрИмя, "gui") ТОГДА
         ОС.цКод := мКонст.сисМсОкно;
         мСтр.Сложить(temp, ".exe", temp)
      АЕСЛИ мСтр.Сравнить(ОС.стрИмя, "dll") ТОГДА
         ОС.цКод := мКонст.сисМсДЛЛ;
         мСтр.Сложить(temp, ".dll", temp)
      ИНАЧЕ
         мОш.Сообщ(мОшКонст.ошОшПарам);
         мПроц.Закончить(1)
      КОНЕЦ;
      ЕСЛИ ОС.цКод В {1,2,3,4} ТОГДА
         мСтек.цРазмер_Уст(стек)
      ИНАЧЕ
         стек.цРазмер := 1
      КОНЕЦ;
      ЕСЛИ ОС.цКод = 6 ТОГДА
         стек.цРазмер := getver()
      КОНЕЦ;
      мСтр.Сложить(сам_путь, "Lib", сам_путь);
      мСтр.Сложить(сам_путь, мКонст.слэш, сам_путь);
      ЕСЛИ ОС.цКод = 5 ТОГДА
         мСтр.Сложить(сам_путь, "Linux32", сам_путь)
      АЕСЛИ ОС.цКод В {4, 6} ТОГДА
         мСтр.Сложить(сам_путь, "KolibriOS", сам_путь)
      АЕСЛИ ОС.цКод В {1, 2, 3} ТОГДА
         мСтр.Сложить(сам_путь, "Windows32", сам_путь)
      КОНЕЦ;
      мСтр.Сложить(сам_путь, мКонст.слэш, сам_путь);
      X86.Настроить(мПам.Мало, ОС.цКод);
      X86.Prolog(temp);
      мДецл.Код_Настроить(сам_путь, путь, уФайл.стрИмя, уФайл.стрРасшир, ОС.цКод В {1, 2, 3}, OpSeq, Expr, AssComp, sttypes);
      мДецл.Компилировать(ОС.цКод, стек.цРазмер);
      мВинКонс.Цвет_Уст(мВинКонс.белый, мВинКонс.синий);
      мКонс.Строка_Печать("   +Компиляция успешна!"); мКонс.НовСтр;
      мВинКонс.Цвет_Уст(мВинКонс.свЖёлтый, мВинКонс.чёрный);
      мКонс.Время_Затрачено;
      мВинКонс.Цвет_Уст(мВинКонс.белый, мВинКонс.чёрный)
   КОНЕЦ Старт;

НАЧАЛО
   Старт
КОНЕЦ Compiler.
