(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
   *)
ÌÎÄÓËÜ Compiler;

ÈÌÏÎÐÒ DECL := ìîäÄåöë,
    ìÑêàí := ìîäÑêàíåð,
    ìÓòèëü := ìîäÓòèëü,
    X86 := ìîäÀñì86_32,
    SYSTEM,
    ìÒèïû := ìîäÒèïû,
    ìÊîíñò := ìîäÊîíñòàíòû,
    ìÊîíñ := ìîäÊîíñîëü,
    ìÎø := ìîäÎøèáêè,
    ìÏðîö := ìîäÏðîöåññ,
    ìÑòð := ìîäÑòðîêè,
    ìÑïèñ := ìîäÑïèñîê,
    ìÏðîâ := ìîäÏðîâåðêà;

ÊÎÍÑÒ

  lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
  lxBY = 3; lxDIV = 6;
  lxMOD = 17; 

  lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54; lxNot = 55; lxAnd = 56; lxComma = 57; lxSemi = 58;
  lxStick = 59; lxLRound = 60; lxLSquare = 61; lxLCurly = 62; lxCaret = 63; lxRRound = 64; lxRSquare = 65;
  lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69; lxColon = 70;
  lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7;
  TNIL = 8; TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

  IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

  stABS = 1; stODD = 2; stLEN = 3; stLSL = 4; stASR = 5; stROR = 6; stFLOOR = 7; stFLT = 8;
  stORD = 9; stCHR = 10; stLONG = 11; stSHORT = 12; stINC = 13; stDEC = 14; stINCL = 15;
  stEXCL = 16; stCOPY = 17; stNEW = 18; stASSERT = 19; stPACK = 20; stUNPK = 21; stDISPOSE = 22;
  stBITS = 23; stLSR = 24; stLENGTH = 25;

  sysADR = 101; sysSIZE = 102; sysBIT = 103; sysGET = 104; sysPUT = 105; sysCODE = 106;
  sysTYPEID = 107; sysMOVE = 108;

ÒÈÏÛ

  LABEL = ÓÊÀÇÀÒÅËÜ ÍÀ ÇÀÏÈÑÜ (ìÒèïû.òÏóíêò)
      a, b: INTEGER
    ÊÎÍÅÖ;

ÏÅÐÅÌ
  pExpr, pFactor: ÏÐÎÖÅÄÓÐÀ (ÏÅÐ e: DECL.òÂûðàæåíèå);
  pOpSeq: ÏÐÎÖÅÄÓÐÀ;
  Lex: ìÑòð.òÑòðîêà;
  sttypes: DECL.òóÒèïÍàáîð;

ÏÐÎÖÅÄÓÐÀ Load(e: DECL.òÂûðàæåíèå);
  ÍÀ×ÀËÎ
    ÅÑËÈ e.eType = eVAR ÒÎÃÄÀ
      X86.Load(e.T.tType)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Load;

ÏÐÎÖÅÄÓÐÀ LenString(adr: LONGREAL): INTEGER;
  ÏÅÐÅÌ
    s: DECL.òóÊîíñòÑòð;
  ÍÀ×ÀËÎ
    s := DECL.Ñòð_Ïîëó÷(adr)
    ÂÅÐÍÓÒÜ s.Len
  ÊÎÍÅÖ LenString;

ÏÐÎÖÅÄÓÐÀ Coord(ÏÅÐ line, col: INTEGER);
  ÍÀ×ÀËÎ
    line := ìÑêàí.line;
    col := ìÑêàí.col
  ÊÎÍÅÖ Coord;

ÏÐÎÖÅÄÓÐÀ Assert(cond: BOOLEAN; line, col, code: INTEGER);
  ÍÀ×ÀËÎ
    ÅÑËÈ ~cond ÒÎÃÄÀ
      ìÏðîâ.Òåñò(ËÎÆÜ, line, col, code)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Assert;

ÏÐÎÖÅÄÓÐÀ Assert2(cond: BOOLEAN; code: INTEGER);
  ÍÀ×ÀËÎ
    ÅÑËÈ ~cond ÒÎÃÄÀ
      ìÏðîâ.Òåñò(ËÎÆÜ, ìÑêàí.line, ìÑêàí.col, code)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Assert2;

ÏÐÎÖÅÄÓÐÀ Next;
  ÍÀ×ÀËÎ
    DECL.Next
  ÊÎÍÅÖ Next;

ÏÐÎÖÅÄÓÐÀ Check(key: INTEGER);
  ÍÀ×ÀËÎ
    DECL.Check(key)
  ÊÎÍÅÖ Check;

ÏÐÎÖÅÄÓÐÀ BaseOf(T0, T1: DECL.òóÒèï): BOOLEAN;
  ÍÀ×ÀËÎ
    ÅÑËÈ (T0.tType = T1.tType) & (T0.tType IN {TRECORD, TPOINTER}) ÒÎÃÄÀ
      ÅÑËÈ T0.tType = TPOINTER ÒÎÃÄÀ
        T0 := T0.Base;
        T1 := T1.Base
      ÊÎÍÅÖ;
      ÏÎÊÀ (T1 # ÏÓÑÒÎ) & (T1 # T0) ÄÅËÀÒÜ
        T1 := T1.Base
      ÊÎÍÅÖ
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ T0 = T1
  ÊÎÍÅÖ BaseOf;

ÏÐÎÖÅÄÓÐÀ Designator(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    id: DECL.òóÈìÿ;
    name: ìÒèïû.òóÓçåë;
    e1: DECL.òÂûðàæåíèå;
    line, col, i, n, bases, glob, loc, idx: INTEGER;
    imp, break, guard: BOOLEAN;
    f: DECL.òóÏîëå;
    T, BaseT: DECL.òóÒèï;
    s: DECL.òóÊîíñòÑòð;

    ÏÐÎÖÅÄÓÐÀ LoadVar;
    ÍÀ×ÀËÎ
      ÅÑËÈ glob # -1 ÒÎÃÄÀ
        X86.GlobalAdr(glob);
        glob := -1
      ÀÅÑËÈ loc # -1 ÒÎÃÄÀ
        X86.LocalAdr(loc, bases);
        loc := -1
      ÊÎÍÅÖ
    ÊÎÍÅÖ LoadVar;

  ÍÀ×ÀËÎ
    glob := -1;
    loc := -1;
    Coord(line, col);
    Check(lxIDENT);
    name := ìÑêàí.id;
    id := DECL.GetIdent(name);
    ÅÑËÈ (id # ÏÓÑÒÎ) & (id.iType = IDMOD) ÒÎÃÄÀ
      Next;
      Check(lxDot);
      Next;
      Check(lxIDENT);
      Coord(line, col);
      name := ìÑêàí.id;
      imp := id.Unit # DECL.unit;
      id := DECL.GetQIdent(id.Unit, name)
    ÊÎÍÅÖ;
    Assert(id # ÏÓÑÒÎ, line, col, 42);
    e.vparam := ËÎÆÜ;
    e.deref := ËÎÆÜ;
    e.id := id;
    Next;
    ÂÛÁÎÐ id.iType ÈÇ
    |IDVAR:
      e.eType := eVAR;
      e.T := id.T;
      ÅÑËÈ id.VarKind = 0 ÒÎÃÄÀ
        e.Read := imp
      ÈÍÀ×Å
        e.Read := (id.VarKind = DECL.param) & (id.T.tType IN {TRECORD, TARRAY});
        e.vparam := id.VarKind = DECL.paramvar
      ÊÎÍÅÖ;
      bases := DECL.unit.Level - id.Level;
      ÅÑËÈ id.Level = 3 ÒÎÃÄÀ
        glob := id.Offset
      ÀÅÑËÈ (id.VarKind = 0) ÈËÈ (id.VarKind = DECL.param) & ~(id.T.tType IN {TARRAY, TRECORD}) ÒÎÃÄÀ
        loc := id.Offset
      ÀÅÑËÈ (id.VarKind = DECL.paramvar) ÈËÈ (id.T.tType IN {TARRAY, TRECORD}) ÒÎÃÄÀ
        ÅÑËÈ DECL.Dim(e.T) > 0 ÒÎÃÄÀ
          n := DECL.Dim(e.T);
          ÄËß i := n ÄÎ 1 BY -1 ÄÅËÀÒÜ
            X86.LocalAdr(id.Offset + i * 4, bases);
            X86.Load(TINTEGER)
          ÊÎÍÅÖ
        ÊÎÍÅÖ;
        X86.LocalAdr(id.Offset, bases);
        X86.Load(TINTEGER)
      ÊÎÍÅÖ
    |IDCONST:
      Assert(id.T # ÏÓÑÒÎ, line, col, 75);
      e.eType := eCONST;
      e.T := id.T;
      e.Value := id.Value;
      ÅÑËÈ id.T.tType IN {TINTEGER, TSET, TBOOLEAN} ÒÎÃÄÀ
        X86.PushConst(FLOOR(e.Value))
      ÀÅÑËÈ id.T.tType IN {TREAL, TLONGREAL} ÒÎÃÄÀ
        X86.PushFlt(e.Value)
      ÀÅÑËÈ id.T.tType = TSTRING ÒÎÃÄÀ
        s := DECL.Ñòð_Ïîëó÷(e.Value);
        ÅÑËÈ s.Len = 1 ÒÎÃÄÀ
          X86.PushConst(ORD(s.Str[0]))
        ÈÍÀ×Å
          X86.PushInt(s.Number)
        ÊÎÍÅÖ
      ÊÎÍÅÖ
    |IDPROC:
      e.eType := ePROC;
      e.T := sttypes[TVOID]
    |IDTYPE:
      Assert(ËÎÆÜ, line, col, 101)
    |IDSTPROC:
      e.eType := eSTPROC;
      e.T := sttypes[TVOID]
    |IDSYSPROC:
      e.eType := eSYSPROC;
      e.T := sttypes[TVOID]
    ÈÍÀ×Å
    ÊÎÍÅÖ;
    break := ËÎÆÜ;
    guard := ËÎÆÜ;
    ÏÎÂÒÎÐßÒÜ
      ÂÛÁÎÐ ìÑêàí.tLex ÈÇ
      |lxDot:
        e.deref := ËÎÆÜ;
        Assert2(e.T.tType IN {TPOINTER, TRECORD}, 105);
        ÅÑËÈ e.T.tType = TPOINTER ÒÎÃÄÀ
          e.Read := ËÎÆÜ;
          LoadVar;
          e.T := e.T.Base;
          X86.Load(TINTEGER);
          ÅÑËÈ ~guard ÒÎÃÄÀ
            X86.CheckNIL
          ÊÎÍÅÖ
        ÊÎÍÅÖ;
        Next;
        Check(lxIDENT);
        Coord(line, col);
        name := ìÑêàí.id;
        T := e.T;
        ÏÎÂÒÎÐßÒÜ
          f := DECL.GetField(T, name);
          T := T.Base
        ÏÎÊÀÍÅ (f # ÏÓÑÒÎ) ÈËÈ (T = ÏÓÑÒÎ);
        Assert(f # ÏÓÑÒÎ, line, col, 99);
        ÅÑËÈ f.Unit # DECL.unit ÒÎÃÄÀ
          Assert(f.Export, line, col, 99)
        ÊÎÍÅÖ;
        ÅÑËÈ glob # -1 ÒÎÃÄÀ
          glob := glob + f.Offset
        ÀÅÑËÈ loc # -1 ÒÎÃÄÀ
          loc := loc + f.Offset
        ÈÍÀ×Å
          X86.Field(f.Offset)
        ÊÎÍÅÖ;
        e.T := f.T;
        e.vparam := ËÎÆÜ;
        guard := ËÎÆÜ;
        Next
      |lxLSquare:
        LoadVar;
        ÏÎÂÒÎÐßÒÜ
          Assert2(e.T.tType = TARRAY, 102);
          Next;
          Coord(line, col);
          pExpr(e1);
          Assert(e1.T.tType = TINTEGER, line, col, 52);
          Load(e1);
          ÅÑËÈ e.T.Len = 0 ÒÎÃÄÀ
            BaseT := DECL.OpenBase(e.T);
            X86.PushConst(BaseT.Size);
            X86.OpenIdx(DECL.Dim(e.T))
          ÈÍÀ×Å
            ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
              idx := FLOOR(e1.Value);
              Assert((idx >= 0) & (idx < e.T.Len), line, col, 159);
              ÅÑËÈ e.T.Base.Size # 1 ÒÎÃÄÀ
                X86.Drop;
                X86.PushConst(e.T.Base.Size * idx)
              ÊÎÍÅÖ;
              X86.Idx
            ÈÍÀ×Å
              X86.FixIdx(e.T.Len, e.T.Base.Size)
            ÊÎÍÅÖ
          ÊÎÍÅÖ;
          e.T := e.T.Base
        ÏÎÊÀÍÅ ìÑêàí.tLex # lxComma;
        Check(lxRSquare);
        e.vparam := ËÎÆÜ;
        guard := ËÎÆÜ;
        Next
      |lxCaret:
        LoadVar;
        Assert2(e.T.tType = TPOINTER, 104);
        e.Read := ËÎÆÜ;
        X86.Load(TINTEGER);
        ÅÑËÈ ~guard ÒÎÃÄÀ
          X86.CheckNIL
        ÊÎÍÅÖ;
        e.T := e.T.Base;
        e.vparam := ËÎÆÜ;
        e.deref := ÈÑÒÈÍÀ;
        guard := ËÎÆÜ;
        Next
      |lxLRound:
        LoadVar;
        ÅÑËÈ e.T.tType IN {TRECORD, TPOINTER} ÒÎÃÄÀ
          ÅÑËÈ e.T.tType = TRECORD ÒÎÃÄÀ
            Assert2(e.vparam, 108)
          ÊÎÍÅÖ;
          Next;
          Check(lxIDENT);
          Coord(line, col);
          T := DECL.IdType(line, col);
          Assert(T # ÏÓÑÒÎ, line, col, 42);
          ÅÑËÈ e.T.tType = TRECORD ÒÎÃÄÀ
            Assert(T.tType = TRECORD, line, col, 106)
          ÈÍÀ×Å
            Assert(T.tType = TPOINTER, line, col, 107)
          ÊÎÍÅÖ;
          Assert(BaseOf(e.T, T), line, col, 108);
          e.T := T;
          Check(lxRRound);
          Next;
          ÅÑËÈ e.T.tType = TPOINTER ÒÎÃÄÀ
            ÅÑËÈ (ìÑêàí.tLex = lxDot) ÈËÈ (ìÑêàí.tLex = lxCaret) ÒÎÃÄÀ
              X86.DupLoadCheck
            ÈÍÀ×Å
              X86.DupLoad
            ÊÎÍÅÖ;
            guard := ÈÑÒÈÍÀ;
            T := T.Base
          ÈÍÀ×Å
            X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
          ÊÎÍÅÖ;
          X86.Guard(T.Number, ËÎÆÜ)
        ÈÍÀ×Å
          break := ÈÑÒÈÍÀ
        ÊÎÍÅÖ
      ÈÍÀ×Å
        break := ÈÑÒÈÍÀ
      ÊÎÍÅÖ
    ÏÎÊÀÍÅ break;
    LoadVar
  ÊÎÍÅÖ Designator;

ÏÐÎÖÅÄÓÐÀ Set(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    a, b: DECL.òÂûðàæåíèå;
    line, col: INTEGER;
    s: SET; flag: BOOLEAN;
  ÍÀ×ÀËÎ
    Next;
    e.eType := eEXP;
    e.T := sttypes[TSET];
    e.Value := 0.0D0;
    e.vparam := ËÎÆÜ;
    s := {};
    flag := ÈÑÒÈÍÀ;
    X86.PushConst(0);
    ÏÎÊÀ ìÑêàí.tLex # lxRCurly ÄÅËÀÒÜ
      Coord(line, col);
      pExpr(a);
      Assert(a.T.tType = TINTEGER, line, col, 52);
      ÅÑËÈ a.eType = eCONST ÒÎÃÄÀ
        Assert(ASR(FLOOR(a.Value), 5) = 0, line, col, 53)
      ÊÎÍÅÖ;
      Load(a);
      b := a;
      ÅÑËÈ ìÑêàí.tLex = lxDbl ÒÎÃÄÀ
        Next;
        Coord(line, col);
        pExpr(b);
        Assert(b.T.tType = TINTEGER, line, col, 52);
        ÅÑËÈ b.eType = eCONST ÒÎÃÄÀ
          Assert(ASR(FLOOR(b.Value), 5) = 0, line, col, 53);
          Assert(a.Value <= b.Value, line, col, 54)
        ÊÎÍÅÖ;
        Load(b)
      ÈÍÀ×Å
        X86.Dup
      ÊÎÍÅÖ;
      X86.rset;
      X86.Set(lxPlus);
      flag := (a.eType = eCONST) & (b.eType = eCONST) & flag;
      ÅÑËÈ flag ÒÎÃÄÀ
        s := s + {FLOOR(a.Value) .. FLOOR(b.Value)}
      ÊÎÍÅÖ;
      ÅÑËÈ ìÑêàí.tLex = lxComma ÒÎÃÄÀ
        Next;
        Assert2(ìÑêàí.tLex # lxRCurly, 36)
      ÈÍÀ×Å
        Check(lxRCurly)
      ÊÎÍÅÖ
    ÊÎÍÅÖ;
    ÅÑËÈ flag ÒÎÃÄÀ
      e.Value := LONG(FLT(ORD(s)));
      e.eType := eCONST
    ÊÎÍÅÖ;
    Next
  ÊÎÍÅÖ Set;

ÏÐÎÖÅÄÓÐÀ IsString(a: DECL.òÂûðàæåíèå): BOOLEAN;
    ÂÅÐÍÓÒÜ (a.T.tType = TSTRING) ÈËÈ (a.T.tType = TARRAY) & (a.T.Base.tType = TCHAR)
  ÊÎÍÅÖ IsString;

ÏÐÎÖÅÄÓÐÀ Str(e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    A: X86.TIDX;
  ÍÀ×ÀËÎ
    ÅÑËÈ (e.T.tType = TARRAY) & (e.T.Base.tType = TCHAR) & (e.T.Len # 0) ÒÎÃÄÀ
      A[0] := e.T.Len;
      X86.OpenArray(A, 1)
    ÀÅÑËÈ e.T.tType = TSTRING ÒÎÃÄÀ
      A[0] := LenString(e.Value) + 1;
      ÅÑËÈ A[0] # 2 ÒÎÃÄÀ
        X86.OpenArray(A, 1)
      ÊÎÍÅÖ
    ÊÎÍÅÖ
  ÊÎÍÅÖ Str;

ÏÐÎÖÅÄÓÐÀ StFunc(ÏÅÐ e: DECL.òÂûðàæåíèå; func: INTEGER);
  ÏÅÐÅÌ
    line, col, line2, col2, a, b, p: INTEGER;
    e1, e2: DECL.òÂûðàæåíèå;
    T: DECL.òóÒèï;
    str, str2: DECL.òóÊîíñòÑòð;
  ÍÀ×ÀËÎ
    e.vparam := ËÎÆÜ;
    e.eType := eEXP;
    Coord(line2, col2);
    Check(lxLRound);
    Next;
    Coord(line, col);
    ÂÛÁÎÐ func ÈÇ
    |stABS:
      pExpr(e1);
      Assert(e1.T.tType IN {TINTEGER, TREAL, TLONGREAL}, line, col, 57);
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        e.Value := ABS(e1.Value);
        e.eType := eCONST;
        Assert(~((e1.T.tType = TINTEGER) & (e1.Value = LONG(FLT(ìÊîíñò.öåëîå_ìèí)))), line, col, DECL.IOVER)
      ÊÎÍÅÖ;
      ÅÑËÈ e1.T.tType = TINTEGER ÒÎÃÄÀ
        X86.StFunc(X86.stABS)
      ÈÍÀ×Å
        X86.StFunc(X86.stFABS)
      ÊÎÍÅÖ;
      e.T := e1.T
    |stODD:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        e.Value := LONG(FLT(ORD(ODD(FLOOR(e1.Value)))));
        e.eType := eCONST
      ÊÎÍÅÖ;
      X86.StFunc(X86.stODD);
      e.T := sttypes[TBOOLEAN]
    |stLEN:
      Designator(e1);
      Assert((e1.eType = eVAR) & (e1.T.tType = TARRAY), line, col, 102);
      ÅÑËÈ e1.T.Len > 0 ÒÎÃÄÀ
        X86.Len(-e1.T.Len)
      ÈÍÀ×Å
        X86.Len(DECL.Dim(e1.T))
      ÊÎÍÅÖ;
      e.T := sttypes[TINTEGER]
    |stLSL, stASR, stROR, stLSR:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      pExpr(e2);
      Assert(e2.T.tType = TINTEGER, line, col, 52);
      Load(e2);
      ÅÑËÈ (e1.eType = eCONST) & (e2.eType = eCONST) ÒÎÃÄÀ
        a := FLOOR(e1.Value);
        b := FLOOR(e2.Value);
        ÂÛÁÎÐ func ÈÇ
        |stLSL: a := LSL(a, b)
        |stASR: a := ASR(a, b)
        |stROR: a := ROR(a, b)
        |stLSR: a := LSR(a, b)
        ÈÍÀ×Å
        ÊÎÍÅÖ;
        e.Value := LONG(FLT(a));
        e.eType := eCONST
      ÊÎÍÅÖ;
      ÂÛÁÎÐ func ÈÇ
      |stLSL: X86.StFunc(X86.stLSL)
      |stASR: X86.StFunc(X86.stASR)
      |stROR: X86.StFunc(X86.stROR)
      |stLSR: X86.StFunc(X86.stLSR)
      ÈÍÀ×Å
      ÊÎÍÅÖ;
      e.T := sttypes[TINTEGER]
    |stFLOOR:
      pExpr(e1);
      Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 66);
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        Assert((e1.Value - 1.0D0 < LONG(FLT(ìÊîíñò.öåëîå_ìàêñ))) & (e1.Value >= LONG(FLT(ìÊîíñò.öåëîå_ìèí))), line, col, 74);
        e.Value := LONG(FLT(FLOOR(e1.Value)));
        e.eType := eCONST
      ÊÎÍÅÖ;
      X86.StFunc(X86.stFLOOR);
      e.T := sttypes[TINTEGER]
    |stFLT:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        e.Value := e1.Value;
        e.eType := eCONST
      ÊÎÍÅÖ;
      X86.StFunc(X86.stFLT);
      e.T := sttypes[TREAL]
    |stORD:
      pExpr(e1);
      Assert(e1.T.tType IN {TCHAR, TBOOLEAN, TSET, TSTRING}, line, col, 68);
      ÅÑËÈ e1.T.tType = TSTRING ÒÎÃÄÀ
        Assert(LenString(e1.Value) = 1, line, col, 94)
      ÊÎÍÅÖ;
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        ÅÑËÈ e1.T.tType = TSTRING ÒÎÃÄÀ
          str := DECL.Ñòð_Ïîëó÷(e1.Value);
          e.Value := LONG(FLT(ORD(str.Str[0])))
        ÈÍÀ×Å
          e.Value := e1.Value
        ÊÎÍÅÖ;
        e.eType := eCONST
      ÊÎÍÅÖ;
      ÅÑËÈ e1.T.tType = TBOOLEAN ÒÎÃÄÀ
        X86.StFunc(X86.stORD)
      ÊÎÍÅÖ;
      e.T := sttypes[TINTEGER]
    |stBITS:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        e.Value := e1.Value;
        e.eType := eCONST
      ÊÎÍÅÖ;
      e.T := sttypes[TSET]
    |stCHR:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      e.T := sttypes[TCHAR];
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        Assert(ASR(FLOOR(e1.Value), 8) = 0, line, col, 76);
        str2 := DECL.AddMono(CHR(FLOOR(e1.Value)));
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        e.T := sttypes[TSTRING];
        e.eType := eCONST
      ÊÎÍÅÖ
    |stLONG:
      pExpr(e1);
      Assert(e1.T.tType = TREAL, line, col, 71);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        e.Value := e1.Value;
        e.eType := eCONST
      ÊÎÍÅÖ;
      Load(e1);
      e.T := sttypes[TLONGREAL]
    |stSHORT:
      pExpr(e1);
      Assert(e1.T.tType = TLONGREAL, line, col, 70);
      ÅÑËÈ e1.eType = eCONST ÒÎÃÄÀ
        Assert(ABS(e1.Value) <= LONG(ìÊîíñò.âåù_ìàêñ), line, col, DECL.FOVER);
        Assert(ABS(e1.Value) >= LONG(ìÊîíñò.âåù_ìèí), line, col, DECL.UNDER);
        e.Value := e1.Value;
        e.eType := eCONST
      ÊÎÍÅÖ;
      Load(e1);
      e.T := sttypes[TREAL]
    |stLENGTH:
      pExpr(e1);
      Assert(IsString(e1), line, col, 141);
      ÅÑËÈ e1.T.tType = TSTRING ÒÎÃÄÀ
        str := DECL.Ñòð_Ïîëó÷(e1.Value);
        ÅÑËÈ str.Len = 1 ÒÎÃÄÀ
          X86.Mono(str.Number);
          X86.StrMono
        ÊÎÍÅÖ;
        e.Value := LONG(FLT(LENGTH(str.Str)));
        e.eType := eCONST
      ÊÎÍÅÖ;
      Str(e1);
      e.T := sttypes[TINTEGER];
      X86.StFunc(X86.stLENGTH)
    |sysADR:
      Assert((ìÑêàí.tLex = lxIDENT) ÈËÈ (ìÑêàí.tLex = lxSTRING) ÈËÈ (ìÑêàí.tLex = lxCHX), line, col, 43);
      ÅÑËÈ ìÑêàí.tLex = lxIDENT ÒÎÃÄÀ
        Designator(e1);
        Assert((e1.eType = eVAR) ÈËÈ (e1.eType = ePROC) ÈËÈ (e1.T = sttypes[TSTRING]), line, col, 43);
        ÅÑËÈ e1.eType = ePROC ÒÎÃÄÀ
          X86.PushInt(e1.id.Number)
        ÊÎÍÅÖ
      ÈÍÀ×Å
        pFactor(e1)
      ÊÎÍÅÖ;
      ÅÑËÈ e1.T = sttypes[TSTRING] ÒÎÃÄÀ
        str := DECL.Ñòð_Ïîëó÷(e1.Value);
        ÅÑËÈ str.Len = 1 ÒÎÃÄÀ
          X86.Drop;
          X86.PushInt(str.Number)
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      e.T := sttypes[TINTEGER];
      X86.ADR(DECL.Dim(e1.T))
    |sysBIT:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      X86.StFunc(X86.sysBIT);
      e.T := sttypes[TBOOLEAN]
    |sysSIZE, sysTYPEID:
      DECL.ÏðîöåäóðÐàçì_Óñò;
      Check(lxIDENT);
      T := DECL.IdType(line, col);
      Assert(T # ÏÓÑÒÎ, line, col, 42);
      e.eType := eCONST;
      e.T := sttypes[TINTEGER];
      ÅÑËÈ func = sysTYPEID ÒÎÃÄÀ
        Assert(T.tType IN {TRECORD, TPOINTER}, line, col, 47);
        ÅÑËÈ T.tType = TPOINTER ÒÎÃÄÀ
          T := T.Base
        ÊÎÍÅÖ;
        e.Value := LONG(FLT(T.Number));
        X86.PushConst(T.Number)
      ÈÍÀ×Å
        e.Value := LONG(FLT(T.Size));
        X86.PushConst(T.Size)
      ÊÎÍÅÖ
    ÈÍÀ×Å
      Assert(ËÎÆÜ, line2, col2, 73)
    ÊÎÍÅÖ;
    Check(lxRRound);
    Next
  ÊÎÍÅÖ StFunc;

ÏÐÎÖÅÄÓÐÀ ProcTypeComp(T1, T2: DECL.òóÒèï): BOOLEAN;
  ÏÅÐÅÌ
    sp: INTEGER;
    stk: ÌÀÑÑÈÂ 100, 2 ÈÇ DECL.òóÒèï;

    ÏÐÎÖÅÄÓÐÀ ProcTypeComp1(T1, T2: DECL.òóÒèï): BOOLEAN;
      ÏÅÐÅÌ
        fp, ft: DECL.òóÏîëå;
        Res: BOOLEAN;

      ÏÐÎÖÅÄÓÐÀ TypeComp(T1, T2: DECL.òóÒèï): BOOLEAN;
        ÏÅÐÅÌ
          Res: BOOLEAN;
        ÍÀ×ÀËÎ
          ÅÑËÈ (T1.tType = TARRAY) & (T2.tType = TARRAY) & (T1.Len = 0) & (T2.Len = 0) ÒÎÃÄÀ
            Res := TypeComp(T1.Base, T2.Base)
          ÈÍÀ×Å
            Res := ProcTypeComp1(T1, T2)
          ÊÎÍÅÖ
          ÂÅÐÍÓÒÜ Res
        ÊÎÍÅÖ TypeComp;

      ÏÐÎÖÅÄÓÐÀ Check(): BOOLEAN;
        ÏÅÐÅÌ
          i: INTEGER;
          res: BOOLEAN;
        ÍÀ×ÀËÎ
          i := 0;
          res := ËÎÆÜ;
          ÏÎÊÀ (i < sp) & ~res ÄÅËÀÒÜ
            res := ((stk[i][0] = T1) & (stk[i][1] = T2)) ÈËÈ ((stk[i][0] = T2) & (stk[i][1] = T1));
            INC(i)
          ÊÎÍÅÖ
          ÂÅÐÍÓÒÜ res
        ÊÎÍÅÖ Check;

      ÍÀ×ÀËÎ
        INC(sp);
        stk[sp][0] := T1;
        stk[sp][1] := T2;
        ÅÑËÈ Check() ÒÎÃÄÀ
          Res := ÈÑÒÈÍÀ
        ÈÍÀ×Å
          ÅÑËÈ (T1.tType = TPROC) & (T2.tType = TPROC) & (T1 # T2) ÒÎÃÄÀ
            Res := (T1.Call = T2.Call) & (T1.Fields.ñ÷åò÷èê = T2.Fields.ñ÷åò÷èê) & ProcTypeComp1(T1.Base, T2.Base);
            fp := T1.Fields.ïðåäûäóù(DECL.òóÏîëå);
            ft := T2.Fields.ïðåäûäóù(DECL.òóÏîëå);
            ÏÎÊÀ Res & (fp # ÏÓÑÒÎ) ÄÅËÀÒÜ
              Res := (fp.ByRef = ft.ByRef) & TypeComp(fp.T, ft.T);
              fp := fp.ñëåäóþù(DECL.òóÏîëå);
              ft := ft.ñëåäóþù(DECL.òóÏîëå)
            ÊÎÍÅÖ
          ÈÍÀ×Å
            Res := T1 = T2
          ÊÎÍÅÖ
        ÊÎÍÅÖ;
        DEC(sp)
        ÂÅÐÍÓÒÜ Res
      ÊÎÍÅÖ ProcTypeComp1;

  ÍÀ×ÀËÎ
    sp := -1
    ÂÅÐÍÓÒÜ ProcTypeComp1(T1, T2)
  ÊÎÍÅÖ ProcTypeComp;

ÏÐÎÖÅÄÓÐÀ ArrComp(Ta, Tf: DECL.òóÒèï): BOOLEAN;
  ÏÅÐÅÌ
    Res: BOOLEAN;
  ÍÀ×ÀËÎ
    ÅÑËÈ (Tf.tType = TARRAY) & (Tf.Len = 0) & (Ta.tType = TARRAY) ÒÎÃÄÀ
      Res := ArrComp(Ta.Base, Tf.Base)
    ÈÍÀ×Å
      Res := ProcTypeComp(Ta, Tf)
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ Res
  ÊÎÍÅÖ ArrComp;

ÏÐÎÖÅÄÓÐÀ AssComp(e: DECL.òÂûðàæåíèå; T: DECL.òóÒèï; param: BOOLEAN): BOOLEAN;
  ÏÅÐÅÌ
    Res: BOOLEAN;
  ÍÀ×ÀËÎ
    ÂÛÁÎÐ T.tType ÈÇ
    |TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN, TCARD16:
      Res := e.T = T
    |TCHAR:
      ÅÑËÈ e.T.tType = TSTRING ÒÎÃÄÀ
        Res := LenString(e.Value) = 1
      ÈÍÀ×Å
        Res := e.T.tType = TCHAR
      ÊÎÍÅÖ
    |TARRAY:
      ÅÑËÈ param ÒÎÃÄÀ
        ÅÑËÈ T.Len = 0 ÒÎÃÄÀ
          ÅÑËÈ (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) ÒÎÃÄÀ
            Res := ÈÑÒÈÍÀ
          ÈÍÀ×Å
            Res := ArrComp(e.T, T)
          ÊÎÍÅÖ
        ÈÍÀ×Å
          ÅÑËÈ (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) ÒÎÃÄÀ
            Res := LenString(e.Value) <= T.Len
          ÈÍÀ×Å
            Res := e.T = T
          ÊÎÍÅÖ
        ÊÎÍÅÖ
      ÈÍÀ×Å
        ÅÑËÈ T.Len = 0 ÒÎÃÄÀ
          Res := ËÎÆÜ
        ÀÅÑËÈ (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) ÒÎÃÄÀ
          Res := LenString(e.Value) <= T.Len
        ÈÍÀ×Å
          Res := e.T = T
        ÊÎÍÅÖ
      ÊÎÍÅÖ
    |TRECORD: Res := BaseOf(T, e.T)
    |TPOINTER: Res := BaseOf(T, e.T) ÈËÈ (e.T.tType = TNIL)
    |TPROC: Res := (e.T.tType = TNIL) ÈËÈ (e.eType = ePROC) & ProcTypeComp(e.id.T, T) ÈËÈ
      (e.eType # ePROC) & ProcTypeComp(e.T, T)
    ÈÍÀ×Å
      Res := ËÎÆÜ
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ Res
  ÊÎÍÅÖ AssComp;

ÏÐÎÖÅÄÓÐÀ ParamComp(e: DECL.òÂûðàæåíèå; T: DECL.òóÒèï; ByRef: BOOLEAN): BOOLEAN;
  ÏÅÐÅÌ
    Res: BOOLEAN;
  ÍÀ×ÀËÎ
    ÅÑËÈ ByRef ÒÎÃÄÀ
      ÅÑËÈ e.eType = eVAR ÒÎÃÄÀ
        ÂÛÁÎÐ T.tType ÈÇ
        |TINTEGER, TREAL, TLONGREAL, TCHAR,
         TSET, TBOOLEAN, TPOINTER, TCARD16:
          Res := e.T = T
        |TARRAY:
          ÅÑËÈ T.Len > 0 ÒÎÃÄÀ
            Res := e.T = T
          ÈÍÀ×Å
            Res := ArrComp(e.T, T)
          ÊÎÍÅÖ
        |TRECORD:
          Res := BaseOf(T, e.T)
        |TPROC:
          Res := ProcTypeComp(e.T, T)
        ÈÍÀ×Å
        ÊÎÍÅÖ
      ÈÍÀ×Å
        Res := ËÎÆÜ
      ÊÎÍÅÖ
    ÈÍÀ×Å
      Res := AssComp(e, T, ÈÑÒÈÍÀ)
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ Res
  ÊÎÍÅÖ ParamComp;

ÏÐÎÖÅÄÓÐÀ Call(param: DECL.òóÏîëå);
  ÏÅÐÅÌ
    line, col, i, n: INTEGER;
    e1: DECL.òÂûðàæåíèå;
    s: DECL.òóÊîíñòÑòð;
    A: X86.TIDX;
    TA: DECL.òóÒèï;
  ÍÀ×ÀËÎ
    ÏÎÊÀ param # ÏÓÑÒÎ ÄÅËÀÒÜ
      Coord(line, col);
      X86.Param;
      pExpr(e1);
      Assert(ParamComp(e1, param.T, param.ByRef), line, col, 114);
      Assert(~(param.ByRef & e1.Read), line, col, 115);
      Assert(~((e1.eType = ePROC) & (e1.id.Level > 3)), line, col, 116);
      ÅÑËÈ (e1.eType = eVAR) & ~param.ByRef ÒÎÃÄÀ
        X86.Load(e1.T.tType)
      ÊÎÍÅÖ;
      ÅÑËÈ param.ByRef & (e1.T.tType = TRECORD) ÒÎÃÄÀ
        ÅÑËÈ e1.vparam ÒÎÃÄÀ
          X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
          X86.Load(TINTEGER)
        ÀÅÑËÈ e1.deref ÒÎÃÄÀ
          X86.DerefType(0)
        ÈÍÀ×Å
          X86.PushConst(e1.T.Number)
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      ÅÑËÈ ~param.ByRef & (param.T.tType IN {TREAL, TLONGREAL}) ÒÎÃÄÀ
        X86.DropFpu(param.T.tType = TLONGREAL)
      ÊÎÍÅÖ;
      ÅÑËÈ (e1.T.tType = TSTRING) & (param.T.tType = TARRAY) ÒÎÃÄÀ
        s := DECL.Ñòð_Ïîëó÷(e1.Value);
        ÅÑËÈ s.Len = 1 ÒÎÃÄÀ
          X86.Mono(s.Number)
        ÊÎÍÅÖ;
        ÅÑËÈ param.T.Len = 0 ÒÎÃÄÀ
          A[0] := s.Len + 1;
          X86.OpenArray(A, 1)
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      ÅÑËÈ (e1.T.tType = TARRAY) & (DECL.Dim(param.T) > DECL.Dim(e1.T)) ÒÎÃÄÀ
        n := DECL.Dim(param.T) - DECL.Dim(e1.T);
        TA := DECL.OpenBase(e1.T);
        ÄËß i := 0 ÄÎ n - 1 ÄÅËÀÒÜ
          A[i] := TA.Len;
          TA := TA.Base
        ÊÎÍÅÖ;
        ÅÑËÈ DECL.Dim(e1.T) = 0 ÒÎÃÄÀ
          X86.OpenArray(A, n)
        ÈÍÀ×Å
          X86.ExtArray(A, n, DECL.Dim(e1.T))
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      param := param.ñëåäóþù(DECL.òóÏîëå);
      ÅÑËÈ param # ÏÓÑÒÎ ÒÎÃÄÀ
        Check(lxComma);
        Next
      ÊÎÍÅÖ
    ÊÎÍÅÖ;
    Check(lxRRound);
    Next
  ÊÎÍÅÖ Call;

ÏÐÎÖÅÄÓÐÀ Factor(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    line, col, ccall, p: INTEGER;
    begcall: X86.ASMLINE;
    s, str2: DECL.òóÊîíñòÑòð;
  ÍÀ×ÀËÎ
    e.eType := eCONST;
    e.vparam := ËÎÆÜ;
    ÂÛÁÎÐ ìÑêàí.tLex ÈÇ
    |lxIDENT:
      begcall := X86.current;
      Designator(e);
      ÅÑËÈ e.eType = ePROC ÒÎÃÄÀ
        ÅÑËÈ ìÑêàí.tLex = lxLRound ÒÎÃÄÀ
          Assert2(e.id.T.Base.tType # TVOID, 73);
          Next;
          X86.PushCall(begcall);
          Call(e.id.T.Fields.ïðåäûäóù(DECL.òóÏîëå));
          X86.EndCall;
          e.eType := eEXP;
          e.T := e.id.T.Base;
          ÅÑËÈ e.id.Level = 3 ÒÎÃÄÀ
            ccall := 0
          ÀÅÑËÈ e.id.Level > DECL.curBlock.Level ÒÎÃÄÀ
            ccall := 1
          ÈÍÀ×Å
            ccall := 2
          ÊÎÍÅÖ;
          X86.Call(e.id.Number, ÈÑÒÈÍÀ, e.T.tType IN {TREAL, TLONGREAL}, e.id.T.Call, ccall, e.id.Level - 3,
            DECL.curBlock.Level - 3, e.id.ParamSize, DECL.curBlock.LocalSize)
        ÈÍÀ×Å
          X86.PushInt(e.id.Number)
        ÊÎÍÅÖ
      ÀÅÑËÈ (e.eType = eVAR) & (e.T.tType = TPROC) & (ìÑêàí.tLex = lxLRound) ÒÎÃÄÀ
        Assert2(e.T.Base.tType # TVOID, 73);
        Next;
        X86.PushCall(begcall);
        Call(e.T.Fields.ïðåäûäóù(DECL.òóÏîëå));
        X86.EndCall;
        e.eType := eEXP;
        X86.CallVar(ÈÑÒÈÍÀ, e.T.Base.tType IN {TREAL, TLONGREAL}, e.T.Call, e.T.Len, DECL.curBlock.LocalSize);
        e.T := e.T.Base;
      ÀÅÑËÈ e.eType IN {eSTPROC, eSYSPROC} ÒÎÃÄÀ
        StFunc(e, e.id.StProc)
      ÊÎÍÅÖ
    |ìÊîíñò.êñÏÓÑÒÎ:
      e.T := sttypes[TNIL];
      e.Value := 0.0D0;
      X86.PushConst(0);
      Next
    |ìÊîíñò.êñÈÑÒÈÍÀ:
      e.T := sttypes[TBOOLEAN];
      e.Value := 1.0D0;
      X86.PushConst(1);
      Next
    |ìÊîíñò.êñËÎÆÜ:
      e.T := sttypes[TBOOLEAN];
      e.Value := 0.0D0;
      X86.PushConst(0);
      Next
    |lxCHX, lxSTRING:
      ÅÑËÈ ìÑêàí.tLex = lxSTRING ÒÎÃÄÀ
        ìÑêàí.GetLexStr(Lex);
        str2 := DECL.Ñòð_Ñîçäàòü(Lex);
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        s := DECL.Ñòð_Ïîëó÷(e.Value);
        ÅÑËÈ s.Len = 1 ÒÎÃÄÀ
          X86.PushConst(ORD(s.Str[0]))
        ÈÍÀ×Å
          X86.PushInt(s.Number)
        ÊÎÍÅÖ
      ÈÍÀ×Å
        str2 := DECL.AddMono(ìÑêàí.vCHX);
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        X86.PushConst(ORD(ìÑêàí.vCHX))
      ÊÎÍÅÖ;
      e.T := sttypes[TSTRING];
      Next
    |lxREAL:
      e.T := sttypes[TREAL];
      e.Value := ìÑêàí.vFLT;
      X86.PushFlt(ìÑêàí.vFLT);
      Next
    |lxLONGREAL:
      e.T := sttypes[TLONGREAL];
      e.Value := ìÑêàí.vFLT;
      X86.PushFlt(ìÑêàí.vFLT);
      Next
    |lxINT, lxHEX:
      e.T := sttypes[TINTEGER];
      e.Value := LONG(FLT(ìÑêàí.vINT));
      X86.PushConst(ìÑêàí.vINT);
      Next
    |lxLRound:
      Next;
      pExpr(e);
      Check(lxRRound);
      Next
    |lxNot:
      Next;
      Coord(line, col);
      Factor(e);
      Assert(e.T.tType = TBOOLEAN, line, col, 37);
      Load(e);
      ÅÑËÈ e.eType = eCONST ÒÎÃÄÀ
        e.Value := LONG(FLT(ORD(e.Value = 0.0D0)))
      ÈÍÀ×Å
        e.eType := eEXP
      ÊÎÍÅÖ;
      X86.Not;
      e.vparam := ËÎÆÜ
    |lxLCurly:
      Set(e)
    ÈÍÀ×Å
      Assert2(ËÎÆÜ, 36)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Factor;

ÏÐÎÖÅÄÓÐÀ IsChr(a: DECL.òÂûðàæåíèå): BOOLEAN;
    ÂÅÐÍÓÒÜ (a.T.tType = TSTRING) & (LenString(a.Value) = 1) ÈËÈ (a.T.tType = TCHAR)
  ÊÎÍÅÖ IsChr;

ÏÐÎÖÅÄÓÐÀ StrRel(a, b: DECL.òÂûðàæåíèå; Op: INTEGER);
  ÍÀ×ÀËÎ
    ÅÑËÈ ~(IsChr(a) ÈËÈ IsChr(b)) ÒÎÃÄÀ
      X86.strcmp(Op, 0)
    ÀÅÑËÈ IsChr(a) & IsChr(b) ÒÎÃÄÀ
      X86.CmpInt(Op)
    ÀÅÑËÈ IsChr(a) ÒÎÃÄÀ
      X86.strcmp(Op, 1)
    ÈÍÀ×Å
      X86.strcmp(Op, -1)
    ÊÎÍÅÖ
  ÊÎÍÅÖ StrRel;

ÏÐÎÖÅÄÓÐÀ log2(n: INTEGER): INTEGER;
  ÏÅÐÅÌ x, i: INTEGER;
  ÍÀ×ÀËÎ
    x := 1;
    i := 0;
    ÏÎÊÀ (x # n) & (i < 31) ÄÅËÀÒÜ
      x := LSL(x, 1);
      INC(i)
    ÊÎÍÅÖ;
    ÅÑËÈ x # n ÒÎÃÄÀ
      i := -1
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ i
  ÊÎÍÅÖ log2;

ÏÐÎÖÅÄÓÐÀ Operation(ÏÅÐ a, b: DECL.òÂûðàæåíèå; Op, line, col: INTEGER);
  ÏÅÐÅÌ n, m: INTEGER;
  ÍÀ×ÀËÎ
    ÂÛÁÎÐ Op ÈÇ
    |lxPlus, lxMinus, lxMult, lxSlash:
      Assert((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}) & (a.T.tType = b.T.tType), line, col, 37);
      Assert(~((Op = lxSlash) & (a.T.tType = TINTEGER)), line, col, 37);
      ÂÛÁÎÐ a.T.tType ÈÇ
      |TINTEGER: X86.Int(Op)
      |TSET: X86.Set(Op)
      |TREAL, TLONGREAL: X86.farith(Op)
      ÈÍÀ×Å
      ÊÎÍÅÖ
    |lxDIV, lxMOD:
      Assert((a.T.tType = TINTEGER) & (b.T.tType = TINTEGER), line, col, 37);
      ÅÑËÈ b.eType = eCONST ÒÎÃÄÀ
        m := FLOOR(b.Value);
        Assert(m # 0, line, col, 48);
        n := log2(m);
        ÅÑËÈ n = -1 ÒÎÃÄÀ
          X86.idivmod(Op = lxMOD)
        ÈÍÀ×Å
          X86.Drop;
          ÅÑËÈ Op = lxMOD ÒÎÃÄÀ
            n := ORD(-BITS(LSL(-1, n)));
            X86.PushConst(n);
            X86.Set(lxMult)
          ÈÍÀ×Å
            X86.PushConst(n);
            X86.StFunc(X86.stASR)
          ÊÎÍÅÖ
        ÊÎÍÅÖ
      ÈÍÀ×Å
        X86.idivmod(Op = lxMOD)
      ÊÎÍÅÖ
    |lxAnd, ìÊîíñò.lxOR:
      Assert((a.T.tType = TBOOLEAN) & (b.T.tType = TBOOLEAN), line, col, 37)
    |ìÊîíñò.êñÂ:
      Assert((a.T.tType = TINTEGER) & (b.T.tType = TSET), line, col, 37);
      X86.inset
    |lxLT, lxLE, lxGT, lxGE:
      Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL}) & (a.T.tType = b.T.tType)) ÈËÈ
        (IsChr(a) ÈËÈ IsString(a)) & (IsChr(b) ÈËÈ IsString(b)) ÈËÈ
        (a.T.tType = TSET) & (b.T.tType = TSET) & ((Op = lxLE) ÈËÈ (Op = lxGE)), line, col, 37);
      ÅÑËÈ a.T.tType IN {TREAL, TLONGREAL} ÒÎÃÄÀ
        X86.fcmp(Op)
      ÀÅÑËÈ a.T.tType = TSET ÒÎÃÄÀ
        X86.Inclusion(Op)
      ÀÅÑËÈ IsString(a) ÈËÈ IsString(b) ÒÎÃÄÀ
        StrRel(a, b, Op)
      ÈÍÀ×Å
        X86.CmpInt(Op)
      ÊÎÍÅÖ
    |lxEQ, lxNE:
      Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN}) & (a.T.tType = b.T.tType)) ÈËÈ
        (IsChr(a) ÈËÈ IsString(a)) & (IsChr(b) ÈËÈ IsString(b)) ÈËÈ
        (a.T.tType IN {TPOINTER, TPROC, TNIL}) & (b.T.tType = TNIL) ÈËÈ
        (b.T.tType IN {TPOINTER, TPROC, TNIL}) & (a.T.tType = TNIL) ÈËÈ
        (a.T.tType = TPOINTER) & (b.T.tType = TPOINTER) & (BaseOf(a.T, b.T) ÈËÈ BaseOf(b.T, a.T)) ÈËÈ
        (a.T.tType = TPROC) & ProcTypeComp(b.T, a.T) ÈËÈ (a.eType = ePROC) & ProcTypeComp(b.T, a.id.T) ÈËÈ
        (b.eType = ePROC) & ProcTypeComp(a.T, b.id.T), line, col, 37);
      ÅÑËÈ a.T.tType IN {TREAL, TLONGREAL} ÒÎÃÄÀ
        X86.fcmp(Op)
      ÀÅÑËÈ IsString(a) ÈËÈ IsString(b) ÒÎÃÄÀ
        StrRel(a, b, Op)
      ÈÍÀ×Å
        X86.CmpInt(Op)
      ÊÎÍÅÖ
    ÈÍÀ×Å
    ÊÎÍÅÖ;
    ÅÑËÈ (a.eType # eCONST) ÈËÈ (b.eType # eCONST) ÒÎÃÄÀ
      a.eType := eEXP;
      ÅÑËÈ DECL.Relation(Op) ÒÎÃÄÀ
        a.T := sttypes[TBOOLEAN]
      ÊÎÍÅÖ
    ÈÍÀ×Å
      DECL.Calc(a.Value, b.Value, a.T, b.T, Op, line, col, a.Value, a.T)
    ÊÎÍÅÖ;
    a.vparam := ËÎÆÜ
  ÊÎÍÅÖ Operation;

ÏÐÎÖÅÄÓÐÀ Term(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    a: DECL.òÂûðàæåíèå;
    Op, line, col, L: INTEGER;
  ÍÀ×ÀËÎ
    Factor(e);
    ÏÎÊÀ (ìÑêàí.tLex = lxMult) ÈËÈ (ìÑêàí.tLex = lxSlash) ÈËÈ
      (ìÑêàí.tLex = lxDIV) ÈËÈ (ìÑêàí.tLex = lxMOD) ÈËÈ
       (ìÑêàí.tLex = lxAnd) ÄÅËÀÒÜ
      Load(e);
      Coord(line, col);
      Op := ìÑêàí.tLex;
      Next;
      ÅÑËÈ Op = lxAnd ÒÎÃÄÀ
        L := X86.NewLabel();
        X86.IfWhile(L, ËÎÆÜ)
      ÊÎÍÅÖ;
      Factor(a);
      Load(a);
      ÅÑËÈ Op = lxAnd ÒÎÃÄÀ
        X86.Label(L)
      ÊÎÍÅÖ;
      Operation(e, a, Op, line, col)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Term;

ÏÐÎÖÅÄÓÐÀ Simple(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    a: DECL.òÂûðàæåíèå;
    Op, line, col, uOp, uline, ucol, L: INTEGER;
  ÍÀ×ÀËÎ
    uOp := 0;
    ÅÑËÈ (ìÑêàí.tLex = lxPlus) ÈËÈ (ìÑêàí.tLex = lxMinus) ÒÎÃÄÀ
      Coord(uline, ucol);
      uOp := ìÑêàí.tLex;
      Next
    ÊÎÍÅÖ;
    Term(e);
    ÅÑËÈ uOp # 0 ÒÎÃÄÀ
      Assert(e.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}, uline, ucol, 37);
      Load(e);
      ÅÑËÈ uOp = lxMinus ÒÎÃÄÀ
        ÂÛÁÎÐ e.T.tType ÈÇ
        |TINTEGER: X86.NegInt
        |TSET: X86.NegSet
        |TREAL, TLONGREAL: X86.fneg
        ÈÍÀ×Å
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      ÅÑËÈ (uOp = lxMinus) & (e.eType = eCONST) ÒÎÃÄÀ
        ÂÛÁÎÐ e.T.tType ÈÇ
        |TINTEGER:
          Assert(e.Value # LONG(FLT(ìÊîíñò.öåëîå_ìèí)), uline, ucol, DECL.IOVER)
        |TSET:
          e.Value := -LONG(FLT(ORD(-BITS(FLOOR(e.Value)))))
        ÈÍÀ×Å
        ÊÎÍÅÖ;
        e.Value := -e.Value
      ÊÎÍÅÖ;
      ÅÑËÈ e.eType # eCONST ÒÎÃÄÀ
        e.eType := eEXP
      ÊÎÍÅÖ;
      e.vparam := ËÎÆÜ
    ÊÎÍÅÖ;
    ÏÎÊÀ (ìÑêàí.tLex = lxPlus) ÈËÈ (ìÑêàí.tLex = lxMinus) ÈËÈ (ìÑêàí.tLex = ìÊîíñò.lxOR) ÄÅËÀÒÜ
      Load(e);
      Coord(line, col);
      Op := ìÑêàí.tLex;
      Next;
      ÅÑËÈ Op = ìÊîíñò.lxOR ÒÎÃÄÀ
        L := X86.NewLabel();
        X86.IfWhile(L, ÈÑÒÈÍÀ)
      ÊÎÍÅÖ;
      Term(a);
      Load(a);
      ÅÑËÈ Op = ìÊîíñò.lxOR ÒÎÃÄÀ
        X86.Label(L)
      ÊÎÍÅÖ;
      Operation(e, a, Op, line, col)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Simple;

ÏÐÎÖÅÄÓÐÀ Expr(ÏÅÐ e: DECL.òÂûðàæåíèå);
  ÏÅÐÅÌ
    a: DECL.òÂûðàæåíèå;
    Op, line, col, line2, col2, fpu: INTEGER;
    T: DECL.òóÒèï;
    beg: X86.ASMLINE;
    s: DECL.òóÊîíñòÑòð;
  ÍÀ×ÀËÎ
    fpu := X86.fpu;
    beg := X86.current;
    Simple(e);
    ÅÑËÈ DECL.Relation(ìÑêàí.tLex) ÒÎÃÄÀ
      Coord(line, col);
      Op := ìÑêàí.tLex;
      Next;
      ÅÑËÈ Op = ìÊîíñò.êñÅÑÒÜ ÒÎÃÄÀ
        Assert(e.T.tType IN {TRECORD, TPOINTER}, line, col, 37);
        ÅÑËÈ e.T.tType = TRECORD ÒÎÃÄÀ
          Assert(e.vparam, line, col, 37)
        ÊÎÍÅÖ;
        Check(lxIDENT);
        Coord(line2, col2);
        T := DECL.IdType(line2, col2);
        Assert(T # ÏÓÑÒÎ, line2, col2, 42);
        ÅÑËÈ e.T.tType = TRECORD ÒÎÃÄÀ
          Assert(T.tType = TRECORD, line2, col2, 106)
        ÈÍÀ×Å
          Assert(T.tType = TPOINTER, line2, col2, 107)
        ÊÎÍÅÖ;
        Assert(BaseOf(e.T, T), line, col, 37);
        ÅÑËÈ e.T.tType = TRECORD ÒÎÃÄÀ
          X86.Drop;
          X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
        ÊÎÍÅÖ;
        Load(e);
        ÅÑËÈ e.T.tType = TPOINTER ÒÎÃÄÀ
          T := T.Base
        ÊÎÍÅÖ;
        X86.Guard(T.Number, ÈÑÒÈÍÀ);
        e.T := sttypes[TBOOLEAN];
        e.eType := eEXP;
        e.vparam := ËÎÆÜ
      ÈÍÀ×Å
        Load(e);
        Str(e);
        Simple(a);
        Load(a);
        Str(a);
        Operation(e, a, Op, line, col)
      ÊÎÍÅÖ
    ÊÎÍÅÖ;
    ÅÑËÈ e.eType = eCONST ÒÎÃÄÀ
      X86.Del(beg);
      X86.Setfpu(fpu);
      ÅÑËÈ ~DECL.Const ÒÎÃÄÀ
        ÂÛÁÎÐ e.T.tType ÈÇ
        |TREAL, TLONGREAL:
          X86.PushFlt(e.Value)
        |TINTEGER, TSET, TBOOLEAN, TNIL:
          X86.PushConst(FLOOR(e.Value))
        |TSTRING:
          s := DECL.Ñòð_Ïîëó÷(e.Value);
          ÅÑËÈ s.Len = 1 ÒÎÃÄÀ
            X86.PushConst(ORD(s.Str[0]))
          ÈÍÀ×Å
            X86.PushInt(s.Number)
          ÊÎÍÅÖ
        ÈÍÀ×Å
        ÊÎÍÅÖ
      ÊÎÍÅÖ
    ÊÎÍÅÖ
  ÊÎÍÅÖ Expr;

ÏÐÎÖÅÄÓÐÀ IfWhileOper(wh: BOOLEAN);
  ÏÅÐÅÌ
    e: DECL.òÂûðàæåíèå;
    line, col, L, L3: INTEGER;
  ÍÀ×ÀËÎ
    L := X86.NewLabel();
    ÅÑËÈ wh ÒÎÃÄÀ
      X86.Label(L)
    ÊÎÍÅÖ;
    ÏÎÂÒÎÐßÒÜ
      Next;
      Coord(line, col);
      Expr(e);
      Assert(e.T.tType = TBOOLEAN, line, col, 117);
      Load(e);
      ÅÑËÈ wh ÒÎÃÄÀ
        Check(ìÊîíñò.êñÄÅËÀÒÜ)
      ÈÍÀ×Å
        Check(ìÊîíñò.êñÒÎÃÄÀ)
      ÊÎÍÅÖ;
      L3 := X86.NewLabel();
      X86.ifwh(L3);
      Next;
      pOpSeq;
      X86.jmp(X86.JMP, L);
      X86.Label(L3)
    ÏÎÊÀÍÅ ìÑêàí.tLex # ìÊîíñò.êñÀÅÑËÈ;
    ÅÑËÈ ~wh & (ìÑêàí.tLex = ìÊîíñò.êñÈÍÀ×Å) ÒÎÃÄÀ
      Next;
      pOpSeq
    ÊÎÍÅÖ;
    Check(ìÊîíñò.êñÊÎÍÅÖ);
    ÅÑËÈ ~wh ÒÎÃÄÀ
      X86.Label(L)
    ÊÎÍÅÖ;
    Next
  ÊÎÍÅÖ IfWhileOper;

ÏÐÎÖÅÄÓÐÀ RepeatOper;
  ÏÅÐÅÌ
    e: DECL.òÂûðàæåíèå;
    line, col, L: INTEGER;
  ÍÀ×ÀËÎ
    Next;
    L := X86.NewLabel();
    X86.Label(L);
    pOpSeq;
    Check(ìÊîíñò.êñÏÎÊÀÍÅ);
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType = TBOOLEAN, line, col, 117);
    Load(e);
    X86.ifwh(L)
  ÊÎÍÅÖ RepeatOper;

ÏÐÎÖÅÄÓÐÀ ForOper;
  ÏÅÐÅÌ
    e: DECL.òÂûðàæåíèå;
    line, col, LBeg, LEnd, iValue: INTEGER;
    Value: LONGREAL;
    T: DECL.òóÒèï;
    name: ìÒèïû.òóÓçåë;
    id: DECL.òóÈìÿ;
  ÍÀ×ÀËÎ
    Next;
    Check(lxIDENT);
    name := ìÑêàí.id;
    id := DECL.GetIdent(name);
    Assert2(id # ÏÓÑÒÎ, 42);
    Assert2(id.iType = IDVAR, 126);
    Assert2(id.VarKind = 0, 127);
    Assert2(id.T.tType = TINTEGER, 128);
    Assert2(id.Level = DECL.unit.Level, 129);
    Next;
    Check(lxAssign);
    Next;
    Coord(line, col);
    ÅÑËÈ id.Level = 3 ÒÎÃÄÀ
      X86.GlobalAdr(id.Offset)
    ÈÍÀ×Å
      X86.LocalAdr(id.Offset, 0)
    ÊÎÍÅÖ;
    X86.Dup;
    Expr(e);
    Assert(e.T.tType = TINTEGER, line, col, 52);
    Load(e);
    X86.Save(TINTEGER);
    Check(ìÊîíñò.êñÄÎ);
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType = TINTEGER, line, col, 52);
    Load(e);
    iValue := 1;
    ÅÑËÈ ìÑêàí.tLex = lxBY ÒÎÃÄÀ
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      iValue := FLOOR(Value);
      Assert(iValue # 0, line, col, 122)
    ÊÎÍÅÖ;
    Check(ìÊîíñò.êñÄÅËÀÒÜ);
    Next;
    X86.For(iValue > 0, LBeg, LEnd);
    pOpSeq;
    X86.NextFor(iValue, LBeg, LEnd);
    Check(ìÊîíñò.êñÊÎÍÅÖ);
    Next
  ÊÎÍÅÖ ForOper;

ÏÐÎÖÅÄÓÐÀ CheckLabel(a, b: INTEGER; Labels: ìÒèïû.òóÑïèñîê): BOOLEAN;
  ÏÅÐÅÌ cur: LABEL;
  ÍÀ×ÀËÎ
    cur := Labels.ïðåäûäóù(LABEL);
    ÏÎÊÀ (cur # ÏÓÑÒÎ) & ((b < cur.a) ÈËÈ (a > cur.b)) ÄÅËÀÒÜ
      cur := cur.ñëåäóþù(LABEL)
    ÊÎÍÅÖ
    ÂÅÐÍÓÒÜ cur = ÏÓÑÒÎ
  ÊÎÍÅÖ CheckLabel;

ÏÐÎÖÅÄÓÐÀ LabelVal(ÏÅÐ a: INTEGER; int: BOOLEAN);
  ÏÅÐÅÌ
    Value: LONGREAL;
    T: DECL.òóÒèï;
    s: DECL.òóÊîíñòÑòð;
    line, col: INTEGER;
  ÍÀ×ÀËÎ
    Coord(line, col);
    DECL.ConstExpr(Value, T);
    ÅÑËÈ int ÒÎÃÄÀ
      Assert(T.tType = TINTEGER, line, col, 161);
      a := FLOOR(Value)
    ÈÍÀ×Å
      Assert(T.tType = TSTRING, line, col, 55);
      s := DECL.Ñòð_Ïîëó÷(Value);
      Assert(s.Len = 1, line, col, 94);
      a := ORD(s.Str[0])
    ÊÎÍÅÖ
  ÊÎÍÅÖ LabelVal;

ÏÐÎÖÅÄÓÐÀ Label(int: BOOLEAN; Labels: ìÒèïû.òóÑïèñîê; LBeg: INTEGER);
  ÏÅÐÅÌ a, b: INTEGER; label: LABEL; line, col: INTEGER;
  ÍÀ×ÀËÎ
    Coord(line, col);
    LabelVal(a, int);
    b := a;
    ÅÑËÈ ìÑêàí.tLex = lxDbl ÒÎÃÄÀ
      Next;
      LabelVal(b, int)
    ÊÎÍÅÖ;
    Assert(a <= b, line, col, 54);
    Assert(CheckLabel(a, b, Labels), line, col, 100);
    NEW(label);
    DECL.ÏàìÎø_Ïðîâåðèòü(label = ÏÓÑÒÎ);
    label.a := a;
    label.b := b;
    ìÑïèñ.Äîáàâèòü(Labels, label);
    X86.CaseLabel(a, b, LBeg)
  ÊÎÍÅÖ Label;

ÏÐÎÖÅÄÓÐÀ Variant(int: BOOLEAN; Labels: ìÒèïû.òóÑïèñîê; EndCase: INTEGER);
  ÏÅÐÅÌ LBeg, LEnd: INTEGER;
  ÍÀ×ÀËÎ
    LBeg := X86.NewLabel();
    LEnd := X86.NewLabel();
    ÅÑËÈ ~((ìÑêàí.tLex = lxStick) ÈËÈ (ìÑêàí.tLex = ìÊîíñò.êñÊÎÍÅÖ)) ÒÎÃÄÀ
      Label(int, Labels, LBeg);
      ÏÎÊÀ ìÑêàí.tLex = lxComma ÄÅËÀÒÜ
        Next;
        Label(int, Labels, LBeg)
      ÊÎÍÅÖ;
      Check(lxColon);
      Next;
      X86.jmp(X86.JMP, LEnd);
      X86.Label(LBeg);
      pOpSeq;
      X86.jmp(X86.JMP, EndCase);
      X86.Label(LEnd)
    ÊÎÍÅÖ
  ÊÎÍÅÖ Variant;

ÏÐÎÖÅÄÓÐÀ CaseOper;
  ÏÅÐÅÌ
    e: DECL.òÂûðàæåíèå;
    int: BOOLEAN;
    line, col, EndCase: INTEGER;
    Labels: ìÒèïû.òóÑïèñîê;
  ÍÀ×ÀËÎ
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType IN {TCHAR, TSTRING, TINTEGER}, line, col, 156);
    Assert(~((e.T.tType = TSTRING) & (LenString(e.Value) # 1)), line, col, 94);
    int := e.T.tType = TINTEGER;
    Check(ìÊîíñò.êñÈÇ);
    Load(e);
    X86.Drop;
    Labels := ìÑïèñ.Ñîçäàòü();
    DECL.ÏàìÎø_Ïðîâåðèòü(Labels = ÏÓÑÒÎ);
    Next;
    EndCase := X86.NewLabel();
    Variant(int, Labels, EndCase);
    ÏÎÊÀ ìÑêàí.tLex = lxStick ÄÅËÀÒÜ
      Next;
      Variant(int, Labels, EndCase)
    ÊÎÍÅÖ;
    ÅÑËÈ ìÑêàí.tLex = ìÊîíñò.êñÈÍÀ×Å ÒÎÃÄÀ
      Next;
      pOpSeq
    ÈÍÀ×Å
      ìÓòèëü.ÊîäÑòðîêà_Óñò(DECL.UnitNumber, ìÑêàí.line);
      X86.OnError(7)
    ÊÎÍÅÖ;
    Check(ìÊîíñò.êñÊÎÍÅÖ);
    X86.Label(EndCase);
    Next;
    ìÑïèñ.Î÷èñòèòü(Labels)
  ÊÎÍÅÖ CaseOper;

ÏÐÎÖÅÄÓÐÀ CheckCode(Code: ìÑòð.òÑòðîêà; Len, line, col: INTEGER);
  ÏÅÐÅÌ i: INTEGER;
  ÍÀ×ÀËÎ
    Assert(~ODD(Len), line, col, 34);
    ÄËß i := 0 ÄÎ Len - 1 ÄÅËÀÒÜ
      Assert(ìÑêàí.×èñëî16_Ïîëó÷(Code[i]), line, col, 34)
    ÊÎÍÅÖ
  ÊÎÍÅÖ CheckCode;

ÏÐÎÖÅÄÓÐÀ StProc(proc: INTEGER);
  ÏÅÐÅÌ
    line, col, line2, col2, iValue: INTEGER;
    e1, e2: DECL.òÂûðàæåíèå;
    Value: LONGREAL;
    T: DECL.òóÒèï;
    str: DECL.òóÊîíñòÑòð;
    begcall: X86.ASMLINE;
  ÍÀ×ÀËÎ
    Coord(line2, col2);
    Check(lxLRound);
    Next;
    Coord(line, col);
    ÂÛÁÎÐ proc ÈÇ
    |stINC, stDEC:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TINTEGER, line, col, 128);
      ÅÑËÈ ìÑêàí.tLex = lxComma ÒÎÃÄÀ
        Next;
        Coord(line, col);
        DECL.ConstExpr(Value, T);
        Assert(T.tType = TINTEGER, line, col, 52);
        iValue := FLOOR(Value);
        Assert(iValue # 0, line, col, 122);
        ÅÑËÈ iValue < 0 ÒÎÃÄÀ
          ÅÑËÈ proc = stINC ÒÎÃÄÀ
            proc := stDEC
          ÈÍÀ×Å
            proc := stINC
          ÊÎÍÅÖ;
          iValue := -iValue
        ÊÎÍÅÖ;
        ÅÑËÈ iValue # 1 ÒÎÃÄÀ
          X86.PushConst(iValue);
          ÅÑËÈ proc = stDEC ÒÎÃÄÀ
            X86.StProc(X86.stDEC)
          ÈÍÀ×Å
            X86.StProc(X86.stINC)
          ÊÎÍÅÖ
        ÈÍÀ×Å
          ÅÑËÈ proc = stDEC ÒÎÃÄÀ
            X86.StProc(X86.stDEC1)
          ÈÍÀ×Å
            X86.StProc(X86.stINC1)
          ÊÎÍÅÖ
        ÊÎÍÅÖ
      ÈÍÀ×Å
        ÅÑËÈ proc = stDEC ÒÎÃÄÀ
          X86.StProc(X86.stDEC1)
        ÈÍÀ×Å
          X86.StProc(X86.stINC1)
        ÊÎÍÅÖ
      ÊÎÍÅÖ
    |stINCL, stEXCL:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TSET, line, col, 138);
      Check(lxComma);
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      iValue := FLOOR(Value);
      Assert(ASR(iValue, 5) = 0, line, col, 53);
      ÅÑËÈ proc = stINCL ÒÎÃÄÀ
        X86.PushConst(ORD({iValue}));
        X86.StProc(X86.stINCL)
      ÈÍÀ×Å
        X86.PushConst(ORD(-{iValue}));
        X86.StProc(X86.stEXCL)
      ÊÎÍÅÖ
    |stCOPY:
      Expr(e1);
      Assert(IsString(e1), line, col, 141);
      Check(lxComma);
      ÅÑËÈ e1.T.tType = TSTRING ÒÎÃÄÀ
        str := DECL.Ñòð_Ïîëó÷(e1.Value);
        ÅÑËÈ str.Len = 1 ÒÎÃÄÀ
          X86.Mono(str.Number);
          X86.StrMono
        ÊÎÍÅÖ
      ÊÎÍÅÖ;
      Str(e1);
      Next;
      Coord(line, col);
      Designator(e2);
      Assert(e2.eType = eVAR, line, col, 63);
      Assert(IsString(e2), line, col, 143);
      Assert(~e2.Read, line, col, 115);
      Str(e2);
      X86.StProc(X86.stCOPY)
    |stNEW, stDISPOSE:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TPOINTER, line, col, 145);
      ÅÑËÈ proc = stNEW ÒÎÃÄÀ
        X86.PushConst(e1.T.Base.Number);
        X86.PushConst(X86.Align(e1.T.Base.Size + 8, 32));
        X86.newrec
      ÈÍÀ×Å
        X86.disprec
      ÊÎÍÅÖ
    |stASSERT:
      Expr(e1);
      Assert(e1.T.tType = TBOOLEAN, line, col, 117);
      Load(e1);
      ÅÑËÈ ìÑêàí.tLex = lxComma ÒÎÃÄÀ
        Next;
        Coord(line, col);
        DECL.ConstExpr(Value, T);
        Assert(T.tType = TINTEGER, line, col, 52);
        Assert((Value >= 0.0D0) & (Value <= 127.0D0), line, col, 95);
        X86.Assert(X86.stASSERT, FLOOR(Value))
      ÈÍÀ×Å
        X86.Assert(X86.stASSERT1, 0)
      ÊÎÍÅÖ
    |stPACK, stUNPK:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 149);
      Assert(~e1.Read, line, col, 115);
      Check(lxComma);
      Next;
      Coord(line, col);
      ÅÑËÈ proc = stUNPK ÒÎÃÄÀ
        Designator(e2);
        Assert(e2.eType = eVAR, line, col, 63);
        Assert(e2.T.tType = TINTEGER, line, col, 128);
        Assert(~e2.Read, line, col, 115);
        ÅÑËÈ e1.T.tType = TLONGREAL ÒÎÃÄÀ
          X86.StProc(X86.stUNPK)
        ÈÍÀ×Å
          X86.StProc(X86.stUNPK1)
        ÊÎÍÅÖ
      ÈÍÀ×Å
        Expr(e2);
        Assert(e2.T.tType = TINTEGER, line, col, 52);
        Load(e2);
        ÅÑËÈ e1.T.tType = TLONGREAL ÒÎÃÄÀ
          X86.StProc(X86.stPACK)
        ÈÍÀ×Å
          X86.StProc(X86.stPACK1)
        ÊÎÍÅÖ
      ÊÎÍÅÖ
    |sysBIT:
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1)
    |sysPUT, sysGET:
      begcall := X86.current;
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      ÅÑËÈ proc = sysGET ÒÎÃÄÀ
        X86.PushCall(begcall);
        X86.Param;
        Designator(e2);
        Assert(e2.eType = eVAR, line, col, 63);
        Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16}, line, col, 154);
        Assert(~e2.Read, line, col, 115);
        X86.EndCall;
        X86.Load(e2.T.tType);
        X86.Save(e2.T.tType)
      ÈÍÀ×Å
        Expr(e2);
        Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16, TSTRING}, line, col, 153);
        ÅÑËÈ e2.T.tType = TSTRING ÒÎÃÄÀ
          Assert(LenString(e2.Value) = 1, line, col, 94)
        ÊÎÍÅÖ;
        Load(e2);
        X86.Save(e2.T.tType)
      ÊÎÍÅÖ
    |sysCODE:
      Assert(ìÑêàí.tLex = lxSTRING, line, col, 150);
      ìÑêàí.GetLexStr(Lex);
      CheckCode(Lex, ìÑêàí.count - 1, line, col);
      X86.Asm(Lex);
      Next
    |sysMOVE:
      begcall := X86.current;
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      X86.PushCall(begcall);
      X86.Param;
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      X86.EndCall;
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
    ÈÍÀ×Å
      Assert(ËÎÆÜ, line2, col2, 132)
    ÊÎÍÅÖ;
    Check(lxRRound);
    Next;
    ÅÑËÈ proc = sysMOVE ÒÎÃÄÀ
      X86.StProc(X86.sysMOVE);
    ÀÅÑËÈ proc = sysBIT ÒÎÃÄÀ
      Check(lxAssign);
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TBOOLEAN, line, col, 117);
      Load(e1);
      X86.StProc(X86.sysBIT)
    ÊÎÍÅÖ
  ÊÎÍÅÖ StProc;

ÏÐÎÖÅÄÓÐÀ IdentOper;
  ÏÅÐÅÌ
    e1, e2: DECL.òÂûðàæåíèå;
    line, col, ccall: INTEGER;
    begcall: X86.ASMLINE;
    s: DECL.òóÊîíñòÑòð;
  ÍÀ×ÀËÎ
    Coord(line, col);
    begcall := X86.current;
    Designator(e1);
    Assert(e1.eType # eCONST, line, col, 130);
    ÅÑËÈ (e1.eType = eVAR) & (e1.T.tType # TPROC) ÒÎÃÄÀ
      Check(lxAssign);
      Assert(~e1.Read, line, col, 115);
      Next;
      Coord(line, col);
      Expr(e2);
      Assert(AssComp(e2, e1.T, ËÎÆÜ), line, col, 131);
      Load(e2);
      ÅÑËÈ e1.T.tType = TRECORD ÒÎÃÄÀ
        X86.PushConst(e1.T.Size);
        X86.PushConst(e1.T.Number);
        ÅÑËÈ e1.vparam ÒÎÃÄÀ
          X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
          X86.Load(TINTEGER)
        ÀÅÑËÈ e1.deref ÒÎÃÄÀ
          X86.DerefType(12)
        ÈÍÀ×Å
          X86.PushConst(e1.T.Number)
        ÊÎÍÅÖ
      ÀÅÑËÈ e2.T.tType = TARRAY ÒÎÃÄÀ
        X86.PushConst(e2.T.Size)
      ÀÅÑËÈ (e2.T.tType = TSTRING) & (e1.T.tType = TARRAY) ÒÎÃÄÀ
        s := DECL.Ñòð_Ïîëó÷(e2.Value);
        ÅÑËÈ s.Len = 1 ÒÎÃÄÀ
          X86.Mono(s.Number)
        ÊÎÍÅÖ;
        X86.PushConst(ìÓòèëü.Ìèíèìóì(s.Len + 1, e1.T.Len))
      ÊÎÍÅÖ;
      X86.Save(e1.T.tType)
    ÀÅÑËÈ e1.eType = ePROC ÒÎÃÄÀ
      Assert((e1.id.T.Base.tType = TVOID) ÈËÈ (e1.id.T.Call = DECL.winapi), line, col, 132);
      ÅÑËÈ e1.id.ParamCount > 0 ÒÎÃÄÀ
        Check(lxLRound);
        Next;
        X86.PushCall(begcall);
        Call(e1.id.T.Fields.ïðåäûäóù(DECL.òóÏîëå));
        X86.EndCall
      ÀÅÑËÈ ìÑêàí.tLex = lxLRound ÒÎÃÄÀ
        Next;
        Check(lxRRound);
        Next
      ÊÎÍÅÖ;
      ÅÑËÈ e1.id.Level = 3 ÒÎÃÄÀ
        ccall := 0
      ÀÅÑËÈ e1.id.Level > DECL.curBlock.Level ÒÎÃÄÀ
        ccall := 1
      ÈÍÀ×Å
        ccall := 2
      ÊÎÍÅÖ;
      X86.Call(e1.id.Number, ËÎÆÜ, ËÎÆÜ, e1.id.T.Call, ccall, e1.id.Level - 3, DECL.curBlock.Level - 3, e1.id.ParamSize, DECL.curBlock.LocalSize)
    ÀÅÑËÈ e1.eType IN {eSTPROC, eSYSPROC} ÒÎÃÄÀ
      StProc(e1.id.StProc)
    ÀÅÑËÈ (e1.eType = eVAR) & (e1.T.tType = TPROC) ÒÎÃÄÀ
      ÅÑËÈ ìÑêàí.tLex = lxLRound ÒÎÃÄÀ
        Next;
        Assert((e1.T.Base.tType = TVOID) ÈËÈ (e1.T.Call = DECL.winapi), line, col, 132);
        X86.PushCall(begcall);
        Call(e1.T.Fields.ïðåäûäóù(DECL.òóÏîëå));
        X86.EndCall;
        X86.CallVar(ËÎÆÜ, ËÎÆÜ, e1.T.Call, e1.T.Len, DECL.curBlock.LocalSize)
      ÀÅÑËÈ ìÑêàí.tLex = lxAssign ÒÎÃÄÀ
        Assert(~e1.Read, line, col, 115);
        Next;
        Coord(line, col);
        Expr(e2);
        Assert(AssComp(e2, e1.T, ËÎÆÜ), line, col, 131);
        Assert(~((e2.eType = ePROC) & (e2.id.Level > 3)), line, col, 116);
        ÅÑËÈ e2.eType = eVAR ÒÎÃÄÀ
          X86.Load(TPROC)
        ÊÎÍÅÖ;
        X86.Save(TPROC)
      ÈÍÀ×Å
        Assert2(e1.T.Fields.ñ÷åò÷èê = 0, 155);
        Assert((e1.T.Base.tType = TVOID) ÈËÈ (e1.T.Call = DECL.winapi), line, col, 132);
        X86.CallVar(ËÎÆÜ, ËÎÆÜ, e1.T.Call, e1.T.Len, DECL.curBlock.LocalSize)
      ÊÎÍÅÖ
    ÊÎÍÅÖ
  ÊÎÍÅÖ IdentOper;

ÏÐÎÖÅÄÓÐÀ Operator;
  ÍÀ×ÀËÎ
    ìÓòèëü.ÊîäÑòðîêà_Óñò(DECL.UnitNumber, ìÑêàí.line);
    ÂÛÁÎÐ ìÑêàí.tLex ÈÇ
    |lxIDENT: IdentOper
    |ìÊîíñò.êñÅÑËÈ, ìÊîíñò.êñÏÎÊÀ: IfWhileOper(ìÑêàí.tLex = ìÊîíñò.êñÏÎÊÀ)
    |ìÊîíñò.êñÏÎÂÒÎÐ: RepeatOper
    |ìÊîíñò.êñÄËß: ForOper
    |ìÊîíñò.êñÂÛÁÎÐ: CaseOper
    ÈÍÀ×Å
    ÊÎÍÅÖ
  ÊÎÍÅÖ Operator;

ÏÐÎÖÅÄÓÐÀ OpSeq;
  ÍÀ×ÀËÎ
    Operator;
    ÏÎÊÀ ìÑêàí.tLex = lxSemi ÄÅËÀÒÜ
      Next;
      Operator
    ÊÎÍÅÖ
  ÊÎÍÅÖ OpSeq;

ÏÐÎÖÅÄÓÐÀ Ñòàðò;
  ÏÅÐÅÌ SelfName, SelfPath, CName, CExt, FName, Path, StdPath,
      Name, Ext, temp, system, stk, felf: ìÑòð.òÑòðîêà;
      platform, stksize: INTEGER;

    ÏÐÎÖÅÄÓÐÀ getstksize(): INTEGER;
    ÏÅÐÅÌ res, i: INTEGER;
    ÍÀ×ÀËÎ
      res := 0;
      i := 0;
      ÏÎÊÀ ìÑêàí.Öèôðà_Ïðîâåðèòü(stk[i]) ÄÅËÀÒÜ
        INC(i)
      ÊÎÍÅÖ;
      ÅÑËÈ stk[i] <= 20X ÒÎÃÄÀ
        stk[i] := 0X;
        res := ìÑêàí.Ñòð_â_Öåë(stk)
      ÊÎÍÅÖ;
      ÅÑËÈ res = 0 ÒÎÃÄÀ
        res := 1
      ÊÎÍÅÖ
      ÂÅÐÍÓÒÜ res
    ÊÎÍÅÖ getstksize;

    ÏÐÎÖÅÄÓÐÀ getver(): INTEGER;
    ÏÅÐÅÌ res, i: INTEGER; err: BOOLEAN;

      ÏÐÎÖÅÄÓÐÀ hexdgt(c: CHAR): BOOLEAN;
        ÂÅÐÍÓÒÜ ("0" <= c) & (c <= "9") ÈËÈ
               ("A" <= c) & (c <= "F") ÈËÈ
               ("a" <= c) & (c <= "f")
      ÊÎÍÅÖ hexdgt;

      ÏÐÎÖÅÄÓÐÀ hex(c: CHAR): INTEGER;
      ÏÅÐÅÌ res: INTEGER;
      ÍÀ×ÀËÎ
        ÅÑËÈ    ("0" <= c) & (c <= "9") ÒÎÃÄÀ
          res := ORD(c) - ORD("0")
        ÀÅÑËÈ ("A" <= c) & (c <= "F") ÒÎÃÄÀ
          res := ORD(c) - ORD("A") + 10
        ÀÅÑËÈ ("a" <= c) & (c <= "f") ÒÎÃÄÀ
          res := ORD(c) - ORD("a") + 10
        ÊÎÍÅÖ
        ÂÅÐÍÓÒÜ res
      ÊÎÍÅÖ hex;

    ÍÀ×ÀËÎ
      res := 0;
      i := 0;
      err := stk[i] # "0"; INC(i);
      err := err ÈËÈ (stk[i] # "x"); INC(i);
      ÏÎÊÀ ~err & hexdgt(stk[i]) ÄÅËÀÒÜ
        INC(i)
      ÊÎÍÅÖ;
      err := err ÈËÈ (i = 2);
      ÅÑËÈ stk[i] <= 20X ÒÎÃÄÀ
        stk[i] := 0X
      ÈÍÀ×Å
        err := ÈÑÒÈÍÀ
      ÊÎÍÅÖ;
      i := 2;
      ÏÎÊÀ ~err & (stk[i] # 0X) ÄÅËÀÒÜ
        res := LSL(res, 4) + hex(stk[i]);
        INC(i)
      ÊÎÍÅÖ;
      ÅÑËÈ res = 0 ÒÎÃÄÀ
        res := 1
      ÊÎÍÅÖ
      ÂÅÐÍÓÒÜ res
    ÊÎÍÅÖ getver;

  ÍÀ×ÀËÎ
    ÅÑËÈ ìÓòèëü.ParamCount < 2 ÒÎÃÄÀ
      ìÎø.Ñîîáù(59);
      ìÏðîö.Çàêîí÷èòü(1)
    ÊÎÍÅÖ;
    ìÓòèëü.ÑòðÏàðàì(SelfName, 0);
    ìÓòèëü.ÑòðÏàðàì(FName, 1);
    ìÓòèëü.ÑòðÏàðàì(system, 2);
    ìÓòèëü.ÑòðÏàðàì(stk, 3);
    pExpr := Expr;
    pFactor := Factor;
    pOpSeq := OpSeq;
    ìÑòð.Ðàçäåëèòü(FName, Path, Name, Ext);
    ÅÑËÈ Ext # ìÊîíñò.ðàñøèð ÒÎÃÄÀ
      ìÎø.Ñîîáù(121);
      ìÏðîö.Çàêîí÷èòü(1)
    ÊÎÍÅÖ;
    ìÑòð.Ðàçäåëèòü(SelfName, SelfPath, CName, CExt);
    temp := Name;
    ÅÑËÈ ìÓòèëü.streq(system, "obj") ÒÎÃÄÀ
      platform := 6;
    ìÑòð.Ñëîæèòü(temp, ".obj", temp)
    ÀÅÑËÈ ìÓòèëü.streq(system, "elf") ÒÎÃÄÀ
      platform := 5;
      felf := SelfPath;
      ìÑòð.Ñëîæèòü(felf, "Elf", felf);
      X86.setfelf(felf)
    ÀÅÑËÈ ìÓòèëü.streq(system, "kos") ÒÎÃÄÀ
      platform := 4;
      ìÑòð.Ñëîæèòü(temp, ".kex", temp)
    ÀÅÑËÈ ìÓòèëü.streq(system, "con") ÒÎÃÄÀ
      platform := 3;
      ìÑòð.Ñëîæèòü(temp, ".exe", temp)
    ÀÅÑËÈ ìÓòèëü.streq(system, "gui") ÒÎÃÄÀ
      platform := 2;
      ìÑòð.Ñëîæèòü(temp, ".exe", temp)
    ÀÅÑËÈ ìÓòèëü.streq(system, "dll") ÒÎÃÄÀ
      platform := 1;
      ìÑòð.Ñëîæèòü(temp, ".dll", temp)
    ÈÍÀ×Å
      ìÎø.Ñîîáù(60);
      ìÏðîö.Çàêîí÷èòü(1)
    ÊÎÍÅÖ;
    ÅÑËÈ platform IN {1,2,3,4} ÒÎÃÄÀ
      stksize := getstksize()
    ÈÍÀ×Å
      stksize := 1
    ÊÎÍÅÖ;
    ÅÑËÈ platform = 6 ÒÎÃÄÀ
      stksize := getver()
    ÊÎÍÅÖ;
    ìÑòð.Ñëîæèòü(SelfPath, "Lib", SelfPath);
    ìÑòð.Ñëîæèòü(SelfPath, ìÊîíñò.ñëýø, SelfPath);
    ÅÑËÈ platform = 5 ÒÎÃÄÀ
      ìÑòð.Ñëîæèòü(SelfPath, "Linux32", SelfPath)
    ÀÅÑËÈ platform IN {4, 6} ÒÎÃÄÀ
      ìÑòð.Ñëîæèòü(SelfPath, "KolibriOS", SelfPath)
    ÀÅÑËÈ platform IN {1, 2, 3} ÒÎÃÄÀ
      ìÑòð.Ñëîæèòü(SelfPath, "Windows32", SelfPath)
    ÊÎÍÅÖ;
    ìÑòð.Ñëîæèòü(SelfPath, ìÊîíñò.ñëýø, SelfPath);
    X86.Init(DECL.ÏàìÎø_Ïðîâåðèòü, platform);
    X86.Prolog(temp);
    DECL.Program(SelfPath, Path, Name, Ext, platform IN {1, 2, 3}, OpSeq, Expr, AssComp, sttypes);
    DECL.Compile(platform, stksize);
    ìÊîíñ.Ñòðîêà_Ïå÷àòü("   +Êîìïèëÿöèÿ óñïåøíà!"); ìÊîíñ.ÍîâÑòð;
    ìÊîíñ.Âðåìÿ_Çàòðà÷åíî
  ÊÎÍÅÖ Ñòàðò;

ÍÀ×ÀËÎ
  Ñòàðò
ÊÎÍÅÖ Compiler.
