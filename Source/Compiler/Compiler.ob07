МОДУЛЬ Compiler;

(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
    *)

ИМПОРТ мДец := DECL,
    мСкан := SCAN,
    мУтиль := UTILS,
    X86, SYSTEM,
    мКонст := modConstante,
    мКо := modConstErr,
    мФк := modFuncCompiler,
    мСтр := modString,
    мСпис := modList,
    мТипы := modType,
    мОш := modError,
    мПроц := modProcess,
    мКонс := modConsole,
    мПров := modAssertion;

ТИПЫ

    тМетка = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
        a, b: ЦЕЛОЕ
    КОНЕЦ;

ПЕРЕМ
    pExpr, pFactor: ПРОЦЕДУРА (ПЕРЕМ e: мДец.тВыражение);
    pOpSeq: ПРОЦЕДУРА;
    Lex: мСтр.тСтрока;
    sttypes: мДец.stTYPES;

ПРОЦЕДУРА BaseOf(тип0_, тип1_: мТипы.туТип): БУЛЕВО;
    ПЕРЕМ
        усл1, усл2 :БУЛЕВО;
    НАЧАЛО
        усл1 := (тип0_.тип_узла = тип1_.тип_узла);
        усл2 := (тип0_.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тУказатель});
        ЕСЛИ усл1 & усл2 ТОГДА
            ЕСЛИ тип0_.тип_узла = мКонст._тУказатель ТОГДА
                тип0_ := тип0_.предок;
                тип1_ := тип1_.предок
            КОНЕЦ;
            ПОКА (тип1_ # ПУСТО) & (тип1_ # тип0_) ДЕЛАТЬ
                тип1_ := тип1_.предок
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ тип0_ = тип1_
    КОНЕЦ BaseOf;

ПРОЦЕДУРА Designator(ПЕРЕМ выраж_: мДец.тВыражение);
    ПЕРЕМ
        имя_узел: мДец.туИмя;
        узел: мСкан.туУзел;
        выраж1: мДец.тВыражение;
        строка_ном, позиция, i, n, bases, glob, loc, idx: ЦЕЛОЕ;
        imp, break, guard: БУЛЕВО;
        f: мДец.туПоле;
        T, тип_предка: мТипы.туТип;
        s: мДец.STRCONST;

    ПРОЦЕДУРА LoadVar;
        НАЧАЛО
            ЕСЛИ glob # -1 ТОГДА
                X86.GlobalAdr(glob);
                glob := -1
            ИНЕСЛ loc # -1 ТОГДА
                X86.LocalAdr(loc, bases);
                loc := -1
            КОНЕЦ
        КОНЕЦ LoadVar;

    НАЧАЛО
        glob := -1;
        loc := -1;
        мФк.Коорд_Уст(строка_ном, позиция);
        мФк.Проверить(мКонст._лекИмя);
        узел := мСкан.id;
        имя_узел := мДец.GetIdent(узел);
        ЕСЛИ (имя_узел # ПУСТО) & (имя_узел.тип_номер = мКонст._IDMOD) ТОГДА
            мФк.Следующ_Проверка(мКонст._лекТочка);
            мФк.Следующ_Проверка(мКонст._лекИмя);
            мФк.Коорд_Уст(строка_ном, позиция);
            узел := мСкан.id;
            imp := имя_узел.модуль # мДец.модуль_текущ;
            имя_узел := мДец.GetQIdent(имя_узел.модуль, узел)
        КОНЕЦ;
        мПров.Проверить(имя_узел # ПУСТО, строка_ном, позиция, мКо._ош33);
        выраж_.vparam := ЛОЖЬ;
        выраж_.deref := ЛОЖЬ;
        выраж_.id := имя_узел;
        мДец.Лексем_Дальше;
        ВЫБРАТЬ имя_узел.тип_номер ИЗ
            |мКонст._имяПерем:
                выраж_.eType := мКонст._eVAR;
                выраж_.тип := имя_узел.тип;
                ЕСЛИ имя_узел.VarKind = 0 ТОГДА
                    выраж_.Read := imp
                ИНАЧЕ
                    выраж_.Read := (имя_узел.VarKind = мКонст._param) & (имя_узел.тип.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тМассив});
                    выраж_.vparam := имя_узел.VarKind = мКонст._param_var
                КОНЕЦ;
                bases := мДец.модуль_текущ.уровень - имя_узел.уровень;
                ЕСЛИ имя_узел.уровень = 3 ТОГДА
                    glob := имя_узел.смещение
                ИНЕСЛ (имя_узел.VarKind = 0) ИЛИ (имя_узел.VarKind = мКонст._param) &
                        ~(имя_узел.тип.тип_узла ВХОДИТ {мКонст._тМассив, мКонст._тЗапись}) ТОГДА
                    loc := имя_узел.смещение
                ИНЕСЛ (имя_узел.VarKind = мКонст._param_var) ИЛИ (имя_узел.тип.тип_узла ВХОДИТ {мКонст._тМассив, мКонст._тЗапись}) ТОГДА
                    ЕСЛИ мТипы.Глубина_Получ(выраж_.тип) > 0 ТОГДА
                        n := мТипы.Глубина_Получ(выраж_.тип);
                        ДЛЯ i := n ДО 1 ПО -1 ДЕЛАТЬ
                            X86.LocalAdr(имя_узел.смещение + i * 4, bases);
                            X86.Load(мКонст._тЦелое)
                        КОНЕЦ
                    КОНЕЦ;
                    X86.LocalAdr(имя_узел.смещение, bases);
                    X86.Load(мКонст._тЦелое)
                КОНЕЦ
            |мКонст._имяКонст:
                мПров.Проверить(имя_узел.тип # ПУСТО, строка_ном, позиция, мКо._ош66);
                выраж_.eType := мКонст._выражКонст;
                выраж_.тип := имя_узел.тип;
                выраж_.двЗнач := имя_узел.двЗнач;
                ЕСЛИ имя_узел.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._TSET, мКонст._тБулево} ТОГДА
                    X86.PushConst(FLOOR(выраж_.двЗнач))
                ИНЕСЛ имя_узел.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ} ТОГДА
                    X86.PushFlt(выраж_.двЗнач)
                ИНЕСЛ имя_узел.тип.тип_узла = мКонст._тСтрока ТОГДА
                    s := мДец.Стр_Получ(выраж_.двЗнач);
                    ЕСЛИ s.Len = 1 ТОГДА
                        X86.PushConst(ORD(s.строка[0]))
                    ИНАЧЕ
                        X86.PushInt(s.Number)
                    КОНЕЦ
                КОНЕЦ
            |мКонст._имяПроц:
                выраж_.eType := мКонст._ePROC;
                выраж_.тип := sttypes[мКонст._TVOID]
            |мКонст._имяТипа:
                мПров.Проверить(ЛОЖЬ, строка_ном, позиция, мКо._ош92)
            |мКонст._IDSTPROC:
                выраж_.eType := мКонст._eSTPROC;
                выраж_.тип := sttypes[мКонст._TVOID]
            |мКонст._имяСисПроц:
                выраж_.eType := мКонст._eSYSPROC;
                выраж_.тип := sttypes[мКонст._TVOID]
        ИНАЧЕ
        КОНЕЦ;
        break := ЛОЖЬ;
        guard := ЛОЖЬ;
        ПОВТОРЯТЬ
            ВЫБРАТЬ мСкан.лекс_тип ИЗ
                |мКонст._лекТочка:
                    выраж_.deref := ЛОЖЬ;
                    мПров.Проверить2(выраж_.тип.тип_узла ВХОДИТ {мКонст._тУказатель, мКонст._тЗапись}, мКо._ош96);
                    ЕСЛИ выраж_.тип.тип_узла = мКонст._тУказатель ТОГДА
                        выраж_.Read := ЛОЖЬ;
                        LoadVar;
                        выраж_.тип := выраж_.тип.предок;
                        X86.Load(мКонст._тЦелое);
                        ЕСЛИ ~guard ТОГДА
                            X86.CheckNIL
                        КОНЕЦ
                    КОНЕЦ;
                    мФк.Следующ_Проверка(мКонст._лекИмя);
                    мФк.Коорд_Уст(строка_ном, позиция);
                    узел := мСкан.id;
                    T := выраж_.тип;
                    ПОВТОРЯТЬ
                        f := мДец.GetField(T, узел);
                        T := T.предок
                    СНОВА (f # ПУСТО) ИЛИ (T = ПУСТО);
                    мПров.Проверить(f # ПУСТО, строка_ном, позиция, мКо._ош90);
                    ЕСЛИ f.модуль # мДец.модуль_текущ ТОГДА
                        мПров.Проверить(f.Export, строка_ном, позиция, мКо._ош90)
                    КОНЕЦ;
                    ЕСЛИ glob # -1 ТОГДА
                        glob := glob + f.Offset
                    ИНЕСЛ loc # -1 ТОГДА
                        loc := loc + f.Offset
                    ИНАЧЕ
                        X86.Field(f.Offset)
                    КОНЕЦ;
                    выраж_.тип := f.тип;
                    выраж_.vparam := ЛОЖЬ;
                    guard := ЛОЖЬ;
                    мДец.Лексем_Дальше
                |мКонст._опСкобЛевКв:
                    LoadVar;
                    ПОВТОРЯТЬ
                        мПров.Проверить2(выраж_.тип.тип_узла = мКонст._тМассив, мКо._ош93);
                        мФк.КоордСледующ_Уст(строка_ном, позиция);
                        pExpr(выраж1);
                        мПров.Проверить(выраж1.тип.тип_узла = мКонст._тЦелое, строка_ном, позиция, мКо._ош43);
                        мФк.Выражение_Загрузить(выраж1);
                        ЕСЛИ выраж_.тип.глубина = 0 ТОГДА
                            тип_предка := мДец.OpenBase(выраж_.тип);
                            X86.PushConst(тип_предка.размер);
                            X86.OpenIdx(мТипы.Глубина_Получ(выраж_.тип))
                        ИНАЧЕ
                            ЕСЛИ выраж1.eType = мКонст._выражКонст ТОГДА
                                idx := FLOOR(выраж1.двЗнач);
                                мПров.Проверить((idx >= 0) & (idx < выраж_.тип.глубина), строка_ном, позиция, мКо._ош137);
                                ЕСЛИ выраж_.тип.предок.размер # 1 ТОГДА
                                    X86.Drop;
                                    X86.PushConst(выраж_.тип.предок.размер * idx)
                                КОНЕЦ;
                                X86.Idx
                            ИНАЧЕ
                                X86.FixIdx(выраж_.тип.глубина, выраж_.тип.предок.размер)
                            КОНЕЦ
                        КОНЕЦ;
                        выраж_.тип := выраж_.тип.предок
                    СНОВА мСкан.лекс_тип # мКонст._опЗпт;
                    мФк.Проверить(мКонст._опСкобПравКв);
                    выраж_.vparam := ЛОЖЬ;
                    guard := ЛОЖЬ;
                    мДец.Лексем_Дальше
                |мКонст._опСтепень:
                    LoadVar;
                    мПров.Проверить2(выраж_.тип.тип_узла = мКонст._тУказатель, мКо._ош95);
                    выраж_.Read := ЛОЖЬ;
                    X86.Load(мКонст._тЦелое);
                    ЕСЛИ ~guard ТОГДА
                        X86.CheckNIL
                    КОНЕЦ;
                    выраж_.тип := выраж_.тип.предок;
                    выраж_.vparam := ЛОЖЬ;
                    выраж_.deref := ИСТИНА;
                    guard := ЛОЖЬ;
                    мДец.Лексем_Дальше
                |мКонст._lexLRound:
                    LoadVar;
                    ЕСЛИ выраж_.тип.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тУказатель} ТОГДА
                        ЕСЛИ выраж_.тип.тип_узла = мКонст._тЗапись ТОГДА
                            мПров.Проверить2(выраж_.vparam, мКо._ош99)
                        КОНЕЦ;
                        мФк.Следующ_Проверка(мКонст._лекИмя);
                        мФк.Коорд_Уст(строка_ном, позиция);
                        T := мДец.IdType(строка_ном, позиция);
                        мПров.Проверить(T # ПУСТО, строка_ном, позиция, мКо._ош33);
                        ЕСЛИ выраж_.тип.тип_узла = мКонст._тЗапись ТОГДА
                            мПров.Проверить(T.тип_узла = мКонст._тЗапись, строка_ном, позиция, мКо._ош97)
                        ИНАЧЕ
                            мПров.Проверить(T.тип_узла = мКонст._тУказатель, строка_ном, позиция, мКо._ош98)
                        КОНЕЦ;
                        мПров.Проверить(BaseOf(выраж_.тип, T), строка_ном, позиция, мКо._ош99);
                        выраж_.тип := T;
                        мФк.Проверка_Дальше(мКонст._опСкобПравКруг);
                        ЕСЛИ выраж_.тип.тип_узла = мКонст._тУказатель ТОГДА
                            ЕСЛИ (мСкан.лекс_тип = мКонст._лекТочка) ИЛИ (мСкан.лекс_тип = мКонст._опСтепень) ТОГДА
                                X86.DupLoadCheck
                            ИНАЧЕ
                                X86.DupLoad
                            КОНЕЦ;
                            guard := ИСТИНА;
                            T := T.предок
                        ИНАЧЕ
                            X86.LocalAdr(выраж_.id.смещение, мДец.модуль_текущ.уровень - выраж_.id.уровень)
                        КОНЕЦ;
                        X86.Guard(T.Number, ЛОЖЬ)
                    ИНАЧЕ
                        break := ИСТИНА
                    КОНЕЦ
            ИНАЧЕ
                break := ИСТИНА
            КОНЕЦ
        СНОВА break;
        LoadVar
    КОНЕЦ Designator;

ПРОЦЕДУРА Set(ПЕРЕМ выраж_: мДец.тВыражение);
    ПЕРЕМ
        выраж1, выраж2: мДец.тВыражение;
        строка, позиц: ЦЕЛОЕ;
        набор: SET;
        flag: БУЛЕВО;

    НАЧАЛО
        мДец.Лексем_Дальше;
        выраж_.eType := мКонст._eEXP;
        выраж_.тип := sttypes[мКонст._TSET];
        выраж_.двЗнач := 0.0D0;
        выраж_.vparam := ЛОЖЬ;
        набор := {};
        flag := ИСТИНА;
        X86.PushConst(0);
        ПОКА мСкан.лекс_тип # мКонст._опСкобФигурПрав ДЕЛАТЬ
            мФк.Коорд_Уст(строка, позиц);
            pExpr(выраж1);
            мПров.Проверить(выраж1.тип.тип_узла = мКонст._тЦелое, строка, позиц, мКо._ош43);
            ЕСЛИ выраж1.eType = мКонст._выражКонст ТОГДА
                мПров.Проверить(ASR(FLOOR(выраж1.двЗнач), 5) = 0, строка, позиц, мКо._ош44)
            КОНЕЦ;
            мФк.Выражение_Загрузить(выраж1);
            выраж2 := выраж1;
            ЕСЛИ мСкан.лекс_тип = мКонст._lexDbl ТОГДА
                мФк.КоордСледующ_Уст(строка, позиц);
                pExpr(выраж2);
                мПров.Проверить(выраж2.тип.тип_узла = мКонст._тЦелое, строка, позиц, мКо._ош43);
                ЕСЛИ выраж2.eType = мКонст._выражКонст ТОГДА
                    мПров.Проверить(ASR(FLOOR(выраж2.двЗнач), 5) = 0, строка, позиц, мКо._ош44);
                    мПров.Проверить(выраж1.двЗнач <= выраж2.двЗнач, строка, позиц, мКо._ош45)
                КОНЕЦ;
                мФк.Выражение_Загрузить(выраж2)
            ИНАЧЕ
                X86.Dup
            КОНЕЦ;
            X86.rset;
            X86.Set(мКонст._опПлюс);
            flag := (выраж1.eType = мКонст._выражКонст) & (выраж2.eType = мКонст._выражКонст) & flag;
            ЕСЛИ flag ТОГДА
                набор := набор + {FLOOR(выраж1.двЗнач) .. FLOOR(выраж2.двЗнач)}
            КОНЕЦ;
            ЕСЛИ мСкан.лекс_тип = мКонст._опЗпт ТОГДА
                мДец.Лексем_Дальше;
                мПров.Проверить2(мСкан.лекс_тип # мКонст._опСкобФигурПрав, мКо._ош27)
            ИНАЧЕ
                мФк.Проверить(мКонст._опСкобФигурПрав)
            КОНЕЦ
        КОНЕЦ;
        ЕСЛИ flag ТОГДА
            выраж_.двЗнач := ДЛИН(FLT(ORD(набор)));
            выраж_.eType := мКонст._выражКонст
        КОНЕЦ;
        мДец.Лексем_Дальше
    КОНЕЦ Set;

ПРОЦЕДУРА Str(e: мДец.тВыражение);
    ПЕРЕМ
        A: X86.tIdx;
    НАЧАЛО
        ЕСЛИ (e.тип.тип_узла = мКонст._тМассив) & (e.тип.предок.тип_узла = мКонст._тСимвол) & (e.тип.глубина # 0) ТОГДА
            A[0] := e.тип.глубина;
            X86.OpenArray(A, 1)
        ИНЕСЛ e.тип.тип_узла = мКонст._тСтрока ТОГДА
            A[0] := мФк.Стр_Получ(e.двЗнач) + 1;
            ЕСЛИ A[0] # 2 ТОГДА
                X86.OpenArray(A, 1)
            КОНЕЦ
        КОНЕЦ
    КОНЕЦ Str;

ПРОЦЕДУРА StFunc(ПЕРЕМ e: мДец.тВыражение; func: ЦЕЛОЕ);
    ПЕРЕМ
        line, col, line2, col2, a, b, p: ЦЕЛОЕ;
        e1, e2: мДец.тВыражение;
        T: мТипы.туТип;
        str, str2: мДец.STRCONST;

    НАЧАЛО
        e.vparam := ЛОЖЬ;
        e.eType := мКонст._eEXP;
        мФк.Коорд_Уст(line2, col2);
        мФк.Проверить(мКонст._lexLRound);
        мФк.КоордСледующ_Уст(line, col);
        ВЫБРАТЬ func ИЗ
            |мКонст._stABS:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ}, line, col, мКо._ош48);
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    e.двЗнач := ABS(e1.двЗнач);
                    e.eType := мКонст._выражКонст;
                    мПров.Проверить(~((e1.тип.тип_узла = мКонст._тЦелое) & (e1.двЗнач = ДЛИН(FLT(мКонст._minINT)))),
                            line, col,  мКо._ош5)
                КОНЕЦ;
                ЕСЛИ e1.тип.тип_узла = мКонст._тЦелое ТОГДА
                    X86.StFunc(мКонст._stABS)
                ИНАЧЕ
                    X86.StFunc(мКонст._stFABS)
                КОНЕЦ;
                e.тип := e1.тип
            |мКонст._stODD:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    e.двЗнач := ДЛИН(FLT(ORD(ODD(FLOOR(e1.двЗнач)))));
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                X86.StFunc(мКонст._stODD);
                e.тип := sttypes[мКонст._тБулево]
            |мКонст._stLEN:
                Designator(e1);
                мПров.Проверить((e1.eType = мКонст._eVAR) & (e1.тип.тип_узла = мКонст._тМассив), line, col, мКо._ош93);
                ЕСЛИ e1.тип.глубина > 0 ТОГДА
                    X86.Len(-e1.тип.глубина)
                ИНАЧЕ
                    X86.Len(мТипы.Глубина_Получ(e1.тип))
                КОНЕЦ;
                e.тип := sttypes[мКонст._тЦелое]
            |мКонст._stLSL, мКонст._stASR, мКонст._stROR, мКонст._stLSR:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Загрузить_Проверить(e1, мКонст._опЗпт);
                мФк.КоордСледующ_Уст(line, col);
                pExpr(e2);
                мПров.Проверить(e2.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e2);
                ЕСЛИ (e1.eType = мКонст._выражКонст) & (e2.eType = мКонст._выражКонст) ТОГДА
                    a := FLOOR(e1.двЗнач);
                    b := FLOOR(e2.двЗнач);
                    ВЫБРАТЬ func ИЗ
                        |мКонст._stLSL: a := LSL(a, b)
                        |мКонст._stASR: a := ASR(a, b)
                        |мКонст._stROR: a := ROR(a, b)
                        |мКонст._stLSR: a := LSR(a, b)
                    ИНАЧЕ
                    КОНЕЦ;
                    e.двЗнач := ДЛИН(FLT(a));
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                ВЫБРАТЬ func ИЗ
                    |мКонст._stLSL: X86.StFunc(мКонст._stLSL)
                    |мКонст._stASR: X86.StFunc(мКонст._stASR)
                    |мКонст._stROR: X86.StFunc(мКонст._stROR)
                    |мКонст._stLSR: X86.StFunc(мКонст._stLSR)
                ИНАЧЕ
                КОНЕЦ;
                e.тип := sttypes[мКонст._тЦелое]
            |мКонст._stFLOOR:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ}, line, col, мКо._ош57);
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    мПров.Проверить((e1.двЗнач - 1.0D0 < ДЛИН(FLT(мКонст._maxINT))) &
                            (e1.двЗнач >= ДЛИН(FLT(мКонст._minINT))), line, col, мКо._ош65);
                    e.двЗнач := ДЛИН(FLT(FLOOR(e1.двЗнач)));
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                X86.StFunc(мКонст._stFLOOR);
                e.тип := sttypes[мКонст._тЦелое]
            |мКонст._stFLT:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    e.двЗнач := e1.двЗнач;
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                X86.StFunc(мКонст._stFLT);
                e.тип := sttypes[мКонст._тВеществ]
            |мКонст._stORD:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла ВХОДИТ {мКонст._тСимвол, мКонст._тБулево, мКонст._TSET, мКонст._тСтрока}, line,
                            col, мКо._ош59);
                ЕСЛИ e1.тип.тип_узла = мКонст._тСтрока ТОГДА
                    мПров.Проверить(мФк.Стр_Получ(e1.двЗнач) = 1, line, col, мКо._ош85)
                КОНЕЦ;
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    ЕСЛИ e1.тип.тип_узла = мКонст._тСтрока ТОГДА
                        str := мДец.Стр_Получ(e1.двЗнач);
                        e.двЗнач := ДЛИН(FLT(ORD(str.строка[0])))
                    ИНАЧЕ
                        e.двЗнач := e1.двЗнач
                    КОНЕЦ;
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                ЕСЛИ e1.тип.тип_узла = мКонст._тБулево ТОГДА
                    X86.StFunc(мКонст._stORD)
                КОНЕЦ;
                e.тип := sttypes[мКонст._тЦелое]
            |мКонст._stBITS:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e1);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    e.двЗнач := e1.двЗнач;
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                e.тип := sttypes[мКонст._TSET]
            |мКонст._stCHR:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e1);
                e.тип := sttypes[мКонст._тСимвол];
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    мПров.Проверить(ASR(FLOOR(e1.двЗнач), 8) = 0, line, col, мКо._ош67);
                    str2 := мДец.AddMono(CHR(FLOOR(e1.двЗнач)));
                    SYSTEM.GET(SYSTEM.ADR(str2), p);
                    e.двЗнач := ДЛИН(FLT(p));
                    e.тип := sttypes[мКонст._тСтрока];
                    e.eType := мКонст._выражКонст
                КОНЕЦ
            |мКонст._stLONG:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тВеществ, line, col, мКо._ош62);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    e.двЗнач := e1.двЗнач;
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                мФк.Выражение_Загрузить(e1);
                e.тип := sttypes[мКонст._тДлинВещ]
            |мКонст._stSHORT:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тДлинВещ, line, col, мКо._ош61);
                ЕСЛИ e1.eType = мКонст._выражКонст ТОГДА
                    мПров.Проверить(ABS(e1.двЗнач) <= ДЛИН(мКонст._maxREAL), line, col, мКо._ош7);
                    мПров.Проверить(ABS(e1.двЗнач) >= ДЛИН(мКонст._minREAL), line, col,  мКо._ош9);
                    e.двЗнач := e1.двЗнач;
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                мФк.Выражение_Загрузить(e1);
                e.тип := sttypes[мКонст._тВеществ]
            |мКонст._stLENGTH:
                pExpr(e1);
                мПров.Проверить(мФк.ЕслиСтрока(e1), line, col, мКо._ош126);
                ЕСЛИ e1.тип.тип_узла = мКонст._тСтрока ТОГДА
                    str := мДец.Стр_Получ(e1.двЗнач);
                    ЕСЛИ str.Len = 1 ТОГДА
                        X86.Mono(str.Number);
                        X86.StrMono
                    КОНЕЦ;
                    e.двЗнач := ДЛИН(FLT(LENGTH(str.строка)));
                    e.eType := мКонст._выражКонст
                КОНЕЦ;
                Str(e1);
                e.тип := sttypes[мКонст._тЦелое];
                X86.StFunc(мКонст._stLENGTH)
            |мКонст._sysADR:
                мПров.Проверить((мСкан.лекс_тип = мКонст._лекИмя) ИЛИ (мСкан.лекс_тип = мКонст._лекСтрока) ИЛИ
                        (мСкан.лекс_тип = мКонст._lexCHX), line, col, мКо._ош34);
                ЕСЛИ мСкан.лекс_тип = мКонст._лекИмя ТОГДА
                    Designator(e1);
                    мПров.Проверить((e1.eType = мКонст._eVAR) ИЛИ (e1.eType = мКонст._ePROC) ИЛИ
                            (e1.тип = sttypes[мКонст._тСтрока]), line, col, мКо._ош34);
                    ЕСЛИ e1.eType = мКонст._ePROC ТОГДА
                        X86.PushInt(e1.id.номер)
                    КОНЕЦ
                ИНАЧЕ
                    pFactor(e1)
                КОНЕЦ;
                ЕСЛИ e1.тип = sttypes[мКонст._тСтрока] ТОГДА
                    str := мДец.Стр_Получ(e1.двЗнач);
                    ЕСЛИ str.Len = 1 ТОГДА
                        X86.Drop;
                        X86.PushInt(str.Number)
                    КОНЕЦ
                КОНЕЦ;
                e.тип := sttypes[мКонст._тЦелое];
                X86.ADR(мТипы.Глубина_Получ(e1.тип))
            |мКонст._sysBIT:
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Загрузить_Проверить(e1, мКонст._опЗпт);
                мФк.КоордСледующ_Уст(line, col);
                pExpr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Выражение_Загрузить(e1);
                X86.StFunc(мКонст._sysBIT);
                e.тип := sttypes[мКонст._тБулево]
            |мКонст._sysSIZE, мКонст._sysTYPEID:
                мДец.ПроцедурРазм_Уст;
                мФк.Проверить(мКонст._лекИмя);
                T := мДец.IdType(line, col);
                мПров.Проверить(T # ПУСТО, line, col, мКо._ош33);
                e.eType := мКонст._выражКонст;
                e.тип := sttypes[мКонст._тЦелое];
                ЕСЛИ func = мКонст._sysTYPEID ТОГДА
                    мПров.Проверить(T.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тУказатель}, line, col, мКо._ош38);
                    ЕСЛИ T.тип_узла = мКонст._тУказатель ТОГДА
                        T := T.предок
                    КОНЕЦ;
                    e.двЗнач := ДЛИН(FLT(T.Number));
                    X86.PushConst(T.Number)
                ИНАЧЕ
                    e.двЗнач := ДЛИН(FLT(T.размер));
                    X86.PushConst(T.размер)
                КОНЕЦ
        ИНАЧЕ
            мПров.Проверить(ЛОЖЬ, line2, col2, мКо._ош64)
        КОНЕЦ;
        мФк.Проверка_Дальше(мКонст._опСкобПравКруг);
    КОНЕЦ StFunc;

ПРОЦЕДУРА ProcTypeComp(T1, T2: мТипы.туТип): БУЛЕВО;
    ПЕРЕМ
        sp: ЦЕЛОЕ;
        stk: МАССИВ 100, 2 ИЗ мТипы.туТип;

    ПРОЦЕДУРА ProcTypeComp1(T1, T2: мТипы.туТип): БУЛЕВО;
        ПЕРЕМ
            fp, ft: мДец.туПоле;
            Res: БУЛЕВО;

        ПРОЦЕДУРА TypeComp(T1, T2: мТипы.туТип): БУЛЕВО;
            ПЕРЕМ Res: БУЛЕВО;
            НАЧАЛО
                ЕСЛИ (T1.тип_узла = мКонст._тМассив) & (T2.тип_узла = мКонст._тМассив) & (T1.глубина = 0) & (T2.глубина = 0) ТОГДА
                    Res := TypeComp(T1.предок, T2.предок)
                ИНАЧЕ
                    Res := ProcTypeComp1(T1, T2)
                КОНЕЦ
                ВЕРНУТЬ Res
            КОНЕЦ TypeComp;

        ПРОЦЕДУРА Check(): БУЛЕВО;
            ПЕРЕМ
                i: ЦЕЛОЕ;
                res: БУЛЕВО;
            НАЧАЛО
                i := 0;
                res := ЛОЖЬ;
                ПОКА (i < sp) & ~res ДЕЛАТЬ
                    res := ((stk[i][0] = T1) & (stk[i][1] = T2)) ИЛИ ((stk[i][0] = T2) & (stk[i][1] = T1));
                    ДОБ(i)
                КОНЕЦ
                ВЕРНУТЬ res
            КОНЕЦ Check;

        НАЧАЛО
            ДОБ(sp);
            stk[sp][0] := T1;
            stk[sp][1] := T2;
            ЕСЛИ Check() ТОГДА
                Res := ИСТИНА
            ИНАЧЕ
                ЕСЛИ (T1.тип_узла = мКонст._TPROC) & (T2.тип_узла = мКонст._TPROC) & (T1 # T2) ТОГДА
                    Res := (T1.вызов = T2.вызов) & (T1.поля.спис_длин = T2.поля.спис_длин) & ProcTypeComp1(T1.предок, T2.предок);
                    fp := T1.поля.первый(мДец.туПоле);
                    ft := T2.поля.первый(мДец.туПоле);
                    ПОКА Res & (fp # ПУСТО) ДЕЛАТЬ
                        Res := (fp.ByRef = ft.ByRef) & TypeComp(fp.тип, ft.тип);
                        fp := fp.следующ(мДец.туПоле);
                        ft := ft.следующ(мДец.туПоле)
                    КОНЕЦ
                ИНАЧЕ
                    Res := T1 = T2
                КОНЕЦ
            КОНЕЦ;
            ВЫЧ(sp)
            ВЕРНУТЬ Res
        КОНЕЦ ProcTypeComp1;

    НАЧАЛО
        sp := -1
        ВЕРНУТЬ ProcTypeComp1(T1, T2)
    КОНЕЦ ProcTypeComp;

ПРОЦЕДУРА ArrComp(Ta, Tf: мТипы.туТип): БУЛЕВО;
    ПЕРЕМ
        Res: БУЛЕВО;
    НАЧАЛО
        ЕСЛИ (Tf.тип_узла = мКонст._тМассив) & (Tf.глубина = 0) & (Ta.тип_узла = мКонст._тМассив) ТОГДА
            Res := ArrComp(Ta.предок, Tf.предок)
        ИНАЧЕ
            Res := ProcTypeComp(Ta, Tf)
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ ArrComp;

ПРОЦЕДУРА AssComp(e: мДец.тВыражение; T: мТипы.туТип; param: БУЛЕВО): БУЛЕВО;
    ПЕРЕМ
        Res: БУЛЕВО;
    НАЧАЛО
        ВЫБРАТЬ T.тип_узла ИЗ
            |мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ, мКонст._TSET, мКонст._тБулево, мКонст._TCARD16:
                Res := e.тип = T
            |мКонст._тСимвол:
                ЕСЛИ e.тип.тип_узла = мКонст._тСтрока ТОГДА
                    Res := мФк.Стр_Получ(e.двЗнач) = 1
                ИНАЧЕ
                    Res := e.тип.тип_узла = мКонст._тСимвол
                КОНЕЦ
            |мКонст._тМассив:
                ЕСЛИ param ТОГДА
                    ЕСЛИ T.глубина = 0 ТОГДА
                        ЕСЛИ (T.предок.тип_узла = мКонст._тСимвол) & (e.тип.тип_узла = мКонст._тСтрока) ТОГДА
                            Res := ИСТИНА
                        ИНАЧЕ
                            Res := ArrComp(e.тип, T)
                        КОНЕЦ
                    ИНАЧЕ
                        ЕСЛИ (T.предок.тип_узла = мКонст._тСимвол) & (e.тип.тип_узла = мКонст._тСтрока) ТОГДА
                            Res := мФк.Стр_Получ(e.двЗнач) <= T.глубина
                        ИНАЧЕ
                            Res := e.тип = T
                        КОНЕЦ
                    КОНЕЦ
                ИНАЧЕ
                    ЕСЛИ T.глубина = 0 ТОГДА
                        Res := ЛОЖЬ
                    ИНЕСЛ (T.предок.тип_узла = мКонст._тСимвол) & (e.тип.тип_узла = мКонст._тСтрока) ТОГДА
                        Res := мФк.Стр_Получ(e.двЗнач) <= T.глубина
                    ИНАЧЕ
                        Res := e.тип = T
                    КОНЕЦ
                КОНЕЦ
            |мКонст._тЗапись: Res := BaseOf(T, e.тип)
            |мКонст._тУказатель: Res := BaseOf(T, e.тип) ИЛИ (e.тип.тип_узла = мКонст._тПусто)
            |мКонст._TPROC: Res := (e.тип.тип_узла = мКонст._тПусто) ИЛИ (e.eType = мКонст._ePROC) & ProcTypeComp(e.id.тип, T) ИЛИ
                    (e.eType # мКонст._ePROC) & ProcTypeComp(e.тип, T)
        ИНАЧЕ
            Res := ЛОЖЬ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ AssComp;

ПРОЦЕДУРА ParamComp(e: мДец.тВыражение; T: мТипы.туТип; ByRef: БУЛЕВО): БУЛЕВО;
    ПЕРЕМ Res: БУЛЕВО;
    НАЧАЛО
      ЕСЛИ ByRef ТОГДА
        ЕСЛИ e.eType = мКонст._eVAR ТОГДА
          ВЫБРАТЬ T.тип_узла ИЗ
          |мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ, мКонст._тСимвол,
           мКонст._TSET, мКонст._тБулево, мКонст._тУказатель, мКонст._TCARD16:
            Res := e.тип = T
          |мКонст._тМассив:
            ЕСЛИ T.глубина > 0 ТОГДА
              Res := e.тип = T
            ИНАЧЕ
              Res := ArrComp(e.тип, T)
            КОНЕЦ
          |мКонст._тЗапись:
            Res := BaseOf(T, e.тип)
          |мКонст._TPROC:
            Res := ProcTypeComp(e.тип, T)
          ИНАЧЕ
          КОНЕЦ
        ИНАЧЕ
          Res := ЛОЖЬ
        КОНЕЦ
      ИНАЧЕ
        Res := AssComp(e, T, ИСТИНА)
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ ParamComp;

ПРОЦЕДУРА Call(param: мДец.туПоле);
    ПЕРЕМ
        line, col, i, n: ЦЕЛОЕ; e1: мДец.тВыражение; s: мДец.STRCONST; A: X86.tIdx; TA: мТипы.туТип;
    НАЧАЛО
      ПОКА param # ПУСТО ДЕЛАТЬ
        мФк.Коорд_Уст(line, col);
        X86.Param;
        pExpr(e1);
        мПров.Проверить(ParamComp(e1, param.тип, param.ByRef), line, col, мКо._ош105);
        мПров.Проверить(~(param.ByRef & e1.Read), line, col, мКо._ош106);
        мПров.Проверить(~((e1.eType = мКонст._ePROC) & (e1.id.уровень > 3)), line, col, мКо._ош107);
        ЕСЛИ (e1.eType = мКонст._eVAR) & ~param.ByRef ТОГДА
          X86.Load(e1.тип.тип_узла)
        КОНЕЦ;
        ЕСЛИ param.ByRef & (e1.тип.тип_узла = мКонст._тЗапись) ТОГДА
          ЕСЛИ e1.vparam ТОГДА
            X86.LocalAdr(e1.id.смещение - 4, мДец.модуль_текущ.уровень - e1.id.уровень);
            X86.Load(мКонст._тЦелое)
          ИНЕСЛ e1.deref ТОГДА
            X86.DerefType(0)
          ИНАЧЕ
            X86.PushConst(e1.тип.Number)
          КОНЕЦ
        КОНЕЦ;
        ЕСЛИ ~param.ByRef & (param.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ}) ТОГДА
          X86.DropFpu(param.тип.тип_узла = мКонст._тДлинВещ)
        КОНЕЦ;
        ЕСЛИ (e1.тип.тип_узла = мКонст._тСтрока) & (param.тип.тип_узла = мКонст._тМассив) ТОГДА
          s := мДец.Стр_Получ(e1.двЗнач);
          ЕСЛИ s.Len = 1 ТОГДА
            X86.Mono(s.Number)
          КОНЕЦ;
          ЕСЛИ param.тип.глубина = 0 ТОГДА
            A[0] := s.Len + 1;
            X86.OpenArray(A, 1)
          КОНЕЦ
        КОНЕЦ;
        ЕСЛИ (e1.тип.тип_узла = мКонст._тМассив) & (мТипы.Глубина_Получ(param.тип) > мТипы.Глубина_Получ(e1.тип)) ТОГДА
          n := мТипы.Глубина_Получ(param.тип) - мТипы.Глубина_Получ(e1.тип);
          TA := мДец.OpenBase(e1.тип);
          ДЛЯ i := 0 ДО n - 1 ДЕЛАТЬ
            A[i] := TA.глубина;
            TA := TA.предок
          КОНЕЦ;
          ЕСЛИ мТипы.Глубина_Получ(e1.тип) = 0 ТОГДА
            X86.OpenArray(A, n)
          ИНАЧЕ
            X86.ExtArray(A, n, мТипы.Глубина_Получ(e1.тип))
          КОНЕЦ
        КОНЕЦ;
        param := param.следующ(мДец.туПоле);
        ЕСЛИ param # ПУСТО ТОГДА
          мФк.Проверка_Дальше(мКонст._опЗпт);
        КОНЕЦ
      КОНЕЦ;
      мФк.Проверка_Дальше(мКонст._опСкобПравКруг);
    КОНЕЦ Call;

ПРОЦЕДУРА Factor(ПЕРЕМ e: мДец.тВыражение);
    ПЕРЕМ line, col, ccall, p: ЦЕЛОЕ; begcall: X86.тАсмУзел; s, str2: мДец.STRCONST;
    НАЧАЛО
      e.eType := мКонст._выражКонст;
      e.vparam := ЛОЖЬ;
      ВЫБРАТЬ мСкан.лекс_тип ИЗ
      |мКонст._лекИмя:
        begcall := X86.current;
        Designator(e);
        ЕСЛИ e.eType = мКонст._ePROC ТОГДА
          ЕСЛИ мСкан.лекс_тип = мКонст._lexLRound ТОГДА
            мПров.Проверить2(e.id.тип.предок.тип_узла # мКонст._TVOID, мКо._ош64);
            мДец.Лексем_Дальше;
            X86.PushCall(begcall);
            Call(e.id.тип.поля.первый(мДец.туПоле));
            X86.EndCall;
            e.eType := мКонст._eEXP;
            e.тип := e.id.тип.предок;
            ЕСЛИ e.id.уровень = 3 ТОГДА
              ccall := 0
            ИНЕСЛ e.id.уровень > мДец.curBlock.уровень ТОГДА
              ccall := 1
            ИНАЧЕ
              ccall := 2
            КОНЕЦ;
            X86.Call(e.id.номер, ИСТИНА, e.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ}, e.id.тип.вызов, ccall, e.id.уровень - 3,
              мДец.curBlock.уровень - 3, e.id.парам_размер, мДец.curBlock.локаль_размер)
          ИНАЧЕ
            X86.PushInt(e.id.номер)
          КОНЕЦ
        ИНЕСЛ (e.eType = мКонст._eVAR) & (e.тип.тип_узла = мКонст._TPROC) & (мСкан.лекс_тип = мКонст._lexLRound) ТОГДА
          мПров.Проверить2(e.тип.предок.тип_узла # мКонст._TVOID, мКо._ош64);
          мДец.Лексем_Дальше;
          X86.PushCall(begcall);
          Call(e.тип.поля.первый(мДец.туПоле));
          X86.EndCall;
          e.eType := мКонст._eEXP;
          X86.CallVar(ИСТИНА, e.тип.предок.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ}, e.тип.вызов, e.тип.глубина, мДец.curBlock.локаль_размер);
          e.тип := e.тип.предок;
        ИНЕСЛ e.eType ВХОДИТ {мКонст._eSTPROC, мКонст._eSYSPROC} ТОГДА
          StFunc(e, e.id.StProc)
        КОНЕЦ
      |мКонст._лекПусто:
        e.тип := sttypes[мКонст._тПусто];
        e.двЗнач := 0.0D0;
        X86.PushConst(0);
        мДец.Лексем_Дальше
      |мКонст._лекИстина:
        e.тип := sttypes[мКонст._тБулево];
        e.двЗнач := 1.0D0;
        X86.PushConst(1);
        мДец.Лексем_Дальше
      |мКонст._лекЛожь:
        e.тип := sttypes[мКонст._тБулево];
        e.двЗнач := 0.0D0;
        X86.PushConst(0);
        мДец.Лексем_Дальше
      |мКонст._lexCHX, мКонст._лекСтрока:
        ЕСЛИ мСкан.лекс_тип = мКонст._лекСтрока ТОГДА
          мСкан.GetLexStr(Lex);
          str2 := мДец.AddString(Lex);
          SYSTEM.GET(SYSTEM.ADR(str2), p);
          e.двЗнач := ДЛИН(FLT(p));
          s := мДец.Стр_Получ(e.двЗнач);
          ЕСЛИ s.Len = 1 ТОГДА
            X86.PushConst(ORD(s.строка[0]))
          ИНАЧЕ
            X86.PushInt(s.Number)
          КОНЕЦ
        ИНАЧЕ
          str2 := мДец.AddMono(мСкан.vCHX);
          SYSTEM.GET(SYSTEM.ADR(str2), p);
          e.двЗнач := ДЛИН(FLT(p));
          X86.PushConst(ORD(мСкан.vCHX))
        КОНЕЦ;
        e.тип := sttypes[мКонст._тСтрока];
        мДец.Лексем_Дальше
      |мКонст._лекВеществ:
        e.тип := sttypes[мКонст._тВеществ];
        e.двЗнач := мСкан.vFLT;
        X86.PushFlt(мСкан.vFLT);
        мДец.Лексем_Дальше
      |мКонст._лекДлинВещ:
        e.тип := sttypes[мКонст._тДлинВещ];
        e.двЗнач := мСкан.vFLT;
        X86.PushFlt(мСкан.vFLT);
        мДец.Лексем_Дальше
      |мКонст._лекЦел, мКонст._lexHEX:
        e.тип := sttypes[мКонст._тЦелое];
        e.двЗнач := ДЛИН(FLT(мСкан.vINT));
        X86.PushConst(мСкан.vINT);
        мДец.Лексем_Дальше
      |мКонст._lexLRound:
        мДец.Лексем_Дальше;
        pExpr(e);
        мФк.Проверка_Дальше(мКонст._опСкобПравКруг);
      |мКонст._опИнверс:
        мФк.КоордСледующ_Уст(line, col);
        Factor(e);
        мПров.Проверить(e.тип.тип_узла = мКонст._тБулево, line, col, мКо._ош28);
        мФк.Выражение_Загрузить(e);
        ЕСЛИ e.eType = мКонст._выражКонст ТОГДА
          e.двЗнач := ДЛИН(FLT(ORD(e.двЗнач = 0.0D0)))
        ИНАЧЕ
          e.eType := мКонст._eEXP
        КОНЕЦ;
        X86.Not;
        e.vparam := ЛОЖЬ
      |мКонст._опСкобФигурЛев:
        Set(e)
      ИНАЧЕ
        мПров.Проверить2(ЛОЖЬ, мКо._ош27)
      КОНЕЦ
    КОНЕЦ Factor;

ПРОЦЕДУРА ЕслиСимв(a: мДец.тВыражение): БУЛЕВО;
      ВЕРНУТЬ (a.тип.тип_узла = мКонст._тСтрока) & (мФк.Стр_Получ(a.двЗнач) = 1) ИЛИ (a.тип.тип_узла = мКонст._тСимвол)
    КОНЕЦ ЕслиСимв;

ПРОЦЕДУРА StrRel(a, b: мДец.тВыражение; Op: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ ~(ЕслиСимв(a) ИЛИ ЕслиСимв(b)) ТОГДА
        X86.strcmp(Op, 0)
      ИНЕСЛ ЕслиСимв(a) & ЕслиСимв(b) ТОГДА
        X86.CmpInt(Op)
      ИНЕСЛ ЕслиСимв(a) ТОГДА
        X86.strcmp(Op, 1)
      ИНАЧЕ
        X86.strcmp(Op, -1)
      КОНЕЦ
    КОНЕЦ StrRel;

ПРОЦЕДУРА log2(n: ЦЕЛОЕ): ЦЕЛОЕ;
    ПЕРЕМ x, i: ЦЕЛОЕ;
    НАЧАЛО
      x := 1;
      i := 0;
      ПОКА (x # n) & (i < 31) ДЕЛАТЬ
        x := LSL(x, 1);
        ДОБ(i)
      КОНЕЦ;
      ЕСЛИ x # n ТОГДА
        i := -1
      КОНЕЦ
      ВЕРНУТЬ i
    КОНЕЦ log2;

ПРОЦЕДУРА Operation(ПЕРЕМ a, b: мДец.тВыражение; Op, line, col: ЦЕЛОЕ);
    ПЕРЕМ n, m: ЦЕЛОЕ;
    НАЧАЛО
      ВЫБРАТЬ Op ИЗ
      |мКонст._опПлюс, мКонст._опМинус, мКонст._опУмнож, мКонст._опДел:
        мПров.Проверить((a.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ, мКонст._TSET})
                & (a.тип.тип_узла = b.тип.тип_узла), line, col, мКо._ош28);
        мПров.Проверить(~((Op = мКонст._опДел) & (a.тип.тип_узла = мКонст._тЦелое)), line, col, мКо._ош28);
        ВЫБРАТЬ a.тип.тип_узла ИЗ
        |мКонст._тЦелое: X86.Int(Op)
        |мКонст._TSET: X86.Set(Op)
        |мКонст._тВеществ, мКонст._тДлинВещ: X86.farith(Op)
        ИНАЧЕ
        КОНЕЦ
      |мКонст._lexDIV, мКонст._lexMOD:
        мПров.Проверить((a.тип.тип_узла = мКонст._тЦелое) & (b.тип.тип_узла = мКонст._тЦелое), line, col, мКо._ош28);
        ЕСЛИ b.eType = мКонст._выражКонст ТОГДА
          m := FLOOR(b.двЗнач);
          мПров.Проверить(m # 0, line, col, мКо._ош39);
          n := log2(m);
          ЕСЛИ n = -1 ТОГДА
            X86.idivmod(Op = мКонст._lexMOD)
          ИНАЧЕ
            X86.Drop;
            ЕСЛИ Op = мКонст._lexMOD ТОГДА
              n := ORD(-BITS(LSL(-1, n)));
              X86.PushConst(n);
              X86.Set(мКонст._опУмнож)
            ИНАЧЕ
              X86.PushConst(n);
              X86.StFunc(мКонст._stASR)
            КОНЕЦ
          КОНЕЦ
        ИНАЧЕ
          X86.idivmod(Op = мКонст._lexMOD)
        КОНЕЦ
      |мКонст._опКомерцИ, мКонст._лекИли:
            мПров.Проверить((a.тип.тип_узла = мКонст._тБулево) & (b.тип.тип_узла = мКонст._тБулево), line, col,
                    мКо._ош28)
      |мКонст._лекВходит:
            мПров.Проверить((a.тип.тип_узла = мКонст._тЦелое) & (b.тип.тип_узла = мКонст._TSET), line, col,
                    мКо._ош28);
            X86.inset
      |мКонст._опМеньше, мКонст._lexLE, мКонст._опБольше, мКонст._lexGE:
        мПров.Проверить(((a.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ}) &
                (a.тип.тип_узла = b.тип.тип_узла)) ИЛИ (ЕслиСимв(a) ИЛИ мФк.ЕслиСтрока(a)) & (ЕслиСимв(b) ИЛИ
                мФк.ЕслиСтрока(b)) ИЛИ (a.тип.тип_узла = мКонст._TSET) & (b.тип.тип_узла = мКонст._TSET) &
                ((Op = мКонст._lexLE) ИЛИ (Op = мКонст._lexGE)), line, col, мКо._ош37);
        ЕСЛИ a.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ} ТОГДА
          X86.fcmp(Op)
        ИНЕСЛ a.тип.тип_узла = мКонст._TSET ТОГДА
          X86.Inclusion(Op)
        ИНЕСЛ мФк.ЕслиСтрока(a) ИЛИ мФк.ЕслиСтрока(b) ТОГДА
          StrRel(a, b, Op)
        ИНАЧЕ
          X86.CmpInt(Op)
        КОНЕЦ
      |мКонст._опРавно, мКонст._опНеРавно:
        мПров.Проверить(((a.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ, мКонст._TSET,
                мКонст._тБулево}) & (a.тип.тип_узла = b.тип.тип_узла)) ИЛИ
                (ЕслиСимв(a) ИЛИ мФк.ЕслиСтрока(a)) & (ЕслиСимв(b) ИЛИ мФк.ЕслиСтрока(b)) ИЛИ
                (a.тип.тип_узла ВХОДИТ {мКонст._тУказатель, мКонст._TPROC, мКонст._тПусто}) &
                (b.тип.тип_узла = мКонст._тПусто) ИЛИ (b.тип.тип_узла ВХОДИТ {мКонст._тУказатель,
                мКонст._TPROC, мКонст._тПусто}) & (a.тип.тип_узла = мКонст._тПусто) ИЛИ
                (a.тип.тип_узла = мКонст._тУказатель) & (b.тип.тип_узла = мКонст._тУказатель) &
                (BaseOf(a.тип, b.тип) ИЛИ BaseOf(b.тип, a.тип)) ИЛИ
                (a.тип.тип_узла = мКонст._TPROC) & ProcTypeComp(b.тип, a.тип) ИЛИ (a.eType = мКонст._ePROC) &
                ProcTypeComp(b.тип, a.id.тип) ИЛИ
                (b.eType = мКонст._ePROC) & ProcTypeComp(a.тип, b.id.тип), line, col, мКо._ош37);
        ЕСЛИ a.тип.тип_узла ВХОДИТ {мКонст._тВеществ, мКонст._тДлинВещ} ТОГДА
          X86.fcmp(Op)
        ИНЕСЛ мФк.ЕслиСтрока(a) ИЛИ мФк.ЕслиСтрока(b) ТОГДА
          StrRel(a, b, Op)
        ИНАЧЕ
          X86.CmpInt(Op)
        КОНЕЦ
      ИНАЧЕ
      КОНЕЦ;
      ЕСЛИ (a.eType # мКонст._выражКонст) ИЛИ (b.eType # мКонст._выражКонст) ТОГДА
        a.eType := мКонст._eEXP;
        ЕСЛИ мДец.Отношен_Проверить(Op) ТОГДА
          a.тип := sttypes[мКонст._тБулево]
        КОНЕЦ
      ИНАЧЕ
        мДец.Calc(a.двЗнач, b.двЗнач, a.тип, b.тип, Op, line, col, a.двЗнач, a.тип)
      КОНЕЦ;
      a.vparam := ЛОЖЬ
    КОНЕЦ Operation;

ПРОЦЕДУРА Term(ПЕРЕМ e: мДец.тВыражение);
    ПЕРЕМ a: мДец.тВыражение; Op, line, col, L: ЦЕЛОЕ;
    НАЧАЛО
      Factor(e);
      ПОКА (мСкан.лекс_тип = мКонст._опУмнож) ИЛИ (мСкан.лекс_тип = мКонст._опДел) ИЛИ
        (мСкан.лекс_тип = мКонст._lexDIV) ИЛИ (мСкан.лекс_тип = мКонст._lexMOD) ИЛИ
         (мСкан.лекс_тип = мКонст._опКомерцИ) ДЕЛАТЬ
        мФк.Выражение_Загрузить(e);
        мФк.Коорд_Уст(line, col);
        Op := мСкан.лекс_тип;
        мДец.Лексем_Дальше;
        ЕСЛИ Op = мКонст._опКомерцИ ТОГДА
          L := X86.NewLabel();
          X86.IfWhile(L, ЛОЖЬ)
        КОНЕЦ;
        Factor(a);
        мФк.Выражение_Загрузить(a);
        ЕСЛИ Op = мКонст._опКомерцИ ТОГДА
          X86.Label(L)
        КОНЕЦ;
        Operation(e, a, Op, line, col)
      КОНЕЦ
    КОНЕЦ Term;

ПРОЦЕДУРА Simple(ПЕРЕМ e: мДец.тВыражение);
    ПЕРЕМ a: мДец.тВыражение; Op, line, col, uOp, uline, ucol, L: ЦЕЛОЕ;
    НАЧАЛО
      uOp := 0;
      ЕСЛИ (мСкан.лекс_тип = мКонст._опПлюс) ИЛИ (мСкан.лекс_тип = мКонст._опМинус) ТОГДА
        мФк.Коорд_Уст(uline, ucol);
        uOp := мСкан.лекс_тип;
        мДец.Лексем_Дальше
      КОНЕЦ;
      Term(e);
      ЕСЛИ uOp # 0 ТОГДА
        мПров.Проверить(e.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ, мКонст._TSET},
                uline, ucol, мКо._ош28);
        мФк.Выражение_Загрузить(e);
        ЕСЛИ uOp = мКонст._опМинус ТОГДА
          ВЫБРАТЬ e.тип.тип_узла ИЗ
          |мКонст._тЦелое: X86.NegInt
          |мКонст._TSET: X86.NegSet
          |мКонст._тВеществ, мКонст._тДлинВещ: X86.fneg
          ИНАЧЕ
          КОНЕЦ
        КОНЕЦ;
        ЕСЛИ (uOp = мКонст._опМинус) & (e.eType = мКонст._выражКонст) ТОГДА
          ВЫБРАТЬ e.тип.тип_узла ИЗ
          |мКонст._тЦелое:
              мПров.Проверить(e.двЗнач # ДЛИН(FLT(мКонст._minINT)), uline, ucol, мКо._ош5)
          |мКонст._TSET:
            e.двЗнач := -ДЛИН(FLT(ORD(-BITS(FLOOR(e.двЗнач)))))
          ИНАЧЕ
          КОНЕЦ;
          e.двЗнач := -e.двЗнач
        КОНЕЦ;
        ЕСЛИ e.eType # мКонст._выражКонст ТОГДА
          e.eType := мКонст._eEXP
        КОНЕЦ;
        e.vparam := ЛОЖЬ
      КОНЕЦ;
      ПОКА (мСкан.лекс_тип = мКонст._опПлюс) ИЛИ (мСкан.лекс_тип = мКонст._опМинус) ИЛИ (мСкан.лекс_тип = мКонст._лекИли) ДЕЛАТЬ
        мФк.Выражение_Загрузить(e);
        мФк.Коорд_Уст(line, col);
        Op := мСкан.лекс_тип;
        мДец.Лексем_Дальше;
        ЕСЛИ Op = мКонст._лекИли ТОГДА
          L := X86.NewLabel();
          X86.IfWhile(L, ИСТИНА)
        КОНЕЦ;
        Term(a);
        мФк.Выражение_Загрузить(a);
        ЕСЛИ Op = мКонст._лекИли ТОГДА
          X86.Label(L)
        КОНЕЦ;
        Operation(e, a, Op, line, col)
      КОНЕЦ
    КОНЕЦ Simple;

ПРОЦЕДУРА Expr(ПЕРЕМ e: мДец.тВыражение);
    ПЕРЕМ a: мДец.тВыражение; Op, line, col, line2, col2, fpu: ЦЕЛОЕ; T: мТипы.туТип; beg: X86.тАсмУзел; s: мДец.STRCONST;
    НАЧАЛО
      fpu := X86.fpu;
      beg := X86.current;
      Simple(e);
      ЕСЛИ мДец.Отношен_Проверить(мСкан.лекс_тип) ТОГДА
        мФк.Коорд_Уст(line, col);
        Op := мСкан.лекс_тип;
        мДец.Лексем_Дальше;
        ЕСЛИ Op = мКонст._лекЕсть ТОГДА
          мПров.Проверить(e.тип.тип_узла ВХОДИТ {мКонст._тЗапись, мКонст._тУказатель}, line, col, мКо._ош28);
          ЕСЛИ e.тип.тип_узла = мКонст._тЗапись ТОГДА
            мПров.Проверить(e.vparam, line, col, мКо._ош28)
          КОНЕЦ;
          мФк.Проверить(мКонст._лекИмя);
          мФк.Коорд_Уст(line2, col2);
          T := мДец.IdType(line2, col2);
          мПров.Проверить(T # ПУСТО, line2, col2, мКо._ош33);
          ЕСЛИ e.тип.тип_узла = мКонст._тЗапись ТОГДА
            мПров.Проверить(T.тип_узла = мКонст._тЗапись, line2, col2, мКо._ош97)
          ИНАЧЕ
            мПров.Проверить(T.тип_узла = мКонст._тУказатель, line2, col2, мКо._ош98)
          КОНЕЦ;
          мПров.Проверить(BaseOf(e.тип, T), line, col, мКо._ош28);
          ЕСЛИ e.тип.тип_узла = мКонст._тЗапись ТОГДА
            X86.Drop;
            X86.LocalAdr(e.id.смещение, мДец.модуль_текущ.уровень - e.id.уровень)
          КОНЕЦ;
          мФк.Выражение_Загрузить(e);
          ЕСЛИ e.тип.тип_узла = мКонст._тУказатель ТОГДА
            T := T.предок
          КОНЕЦ;
          X86.Guard(T.Number, ИСТИНА);
          e.тип := sttypes[мКонст._тБулево];
          e.eType := мКонст._eEXP;
          e.vparam := ЛОЖЬ
        ИНАЧЕ
          мФк.Выражение_Загрузить(e);
          Str(e);
          Simple(a);
          мФк.Выражение_Загрузить(a);
          Str(a);
          Operation(e, a, Op, line, col)
        КОНЕЦ
      КОНЕЦ;
      ЕСЛИ e.eType = мКонст._выражКонст ТОГДА
        X86.Del(beg);
        X86.Setfpu(fpu);
        ЕСЛИ ~мДец.Const ТОГДА
          ВЫБРАТЬ e.тип.тип_узла ИЗ
          |мКонст._тВеществ, мКонст._тДлинВещ:
            X86.PushFlt(e.двЗнач)
          |мКонст._тЦелое, мКонст._TSET, мКонст._тБулево, мКонст._тПусто:
            X86.PushConst(FLOOR(e.двЗнач))
          |мКонст._тСтрока:
            s := мДец.Стр_Получ(e.двЗнач);
            ЕСЛИ s.Len = 1 ТОГДА
              X86.PushConst(ORD(s.строка[0]))
            ИНАЧЕ
              X86.PushInt(s.Number)
            КОНЕЦ
          ИНАЧЕ
          КОНЕЦ
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ Expr;

ПРОЦЕДУРА ОпЕслиПока_Уст(wh: БУЛЕВО);
    ПЕРЕМ e: мДец.тВыражение; line, col, L, L3: ЦЕЛОЕ;
    НАЧАЛО
      L := X86.NewLabel();
      ЕСЛИ wh ТОГДА
        X86.Label(L)
      КОНЕЦ;
      ПОВТОРЯТЬ
        мФк.КоордСледующ_Уст(line, col);
        Expr(e);
        мПров.Проверить(e.тип.тип_узла = мКонст._тБулево, line, col, мКо._ош108);
        мФк.Выражение_Загрузить(e);
        ЕСЛИ wh ТОГДА
          мФк.Проверить(мКонст._lexDO)
        ИНАЧЕ
          мФк.Проверить(мКонст._лекТогда)
        КОНЕЦ;
        L3 := X86.NewLabel();
        X86.ifwh(L3);
        мДец.Лексем_Дальше;
        pOpSeq;
        X86.jmp(мКонст._JMP, L);
        X86.Label(L3)
      СНОВА мСкан.лекс_тип # мКонст._лекИлЕсли;
      ЕСЛИ ~wh & (мСкан.лекс_тип = мКонст._лекИначе) ТОГДА
        мДец.Лексем_Дальше;
        pOpSeq
      КОНЕЦ;
      мФк.Проверить(мКонст._лекКонец);
      ЕСЛИ ~wh ТОГДА
        X86.Label(L)
      КОНЕЦ;
      мДец.Лексем_Дальше
    КОНЕЦ ОпЕслиПока_Уст;

ПРОЦЕДУРА ОпПовторять_Уст;
    ПЕРЕМ e: мДец.тВыражение; line, col, L: ЦЕЛОЕ;
    НАЧАЛО
      мДец.Лексем_Дальше;
      L := X86.NewLabel();
      X86.Label(L);
      pOpSeq;
      мФк.Проверить(мКонст._лекСнова);
      мФк.КоордСледующ_Уст(line, col);
      Expr(e);
      мПров.Проверить(e.тип.тип_узла = мКонст._тБулево, line, col, мКо._ош108);
      мФк.Выражение_Загрузить(e);
      X86.ifwh(L)
    КОНЕЦ ОпПовторять_Уст;

ПРОЦЕДУРА ОпДля_Уст;
    ПЕРЕМ e: мДец.тВыражение; line, col, LBeg, LEnd, iValue: ЦЕЛОЕ; Value: ДЛИНВЕЩ;
        T: мТипы.туТип; name: мСкан.туУзел; id: мДец.туИмя;
    НАЧАЛО
      мФк.Следующ_Проверка(мКонст._лекИмя);
      name := мСкан.id;
      id := мДец.GetIdent(name);
      мПров.Проверить2(id # ПУСТО, мКо._ош33);
      мПров.Проверить2(id.тип_номер = мКонст._имяПерем, мКо._ош117);
      мПров.Проверить2(id.VarKind = 0, мКо._ош118);
      мПров.Проверить2(id.тип.тип_узла = мКонст._тЦелое, мКо._ош119);
      мПров.Проверить2(id.уровень = мДец.модуль_текущ.уровень, мКо._ош120);
      мФк.Следующ_Проверка(мКонст._lexAssign);
      мФк.КоордСледующ_Уст(line, col);
      ЕСЛИ id.уровень = 3 ТОГДА
        X86.GlobalAdr(id.смещение)
      ИНАЧЕ
        X86.LocalAdr(id.смещение, 0)
      КОНЕЦ;
      X86.Dup;
      Expr(e);
      мПров.Проверить(e.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
      мФк.Выражение_Загрузить(e);
      X86.Save(мКонст._тЦелое);
      мФк.Проверить(мКонст._lexTO);
      мФк.КоордСледующ_Уст(line, col);
      Expr(e);
      мПров.Проверить(e.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
      мФк.Выражение_Загрузить(e);
      iValue := 1;
      ЕСЛИ мСкан.лекс_тип = мКонст._лекПо ТОГДА
        мФк.КоордСледующ_Уст(line, col);
        мДец.ConstExpr(Value, T);
        мПров.Проверить(T.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
        iValue := FLOOR(Value);
        мПров.Проверить(iValue # 0, line, col, мКо._ош113)
      КОНЕЦ;
      мФк.Проверка_Дальше(мКонст._lexDO);
      X86.For(iValue > 0, LBeg, LEnd);
      pOpSeq;
      X86.NextFor(iValue, LBeg, LEnd);
      мФк.Проверка_Дальше(мКонст._лекКонец);
    КОНЕЦ ОпДля_Уст;

ПРОЦЕДУРА CheckLabel(a, b: ЦЕЛОЕ; Labels: мСпис.туСписок): БУЛЕВО;
    ПЕРЕМ cur: тМетка;
    НАЧАЛО
      cur := Labels.первый(тМетка);
      ПОКА (cur # ПУСТО) & ((b < cur.a) ИЛИ (a > cur.b)) ДЕЛАТЬ
        cur := cur.следующ(тМетка)
      КОНЕЦ
      ВЕРНУТЬ cur = ПУСТО
    КОНЕЦ CheckLabel;

ПРОЦЕДУРА LabelVal(ПЕРЕМ a: ЦЕЛОЕ; int: БУЛЕВО);
    ПЕРЕМ Value: ДЛИНВЕЩ; T: мТипы.туТип; s: мДец.STRCONST; line, col: ЦЕЛОЕ;
    НАЧАЛО
      мФк.Коорд_Уст(line, col);
      мДец.ConstExpr(Value, T);
      ЕСЛИ int ТОГДА
        мПров.Проверить(T.тип_узла = мКонст._тЦелое, line, col, мКо._ош139);
        a := FLOOR(Value)
      ИНАЧЕ
        мПров.Проверить(T.тип_узла = мКонст._тСтрока, line, col, мКо._ош46);
        s := мДец.Стр_Получ(Value);
        мПров.Проверить(s.Len = 1, line, col, мКо._ош85);
        a := ORD(s.строка[0])
      КОНЕЦ
    КОНЕЦ LabelVal;

ПРОЦЕДУРА Label(int: БУЛЕВО; Labels: мСпис.туСписок; LBeg: ЦЕЛОЕ);
    ПЕРЕМ a, b: ЦЕЛОЕ; label: тМетка; line, col: ЦЕЛОЕ;
    НАЧАЛО
      мФк.Коорд_Уст(line, col);
      LabelVal(a, int);
      b := a;
      ЕСЛИ мСкан.лекс_тип = мКонст._lexDbl ТОГДА
        мДец.Лексем_Дальше;
        LabelVal(b, int)
      КОНЕЦ;
      мПров.Проверить(a <= b, line, col, мКо._ош45);
      мПров.Проверить(CheckLabel(a, b, Labels), line, col, мКо._ош91);
      НОВ(label);
      мДец.MemErr(label = ПУСТО);
      label.a := a;
      label.b := b;
      мСпис.Добавить(Labels, label);
      X86.CaseLabel(a, b, LBeg)
    КОНЕЦ Label;

ПРОЦЕДУРА Variant(int: БУЛЕВО; Labels: мСпис.туСписок; EndCase: ЦЕЛОЕ);
    ПЕРЕМ LBeg, LEnd: ЦЕЛОЕ;
    НАЧАЛО
      LBeg := X86.NewLabel();
      LEnd := X86.NewLabel();
      ЕСЛИ ~((мСкан.лекс_тип = мКонст._опВерт) ИЛИ (мСкан.лекс_тип = мКонст._лекКонец)) ТОГДА
        Label(int, Labels, LBeg);
        ПОКА мСкан.лекс_тип = мКонст._опЗпт ДЕЛАТЬ
          мДец.Лексем_Дальше;
          Label(int, Labels, LBeg)
        КОНЕЦ;
        мФк.Проверка_Дальше(мКонст._опДвеТчк);
        X86.jmp(мКонст._JMP, LEnd);
        X86.Label(LBeg);
        pOpSeq;
        X86.jmp(мКонст._JMP, EndCase);
        X86.Label(LEnd)
      КОНЕЦ
    КОНЕЦ Variant;

ПРОЦЕДУРА ОпВыбрать_Уст;
    ПЕРЕМ e: мДец.тВыражение; int: БУЛЕВО; line, col, EndCase: ЦЕЛОЕ; Labels: мСпис.туСписок;
    НАЧАЛО
      мФк.КоордСледующ_Уст(line, col);
      Expr(e);
      мПров.Проверить(e.тип.тип_узла ВХОДИТ {мКонст._тСимвол, мКонст._тСтрока, мКонст._тЦелое}, line, col, мКо._ош134);
      мПров.Проверить(~((e.тип.тип_узла = мКонст._тСтрока) & (мФк.Стр_Получ(e.двЗнач) # 1)), line, col, мКо._ош85);
      int := e.тип.тип_узла = мКонст._тЦелое;
      мФк.Проверить(мКонст._lexOF);
      мФк.Выражение_Загрузить(e);
      X86.Drop;
      Labels := мСпис.Создать();
      мДец.MemErr(Labels = ПУСТО);
      мДец.Лексем_Дальше;
      EndCase := X86.NewLabel();
      Variant(int, Labels, EndCase);
      ПОКА мСкан.лекс_тип = мКонст._опВерт ДЕЛАТЬ
        мДец.Лексем_Дальше;
        Variant(int, Labels, EndCase)
      КОНЕЦ;
      ЕСЛИ мСкан.лекс_тип = мКонст._лекИначе ТОГДА
        мДец.Лексем_Дальше;
        pOpSeq
      ИНАЧЕ
        мУтиль.ЮнитСтрока_Уст(мДец.модуль_ном, мСкан.строка_ном);
        X86.OnError(7)
      КОНЕЦ;
      мФк.Проверить(мКонст._лекКонец);
      X86.Label(EndCase);
      мДец.Лексем_Дальше;
      мСпис.Очистить(Labels)
    КОНЕЦ ОпВыбрать_Уст;

ПРОЦЕДУРА CheckCode(Code: мСтр.тСтрока; Len, line, col: ЦЕЛОЕ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      мПров.Проверить(~ODD(Len), line, col, мКо._ош25);
      ДЛЯ i := 0 ДО Len - 1 ДЕЛАТЬ
        мПров.Проверить(мСкан.Если16число(Code[i]), line, col, мКо._ош25)
      КОНЕЦ
    КОНЕЦ CheckCode;

ПРОЦЕДУРА СисПроцедур_Уст(proc: ЦЕЛОЕ);
    ПЕРЕМ line, col, line2, col2, iValue: ЦЕЛОЕ; e1, e2: мДец.тВыражение; Value: ДЛИНВЕЩ;
        тип: мТипы.туТип; str: мДец.STRCONST; begcall: X86.тАсмУзел;
    НАЧАЛО
        мФк.Коорд_Уст(line2, col2);
        мФк.Проверить(мКонст._lexLRound);
        мФк.КоордСледующ_Уст(line, col);
        ВЫБРАТЬ proc ИЗ
            |мКонст._stINC, мКонст._stDEC:
                Designator(e1);
                мПров.Проверить(e1.eType = мКонст._eVAR, line, col, мКо._ош54);
                мПров.Проверить(~e1.Read, line, col, мКо._ош106);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош119);
                ЕСЛИ мСкан.лекс_тип = мКонст._опЗпт ТОГДА
                  мФк.КоордСледующ_Уст(line, col);
                  мДец.ConstExpr(Value, тип);
                  мПров.Проверить(тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                  iValue := FLOOR(Value);
                  мПров.Проверить(iValue # 0, line, col, мКо._ош113);
                  ЕСЛИ iValue < 0 ТОГДА
                    ЕСЛИ proc = мКонст._stINC ТОГДА
                      proc := мКонст._stDEC
                    ИНАЧЕ
                      proc := мКонст._stINC
                    КОНЕЦ;
                    iValue := -iValue
                  КОНЕЦ;
                  ЕСЛИ iValue # 1 ТОГДА
                    X86.PushConst(iValue);
                    ЕСЛИ proc = мКонст._stDEC ТОГДА
                      X86.StProc(мКонст._stDEC)
                    ИНАЧЕ
                      X86.StProc(мКонст._stINC)
                    КОНЕЦ
                  ИНАЧЕ
                    ЕСЛИ proc = мКонст._stDEC ТОГДА
                      X86.StProc(мКонст._stDEC1)
                    ИНАЧЕ
                      X86.StProc(мКонст._stINC1)
                    КОНЕЦ
                  КОНЕЦ
                ИНАЧЕ
                  ЕСЛИ proc = мКонст._stDEC ТОГДА
                    X86.StProc(мКонст._stDEC1)
                  ИНАЧЕ
                    X86.StProc(мКонст._stINC1)
                  КОНЕЦ
                КОНЕЦ
            |мКонст._stINCL, мКонст._stEXCL:
                Designator(e1);
                мПров.Проверить(e1.eType = мКонст._eVAR, line, col, мКо._ош54);
                мПров.Проверить(~e1.Read, line, col, мКо._ош106);
                мПров.Проверить(e1.тип.тип_узла = мКонст._TSET, line, col, мКо._ош125);
                мФк.Проверить(мКонст._опЗпт);
                мФк.КоордСледующ_Уст(line, col);
                мДец.ConstExpr(Value, тип);
                мПров.Проверить(тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                iValue := FLOOR(Value);
                мПров.Проверить(ASR(iValue, 5) = 0, line, col, мКо._ош45);
                ЕСЛИ proc = мКонст._stINCL ТОГДА
                  X86.PushConst(ORD({iValue}));
                  X86.StProc(мКонст._stINCL)
                ИНАЧЕ
                  X86.PushConst(ORD(-{iValue}));
                  X86.StProc(мКонст._stEXCL)
                КОНЕЦ
            |мКонст._stCOPY:
                Expr(e1);
                мПров.Проверить(мФк.ЕслиСтрока(e1), line, col, мКо._ош126);
                мФк.Проверить(мКонст._опЗпт);
                ЕСЛИ e1.тип.тип_узла = мКонст._тСтрока ТОГДА
                  str := мДец.Стр_Получ(e1.двЗнач);
                  ЕСЛИ str.Len = 1 ТОГДА
                    X86.Mono(str.Number);
                    X86.StrMono
                  КОНЕЦ
                КОНЕЦ;
                Str(e1);
                мФк.КоордСледующ_Уст(line, col);
                Designator(e2);
                мПров.Проверить(e2.eType = мКонст._eVAR, line, col, мКо._ош54);
                мПров.Проверить(мФк.ЕслиСтрока(e2), line, col, мКо._ош127);
                мПров.Проверить(~e2.Read, line, col, мКо._ош106);
                Str(e2);
                X86.StProc(мКонст._stCOPY)
            |мКонст._stNEW, мКонст._stDISPOSE:
                Designator(e1);
                мПров.Проверить(e1.eType = мКонст._eVAR, line, col, мКо._ош54);
                мПров.Проверить(~e1.Read, line, col, мКо._ош106);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тУказатель, line, col, мКо._ош128);
                ЕСЛИ proc = мКонст._stNEW ТОГДА
                  X86.PushConst(e1.тип.предок.Number);
                  X86.PushConst(X86.Align(e1.тип.предок.размер + 8, 32));
                  X86.newrec
                ИНАЧЕ
                  X86.disprec
                КОНЕЦ
            |мКонст._stASSERT:
                  Expr(e1);
                  мФк.Func_Assert(e1, line, col, Value, тип)
            |мКонст._stPACK, мКонст._stUNPK:
                Designator(e1);
                мФк.Func_PACK1(e1, line, col, Value, тип);
                ЕСЛИ proc = мКонст._stUNPK ТОГДА
                  Designator(e2);
                  мФк.Func_PACK2(e2, line, col, Value, тип);
                ИНАЧЕ
                  Expr(e2);
                  мФк.Func_PACK3(e1, e2, line, col, Value);
                КОНЕЦ
            |мКонст._sysBIT:
                Expr(e1);
                мФк.Func_BIT1(e1, line, col, Value);
                Expr(e1);
                мФк.Func_BIT2(e1, line, col, Value);
            |мКонст._sysPUT, мКонст._sysGET:
                begcall := X86.current;
                Expr(e1);
                мПров.Проверить(e1.тип.тип_узла = мКонст._тЦелое, line, col, мКо._ош43);
                мФк.Загрузить_Проверить(e1, мКонст._опЗпт);
                мФк.КоордСледующ_Уст(line, col);
                ЕСЛИ proc = мКонст._sysGET ТОГДА
                  X86.PushCall(begcall);
                  X86.Param;
                  Designator(e2);
                  мПров.Проверить(e2.eType = мКонст._eVAR, line, col, мКо._ош54);
                  мПров.Проверить(e2.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ,
                        мКонст._тСимвол, мКонст._TSET, мКонст._тБулево, мКонст._TCARD16}, line, col,
                        мКо._ош132);
                  мПров.Проверить(~e2.Read, line, col, мКо._ош106);
                  X86.EndCall;
                  X86.Load(e2.тип.тип_узла);
                  X86.Save(e2.тип.тип_узла)
                ИНАЧЕ
                  Expr(e2);
                  мПров.Проверить(e2.тип.тип_узла ВХОДИТ {мКонст._тЦелое, мКонст._тВеществ, мКонст._тДлинВещ,
                        мКонст._тСимвол, мКонст._TSET, мКонст._тБулево, мКонст._TCARD16, мКонст._тСтрока},
                        line, col, мКо._ош131);
                  ЕСЛИ e2.тип.тип_узла = мКонст._тСтрока ТОГДА
                    мПров.Проверить(мФк.Стр_Получ(e2.двЗнач) = 1, line, col, мКо._ош85)
                  КОНЕЦ;
                  мФк.Выражение_Загрузить(e2);
                  X86.Save(e2.тип.тип_узла)
                КОНЕЦ
            |мКонст._sysCODE:
                мПров.Проверить(мСкан.лекс_тип = мКонст._лекСтрока, line, col, мКо._ош130);
                мСкан.GetLexStr(Lex);
                CheckCode(Lex, мСкан.count - 1, line, col);
                X86.Asm(Lex);
                мДец.Лексем_Дальше
            |мКонст._sysMOVE:
                begcall := X86.current;
                Expr(e1);
                мФк.Func_MOVE1(e1, line, col, Value, begcall);
                Expr(e1);
                мФк.Func_MOVE2(e1, line, col, Value);
                Expr(e1);
                мФк.Func_MOVE3(e1, line, col, Value);
        ИНАЧЕ
            мПров.Проверить(ЛОЖЬ, line2, col2, мКо._ош123)
        КОНЕЦ;
        мФк.Проверка_Дальше(мКонст._опСкобПравКруг);
        ЕСЛИ proc = мКонст._sysMOVE ТОГДА
            X86.StProc(мКонст._sysMOVE);
        ИНЕСЛ proc = мКонст._sysBIT ТОГДА
            мФк.Проверить(мКонст._lexAssign);
            мФк.КоордСледующ_Уст(line, col);
            Expr(e1);
            мПров.Проверить(e1.тип.тип_узла = мКонст._тБулево, line, col, мКо._ош108);
            мФк.Выражение_Загрузить(e1);
            X86.StProc(мКонст._sysBIT)
        КОНЕЦ
    КОНЕЦ СисПроцедур_Уст;

ПРОЦЕДУРА IdentOper;
    ПЕРЕМ
        выраж1, выраж2: мДец.тВыражение;
        строка, позиц, ccall: ЦЕЛОЕ;
        вызов_начало: X86.тАсмУзел;
        s: мДец.STRCONST;
    НАЧАЛО
      мФк.Коорд_Уст(строка, позиц);
      вызов_начало := X86.current;
      Designator(выраж1);
      мПров.Проверить(выраж1.eType # мКонст._выражКонст, строка, позиц, мКо._ош121);
      ЕСЛИ (выраж1.eType = мКонст._eVAR) & (выраж1.тип.тип_узла # мКонст._TPROC) ТОГДА
        мФк.Проверить(мКонст._lexAssign);
        мПров.Проверить(~выраж1.Read, строка, позиц, мКо._ош106);
        мФк.КоордСледующ_Уст(строка, позиц);
        Expr(выраж2);
        мПров.Проверить(AssComp(выраж2, выраж1.тип, ЛОЖЬ), строка, позиц, мКо._ош122);
        мФк.Выражение_Загрузить(выраж2);
        ЕСЛИ выраж1.тип.тип_узла = мКонст._тЗапись ТОГДА
          X86.PushConst(выраж1.тип.размер);
          X86.PushConst(выраж1.тип.Number);
          ЕСЛИ выраж1.vparam ТОГДА
            X86.LocalAdr(выраж1.id.смещение - 4, мДец.модуль_текущ.уровень - выраж1.id.уровень);
            X86.Load(мКонст._тЦелое)
          ИНЕСЛ выраж1.deref ТОГДА
            X86.DerefType(12)
          ИНАЧЕ
            X86.PushConst(выраж1.тип.Number)
          КОНЕЦ
        ИНЕСЛ выраж2.тип.тип_узла = мКонст._тМассив ТОГДА
          X86.PushConst(выраж2.тип.размер)
        ИНЕСЛ (выраж2.тип.тип_узла = мКонст._тСтрока) & (выраж1.тип.тип_узла = мКонст._тМассив) ТОГДА
          s := мДец.Стр_Получ(выраж2.двЗнач);
          ЕСЛИ s.Len = 1 ТОГДА
            X86.Mono(s.Number)
          КОНЕЦ;
          X86.PushConst(мУтиль.Мин_Получ(s.Len + 1, выраж1.тип.глубина))
        КОНЕЦ;
        X86.Save(выраж1.тип.тип_узла)
      ИНЕСЛ выраж1.eType = мКонст._ePROC ТОГДА
        мПров.Проверить((выраж1.id.тип.предок.тип_узла = мКонст._TVOID) ИЛИ (выраж1.id.тип.вызов = мКонст._winapi),
                строка, позиц, мКо._ош123);
        ЕСЛИ выраж1.id.парам_число > 0 ТОГДА
          мФк.Проверка_Дальше(мКонст._lexLRound);
          X86.PushCall(вызов_начало);
          Call(выраж1.id.тип.поля.первый(мДец.туПоле));
          X86.EndCall
        ИНЕСЛ мСкан.лекс_тип = мКонст._lexLRound ТОГДА
          мФк.Следующ_Проверка(мКонст._опСкобПравКруг);
          мДец.Лексем_Дальше
        КОНЕЦ;
        ЕСЛИ выраж1.id.уровень = 3 ТОГДА
          ccall := 0
        ИНЕСЛ выраж1.id.уровень > мДец.curBlock.уровень ТОГДА
          ccall := 1
        ИНАЧЕ
          ccall := 2
        КОНЕЦ;
        X86.Call(выраж1.id.номер, ЛОЖЬ, ЛОЖЬ, выраж1.id.тип.вызов, ccall, выраж1.id.уровень - 3, мДец.curBlock.уровень - 3, выраж1.id.парам_размер, мДец.curBlock.локаль_размер)
      ИНЕСЛ выраж1.eType ВХОДИТ {мКонст._eSTPROC, мКонст._eSYSPROC} ТОГДА
        СисПроцедур_Уст(выраж1.id.StProc)
      ИНЕСЛ (выраж1.eType = мКонст._eVAR) & (выраж1.тип.тип_узла = мКонст._TPROC) ТОГДА
        ЕСЛИ мСкан.лекс_тип = мКонст._lexLRound ТОГДА
          мДец.Лексем_Дальше;
          мПров.Проверить((выраж1.тип.предок.тип_узла = мКонст._TVOID) ИЛИ (выраж1.тип.вызов = мКонст._winapi), строка, позиц,
                мКо._ош123);
          X86.PushCall(вызов_начало);
          Call(выраж1.тип.поля.первый(мДец.туПоле));
          X86.EndCall;
          X86.CallVar(ЛОЖЬ, ЛОЖЬ, выраж1.тип.вызов, выраж1.тип.глубина, мДец.curBlock.локаль_размер)
        ИНЕСЛ мСкан.лекс_тип = мКонст._lexAssign ТОГДА
          мПров.Проверить(~выраж1.Read, строка, позиц, мКо._ош106);
          мФк.КоордСледующ_Уст(строка, позиц);
          Expr(выраж2);
          мПров.Проверить(AssComp(выраж2, выраж1.тип, ЛОЖЬ), строка, позиц, мКо._ош122);
          мПров.Проверить(~((выраж2.eType = мКонст._ePROC) & (выраж2.id.уровень > 3)), строка, позиц, мКо._ош107);
          ЕСЛИ выраж2.eType = мКонст._eVAR ТОГДА
            X86.Load(мКонст._TPROC)
          КОНЕЦ;
          X86.Save(мКонст._TPROC)
        ИНАЧЕ
          мПров.Проверить2(выраж1.тип.поля.спис_длин = 0, мКо._ош133);
          мПров.Проверить((выраж1.тип.предок.тип_узла = мКонст._TVOID) ИЛИ (выраж1.тип.вызов = мКонст._winapi), строка, позиц,
                мКо._ош123);
          X86.CallVar(ЛОЖЬ, ЛОЖЬ, выраж1.тип.вызов, выраж1.тип.глубина, мДец.curBlock.локаль_размер)
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ IdentOper;

ПРОЦЕДУРА Повтор_Уст;
    НАЧАЛО
         мУтиль.ЮнитСтрока_Уст(мДец.модуль_ном, мСкан.строка_ном);
         ВЫБРАТЬ мСкан.лекс_тип ИЗ
             |мКонст._лекИмя: IdentOper
             |мКонст._лекЕсли, мКонст._лекПока: ОпЕслиПока_Уст(мСкан.лекс_тип = мКонст._лекПока)
             |мКонст._лекПовторять: ОпПовторять_Уст
             |мКонст._лекДля: ОпДля_Уст
             |мКонст._лекВыбрать: ОпВыбрать_Уст
         ИНАЧЕ
         КОНЕЦ
    КОНЕЦ Повтор_Уст;

ПРОЦЕДУРА OpSeq;
    НАЧАЛО
      Повтор_Уст;
      ПОКА мСкан.лекс_тип = мКонст._опТчкЗпт ДЕЛАТЬ
        мДец.Лексем_Дальше;
        Повтор_Уст
      КОНЕЦ
    КОНЕЦ OpSeq;

ПРОЦЕДУРА Старт;
    ПЕРЕМ
        SelfName, SelfPath, файл_имя, расшир, FName, Path, StdPath,
        Name, Ext, temp, system, стэк_стр, felf: мСтр.тСтрока;
        ос_ном, стэк_разм: ЦЕЛОЕ;

    ПРОЦЕДУРА СтэкМбРазмер_Получ(): ЦЕЛОЕ;
        ПЕРЕМ
            результ_Мб, итер: ЦЕЛОЕ;
        НАЧАЛО
            результ_Мб := 0;
            итер := 0;
            ПОКА мСкан.ЕслиЦифра(стэк_стр[итер]) ДЕЛАТЬ
                ДОБ(итер)
            КОНЕЦ;
            ЕСЛИ стэк_стр[итер] <= 20X ТОГДА
                стэк_стр[итер] := 0X;
                результ_Мб := мСкан.Стр2цел(стэк_стр)
            КОНЕЦ;
            ЕСЛИ результ_Мб = 0 ТОГДА
                результ_Мб := 1
            КОНЕЦ
            ВЕРНУТЬ результ_Мб
        КОНЕЦ СтэкМбРазмер_Получ;

    ПРОЦЕДУРА СтэкРазмер_Получ(): ЦЕЛОЕ;
        ПЕРЕМ
            результ, итер: ЦЕЛОЕ;
            бОшибка: БУЛЕВО;
        
        ПРОЦЕДУРА Если16(симв_: СИМВ): БУЛЕВО;
            ВЕРНУТЬ ("0" <= симв_) & (симв_ <= "9") ИЛИ
                ("A" <= симв_) & (симв_ <= "F") ИЛИ
                ("a" <= симв_) & (симв_ <= "f")
            КОНЕЦ Если16;

        ПРОЦЕДУРА Симв2число(симв_: СИМВ): ЦЕЛОЕ;
            ПЕРЕМ
                результ_числ: ЦЕЛОЕ;
            НАЧАЛО
                ЕСЛИ  ("0" <= симв_) & (симв_ <= "9") ТОГДА
                    результ_числ := ORD(симв_) - ORD("0")
                ИНЕСЛ ("A" <= симв_) & (симв_ <= "F") ТОГДА
                    результ_числ := ORD(симв_) - ORD("A") + 10
                ИНЕСЛ ("a" <= симв_) & (симв_ <= "f") ТОГДА
                    результ_числ := ORD(симв_) - ORD("a") + 10
                КОНЕЦ
                ВЕРНУТЬ результ_числ
            КОНЕЦ Симв2число;

       НАЧАЛО
            результ := 0;
            итер := 0;
            
            бОшибка := стэк_стр[итер] # "0";
            ДОБ(итер);
            
            бОшибка := бОшибка ИЛИ (стэк_стр[итер] # "x");
            ДОБ(итер);
            
            ПОКА ~бОшибка & Если16(стэк_стр[итер]) ДЕЛАТЬ
              ДОБ(итер)
            КОНЕЦ;
            бОшибка := бОшибка ИЛИ (итер = 2);
            ЕСЛИ стэк_стр[итер] <= 20X ТОГДА
              стэк_стр[итер] := 0X
            ИНАЧЕ
              бОшибка := ИСТИНА
            КОНЕЦ;
            итер := 2;
            ПОКА ~бОшибка & (стэк_стр[итер] # 0X) ДЕЛАТЬ
              результ := LSL(результ, 4) + Симв2число(стэк_стр[итер]);
              ДОБ(итер)
            КОНЕЦ;
            ЕСЛИ результ = 0 ТОГДА
              результ := 1
            КОНЕЦ
            ВЕРНУТЬ результ
       КОНЕЦ СтэкРазмер_Получ;

    НАЧАЛО
        ЕСЛИ мУтиль.парам_всего < 2 ТОГДА
            мОш.Сообщ(50);
            мПроц.Выход(1)
        КОНЕЦ;
        мУтиль.СтрПарам_Уст(SelfName, 0);
        мУтиль.СтрПарам_Уст(FName, 1);
        мУтиль.СтрПарам_Уст(system, 2);
        мУтиль.СтрПарам_Уст(стэк_стр, 3);
        pExpr := Expr;
        pFactor := Factor;
        pOpSeq := OpSeq;
        мУтиль.ФайлПуть_Разделить(FName, Path, Name, Ext);
        ЕСЛИ Ext # мКонст._расшир ТОГДА
            мОш.Сообщ(112);
            мПроц.Выход(1)
        КОНЕЦ;
        мУтиль.ФайлПуть_Разделить(SelfName, SelfPath, файл_имя, расшир);
        temp := Name;
        ЕСЛИ мУтиль.Стр_соединить(system, "obj") ТОГДА
            ос_ном := мКонст._прОб;
            мУтиль.ТриСтр_соединить(temp, ".obj", temp)
        ИНЕСЛ мУтиль.Стр_соединить(system, "elf") ТОГДА
            ос_ном := 5;
            felf := SelfPath;
            мУтиль.ТриСтр_соединить(felf, "Elf", felf);
            X86.setfelf(felf)
        ИНЕСЛ мУтиль.Стр_соединить(system, "kos") ТОГДА
            ос_ном := 4;
            мУтиль.ТриСтр_соединить(temp, ".kex", temp)
        ИНЕСЛ мУтиль.Стр_соединить(system, "con") ТОГДА
            ос_ном := 3;
            мУтиль.ТриСтр_соединить(temp, ".exe", temp)
        ИНЕСЛ мУтиль.Стр_соединить(system, "gui") ТОГДА
            ос_ном := 2;
            мУтиль.ТриСтр_соединить(temp, ".exe", temp)
        ИНЕСЛ мУтиль.Стр_соединить(system, "dll") ТОГДА
            ос_ном := 1;
            мУтиль.ТриСтр_соединить(temp, ".dll", temp)
        ИНАЧЕ
            мОш.Сообщ(51);
            мПроц.Выход(1)
        КОНЕЦ;
        ЕСЛИ ос_ном ВХОДИТ {1,2,3,4} ТОГДА
            стэк_разм := СтэкМбРазмер_Получ()
        ИНАЧЕ
            стэк_разм := 1
        КОНЕЦ;
        ЕСЛИ ос_ном = мКонст._прОб ТОГДА
            стэк_разм := СтэкРазмер_Получ()
        КОНЕЦ;
        мУтиль.ТриСтр_соединить(SelfPath, "Lib", SelfPath);
        мУтиль.ТриСтр_соединить(SelfPath, мКонст._слэш, SelfPath);
        ЕСЛИ ос_ном = 5 ТОГДА
            мУтиль.ТриСтр_соединить(SelfPath, "Linux32", SelfPath)
        ИНЕСЛ ос_ном ВХОДИТ {4, 6} ТОГДА
            мУтиль.ТриСтр_соединить(SelfPath, "KolibriOS", SelfPath)
        ИНЕСЛ ос_ном ВХОДИТ {1, 2, 3} ТОГДА
            мУтиль.ТриСтр_соединить(SelfPath, "Windows32", SelfPath)
        КОНЕЦ;
        мУтиль.ТриСтр_соединить(SelfPath, мКонст._слэш, SelfPath);
        X86.Init(мДец.MemErr, ос_ном);
        X86.Prolog(temp);
        мДец.Program(SelfPath, Path, Name, Ext, ос_ном ВХОДИТ {1, 2, 3}, OpSeq, Expr, AssComp, sttypes);
        мДец.Компилировать(ос_ном, стэк_разм);
        мКонс.Стр_Печать(" =Выполнено="); мКонс.Стр_Нов;
        мКонс.ВремяКомпил_Печать
    КОНЕЦ Старт;

НАЧАЛО
  Старт
КОНЕЦ Compiler.
