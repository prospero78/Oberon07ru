(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
   *)
лндскэ Compiler;

хлонпр DECL := ЛНДдЕЖК,
    ЛяЙЮМ := ЛНДяЙЮМЕП,
    ЛсРХКЭ := ЛНДсРХКЭ,
    X86 := ЛНДюЯЛ86_32,
    SYSTEM,
    ЛрХОШ := ЛНДрХОШ,
    ЛйНМЯР := ЛНДйНМЯРЮМРШ,
    ЛйНМЯ := ЛНДйНМЯНКЭ,
    ЛнЬ := ЛНДнЬХАЙХ,
    ЛоПНЖ := ЛНДоПНЖЕЯЯ,
    ЛяРП := ЛНДяРПНЙХ,
    ЛяОХЯ := ЛНДяОХЯНЙ,
    ЛоПНБ := ЛНДоПНБЕПЙЮ;

йнмяр

  lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
  lxBY = 3; lxDIV = 6;
  lxMOD = 17; 

  lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54; lxNot = 55; lxAnd = 56; lxComma = 57; lxSemi = 58;
  lxStick = 59; lxLRound = 60; lxLSquare = 61; lxLCurly = 62; lxCaret = 63; lxRRound = 64; lxRSquare = 65;
  lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69; lxColon = 70;
  lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7;
  TNIL = 8; TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

  IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

  stABS = 1; stODD = 2; stLEN = 3; stLSL = 4; stASR = 5; stROR = 6; stFLOOR = 7; stFLT = 8;
  stORD = 9; stCHR = 10; stLONG = 11; stSHORT = 12; stINC = 13; stDEC = 14; stINCL = 15;
  stEXCL = 16; stCOPY = 17; stNEW = 18; stASSERT = 19; stPACK = 20; stUNPK = 21; stDISPOSE = 22;
  stBITS = 23; stLSR = 24; stLENGTH = 25;

  sysADR = 101; sysSIZE = 102; sysBIT = 103; sysGET = 104; sysPUT = 105; sysCODE = 106;
  sysTYPEID = 107; sysMOVE = 108;

рхош

  LABEL = сйюгюрекэ мю гюохяэ (ЛрХОШ.РоСМЙР)
      a, b: INTEGER
    йнмеж;

оепел
  pExpr, pFactor: опнжедспю (оеп e: DECL.РбШПЮФЕМХЕ);
  pOpSeq: опнжедспю;
  Lex: ЛяРП.РяРПНЙЮ;
  sttypes: DECL.РСрХОмЮАНП;

опнжедспю Load(e: DECL.РбШПЮФЕМХЕ);
  мювюкн
    еякх e.eType = eVAR рнцдю
      X86.Load(e.T.tType)
    йнмеж
  йнмеж Load;

опнжедспю LenString(adr: LONGREAL): INTEGER;
  оепел
    s: DECL.РСйНМЯРяРП;
  мювюкн
    s := DECL.яРП_оНКСВ(adr)
    бепмсрэ s.Len
  йнмеж LenString;

опнжедспю Coord(оеп line, col: INTEGER);
  мювюкн
    line := ЛяЙЮМ.line;
    col := ЛяЙЮМ.col
  йнмеж Coord;

опнжедспю Assert(cond: BOOLEAN; line, col, code: INTEGER);
  мювюкн
    еякх ~cond рнцдю
      ЛоПНБ.рЕЯР(кнфэ, line, col, code)
    йнмеж
  йнмеж Assert;

опнжедспю Assert2(cond: BOOLEAN; code: INTEGER);
  мювюкн
    еякх ~cond рнцдю
      ЛоПНБ.рЕЯР(кнфэ, ЛяЙЮМ.line, ЛяЙЮМ.col, code)
    йнмеж
  йнмеж Assert2;

опнжедспю Next;
  мювюкн
    DECL.Next
  йнмеж Next;

опнжедспю Check(key: INTEGER);
  мювюкн
    DECL.Check(key)
  йнмеж Check;

опнжедспю BaseOf(T0, T1: DECL.РСрХО): BOOLEAN;
  мювюкн
    еякх (T0.tType = T1.tType) & (T0.tType IN {TRECORD, TPOINTER}) рнцдю
      еякх T0.tType = TPOINTER рнцдю
        T0 := T0.Base;
        T1 := T1.Base
      йнмеж;
      онйю (T1 # осярн) & (T1 # T0) декюрэ
        T1 := T1.Base
      йнмеж
    йнмеж
    бепмсрэ T0 = T1
  йнмеж BaseOf;

опнжедспю Designator(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    id: DECL.РСхЛЪ;
    name: ЛрХОШ.РСсГЕК;
    e1: DECL.РбШПЮФЕМХЕ;
    line, col, i, n, bases, glob, loc, idx: INTEGER;
    imp, break, guard: BOOLEAN;
    f: DECL.РСоНКЕ;
    T, BaseT: DECL.РСрХО;
    s: DECL.РСйНМЯРяРП;

    опнжедспю LoadVar;
    мювюкн
      еякх glob # -1 рнцдю
        X86.GlobalAdr(glob);
        glob := -1
      юеякх loc # -1 рнцдю
        X86.LocalAdr(loc, bases);
        loc := -1
      йнмеж
    йнмеж LoadVar;

  мювюкн
    glob := -1;
    loc := -1;
    Coord(line, col);
    Check(lxIDENT);
    name := ЛяЙЮМ.id;
    id := DECL.GetIdent(name);
    еякх (id # осярн) & (id.iType = IDMOD) рнцдю
      Next;
      Check(lxDot);
      Next;
      Check(lxIDENT);
      Coord(line, col);
      name := ЛяЙЮМ.id;
      imp := id.Unit # DECL.unit;
      id := DECL.GetQIdent(id.Unit, name)
    йнмеж;
    Assert(id # осярн, line, col, 42);
    e.vparam := кнфэ;
    e.deref := кнфэ;
    e.id := id;
    Next;
    бшанп id.iType хг
    |IDVAR:
      e.eType := eVAR;
      e.T := id.T;
      еякх id.VarKind = 0 рнцдю
        e.Read := imp
      хмюве
        e.Read := (id.VarKind = DECL.param) & (id.T.tType IN {TRECORD, TARRAY});
        e.vparam := id.VarKind = DECL.paramvar
      йнмеж;
      bases := DECL.unit.Level - id.Level;
      еякх id.Level = 3 рнцдю
        glob := id.Offset
      юеякх (id.VarKind = 0) хкх (id.VarKind = DECL.param) & ~(id.T.tType IN {TARRAY, TRECORD}) рнцдю
        loc := id.Offset
      юеякх (id.VarKind = DECL.paramvar) хкх (id.T.tType IN {TARRAY, TRECORD}) рнцдю
        еякх DECL.Dim(e.T) > 0 рнцдю
          n := DECL.Dim(e.T);
          дкъ i := n дн 1 BY -1 декюрэ
            X86.LocalAdr(id.Offset + i * 4, bases);
            X86.Load(TINTEGER)
          йнмеж
        йнмеж;
        X86.LocalAdr(id.Offset, bases);
        X86.Load(TINTEGER)
      йнмеж
    |IDCONST:
      Assert(id.T # осярн, line, col, 75);
      e.eType := eCONST;
      e.T := id.T;
      e.Value := id.Value;
      еякх id.T.tType IN {TINTEGER, TSET, TBOOLEAN} рнцдю
        X86.PushConst(FLOOR(e.Value))
      юеякх id.T.tType IN {TREAL, TLONGREAL} рнцдю
        X86.PushFlt(e.Value)
      юеякх id.T.tType = TSTRING рнцдю
        s := DECL.яРП_оНКСВ(e.Value);
        еякх s.Len = 1 рнцдю
          X86.PushConst(ORD(s.Str[0]))
        хмюве
          X86.PushInt(s.Number)
        йнмеж
      йнмеж
    |IDPROC:
      e.eType := ePROC;
      e.T := sttypes[TVOID]
    |IDTYPE:
      Assert(кнфэ, line, col, 101)
    |IDSTPROC:
      e.eType := eSTPROC;
      e.T := sttypes[TVOID]
    |IDSYSPROC:
      e.eType := eSYSPROC;
      e.T := sttypes[TVOID]
    хмюве
    йнмеж;
    break := кнфэ;
    guard := кнфэ;
    онбрнпърэ
      бшанп ЛяЙЮМ.tLex хг
      |lxDot:
        e.deref := кнфэ;
        Assert2(e.T.tType IN {TPOINTER, TRECORD}, 105);
        еякх e.T.tType = TPOINTER рнцдю
          e.Read := кнфэ;
          LoadVar;
          e.T := e.T.Base;
          X86.Load(TINTEGER);
          еякх ~guard рнцдю
            X86.CheckNIL
          йнмеж
        йнмеж;
        Next;
        Check(lxIDENT);
        Coord(line, col);
        name := ЛяЙЮМ.id;
        T := e.T;
        онбрнпърэ
          f := DECL.GetField(T, name);
          T := T.Base
        онйюме (f # осярн) хкх (T = осярн);
        Assert(f # осярн, line, col, 99);
        еякх f.Unit # DECL.unit рнцдю
          Assert(f.Export, line, col, 99)
        йнмеж;
        еякх glob # -1 рнцдю
          glob := glob + f.Offset
        юеякх loc # -1 рнцдю
          loc := loc + f.Offset
        хмюве
          X86.Field(f.Offset)
        йнмеж;
        e.T := f.T;
        e.vparam := кнфэ;
        guard := кнфэ;
        Next
      |lxLSquare:
        LoadVar;
        онбрнпърэ
          Assert2(e.T.tType = TARRAY, 102);
          Next;
          Coord(line, col);
          pExpr(e1);
          Assert(e1.T.tType = TINTEGER, line, col, 52);
          Load(e1);
          еякх e.T.Len = 0 рнцдю
            BaseT := DECL.OpenBase(e.T);
            X86.PushConst(BaseT.Size);
            X86.OpenIdx(DECL.Dim(e.T))
          хмюве
            еякх e1.eType = eCONST рнцдю
              idx := FLOOR(e1.Value);
              Assert((idx >= 0) & (idx < e.T.Len), line, col, 159);
              еякх e.T.Base.Size # 1 рнцдю
                X86.Drop;
                X86.PushConst(e.T.Base.Size * idx)
              йнмеж;
              X86.Idx
            хмюве
              X86.FixIdx(e.T.Len, e.T.Base.Size)
            йнмеж
          йнмеж;
          e.T := e.T.Base
        онйюме ЛяЙЮМ.tLex # lxComma;
        Check(lxRSquare);
        e.vparam := кнфэ;
        guard := кнфэ;
        Next
      |lxCaret:
        LoadVar;
        Assert2(e.T.tType = TPOINTER, 104);
        e.Read := кнфэ;
        X86.Load(TINTEGER);
        еякх ~guard рнцдю
          X86.CheckNIL
        йнмеж;
        e.T := e.T.Base;
        e.vparam := кнфэ;
        e.deref := хярхмю;
        guard := кнфэ;
        Next
      |lxLRound:
        LoadVar;
        еякх e.T.tType IN {TRECORD, TPOINTER} рнцдю
          еякх e.T.tType = TRECORD рнцдю
            Assert2(e.vparam, 108)
          йнмеж;
          Next;
          Check(lxIDENT);
          Coord(line, col);
          T := DECL.IdType(line, col);
          Assert(T # осярн, line, col, 42);
          еякх e.T.tType = TRECORD рнцдю
            Assert(T.tType = TRECORD, line, col, 106)
          хмюве
            Assert(T.tType = TPOINTER, line, col, 107)
          йнмеж;
          Assert(BaseOf(e.T, T), line, col, 108);
          e.T := T;
          Check(lxRRound);
          Next;
          еякх e.T.tType = TPOINTER рнцдю
            еякх (ЛяЙЮМ.tLex = lxDot) хкх (ЛяЙЮМ.tLex = lxCaret) рнцдю
              X86.DupLoadCheck
            хмюве
              X86.DupLoad
            йнмеж;
            guard := хярхмю;
            T := T.Base
          хмюве
            X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
          йнмеж;
          X86.Guard(T.Number, кнфэ)
        хмюве
          break := хярхмю
        йнмеж
      хмюве
        break := хярхмю
      йнмеж
    онйюме break;
    LoadVar
  йнмеж Designator;

опнжедспю Set(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    a, b: DECL.РбШПЮФЕМХЕ;
    line, col: INTEGER;
    s: SET; flag: BOOLEAN;
  мювюкн
    Next;
    e.eType := eEXP;
    e.T := sttypes[TSET];
    e.Value := 0.0D0;
    e.vparam := кнфэ;
    s := {};
    flag := хярхмю;
    X86.PushConst(0);
    онйю ЛяЙЮМ.tLex # lxRCurly декюрэ
      Coord(line, col);
      pExpr(a);
      Assert(a.T.tType = TINTEGER, line, col, 52);
      еякх a.eType = eCONST рнцдю
        Assert(ASR(FLOOR(a.Value), 5) = 0, line, col, 53)
      йнмеж;
      Load(a);
      b := a;
      еякх ЛяЙЮМ.tLex = lxDbl рнцдю
        Next;
        Coord(line, col);
        pExpr(b);
        Assert(b.T.tType = TINTEGER, line, col, 52);
        еякх b.eType = eCONST рнцдю
          Assert(ASR(FLOOR(b.Value), 5) = 0, line, col, 53);
          Assert(a.Value <= b.Value, line, col, 54)
        йнмеж;
        Load(b)
      хмюве
        X86.Dup
      йнмеж;
      X86.rset;
      X86.Set(lxPlus);
      flag := (a.eType = eCONST) & (b.eType = eCONST) & flag;
      еякх flag рнцдю
        s := s + {FLOOR(a.Value) .. FLOOR(b.Value)}
      йнмеж;
      еякх ЛяЙЮМ.tLex = lxComma рнцдю
        Next;
        Assert2(ЛяЙЮМ.tLex # lxRCurly, 36)
      хмюве
        Check(lxRCurly)
      йнмеж
    йнмеж;
    еякх flag рнцдю
      e.Value := LONG(FLT(ORD(s)));
      e.eType := eCONST
    йнмеж;
    Next
  йнмеж Set;

опнжедспю IsString(a: DECL.РбШПЮФЕМХЕ): BOOLEAN;
    бепмсрэ (a.T.tType = TSTRING) хкх (a.T.tType = TARRAY) & (a.T.Base.tType = TCHAR)
  йнмеж IsString;

опнжедспю Str(e: DECL.РбШПЮФЕМХЕ);
  оепел
    A: X86.TIDX;
  мювюкн
    еякх (e.T.tType = TARRAY) & (e.T.Base.tType = TCHAR) & (e.T.Len # 0) рнцдю
      A[0] := e.T.Len;
      X86.OpenArray(A, 1)
    юеякх e.T.tType = TSTRING рнцдю
      A[0] := LenString(e.Value) + 1;
      еякх A[0] # 2 рнцдю
        X86.OpenArray(A, 1)
      йнмеж
    йнмеж
  йнмеж Str;

опнжедспю StFunc(оеп e: DECL.РбШПЮФЕМХЕ; func: INTEGER);
  оепел
    line, col, line2, col2, a, b, p: INTEGER;
    e1, e2: DECL.РбШПЮФЕМХЕ;
    T: DECL.РСрХО;
    str, str2: DECL.РСйНМЯРяРП;
  мювюкн
    e.vparam := кнфэ;
    e.eType := eEXP;
    Coord(line2, col2);
    Check(lxLRound);
    Next;
    Coord(line, col);
    бшанп func хг
    |stABS:
      pExpr(e1);
      Assert(e1.T.tType IN {TINTEGER, TREAL, TLONGREAL}, line, col, 57);
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        e.Value := ABS(e1.Value);
        e.eType := eCONST;
        Assert(~((e1.T.tType = TINTEGER) & (e1.Value = LONG(FLT(ЛйНМЯР.ЖЕКНЕ_ЛХМ)))), line, col, DECL.IOVER)
      йнмеж;
      еякх e1.T.tType = TINTEGER рнцдю
        X86.StFunc(X86.stABS)
      хмюве
        X86.StFunc(X86.stFABS)
      йнмеж;
      e.T := e1.T
    |stODD:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        e.Value := LONG(FLT(ORD(ODD(FLOOR(e1.Value)))));
        e.eType := eCONST
      йнмеж;
      X86.StFunc(X86.stODD);
      e.T := sttypes[TBOOLEAN]
    |stLEN:
      Designator(e1);
      Assert((e1.eType = eVAR) & (e1.T.tType = TARRAY), line, col, 102);
      еякх e1.T.Len > 0 рнцдю
        X86.Len(-e1.T.Len)
      хмюве
        X86.Len(DECL.Dim(e1.T))
      йнмеж;
      e.T := sttypes[TINTEGER]
    |stLSL, stASR, stROR, stLSR:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      pExpr(e2);
      Assert(e2.T.tType = TINTEGER, line, col, 52);
      Load(e2);
      еякх (e1.eType = eCONST) & (e2.eType = eCONST) рнцдю
        a := FLOOR(e1.Value);
        b := FLOOR(e2.Value);
        бшанп func хг
        |stLSL: a := LSL(a, b)
        |stASR: a := ASR(a, b)
        |stROR: a := ROR(a, b)
        |stLSR: a := LSR(a, b)
        хмюве
        йнмеж;
        e.Value := LONG(FLT(a));
        e.eType := eCONST
      йнмеж;
      бшанп func хг
      |stLSL: X86.StFunc(X86.stLSL)
      |stASR: X86.StFunc(X86.stASR)
      |stROR: X86.StFunc(X86.stROR)
      |stLSR: X86.StFunc(X86.stLSR)
      хмюве
      йнмеж;
      e.T := sttypes[TINTEGER]
    |stFLOOR:
      pExpr(e1);
      Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 66);
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        Assert((e1.Value - 1.0D0 < LONG(FLT(ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ))) & (e1.Value >= LONG(FLT(ЛйНМЯР.ЖЕКНЕ_ЛХМ))), line, col, 74);
        e.Value := LONG(FLT(FLOOR(e1.Value)));
        e.eType := eCONST
      йнмеж;
      X86.StFunc(X86.stFLOOR);
      e.T := sttypes[TINTEGER]
    |stFLT:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        e.Value := e1.Value;
        e.eType := eCONST
      йнмеж;
      X86.StFunc(X86.stFLT);
      e.T := sttypes[TREAL]
    |stORD:
      pExpr(e1);
      Assert(e1.T.tType IN {TCHAR, TBOOLEAN, TSET, TSTRING}, line, col, 68);
      еякх e1.T.tType = TSTRING рнцдю
        Assert(LenString(e1.Value) = 1, line, col, 94)
      йнмеж;
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        еякх e1.T.tType = TSTRING рнцдю
          str := DECL.яРП_оНКСВ(e1.Value);
          e.Value := LONG(FLT(ORD(str.Str[0])))
        хмюве
          e.Value := e1.Value
        йнмеж;
        e.eType := eCONST
      йнмеж;
      еякх e1.T.tType = TBOOLEAN рнцдю
        X86.StFunc(X86.stORD)
      йнмеж;
      e.T := sttypes[TINTEGER]
    |stBITS:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      еякх e1.eType = eCONST рнцдю
        e.Value := e1.Value;
        e.eType := eCONST
      йнмеж;
      e.T := sttypes[TSET]
    |stCHR:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      e.T := sttypes[TCHAR];
      еякх e1.eType = eCONST рнцдю
        Assert(ASR(FLOOR(e1.Value), 8) = 0, line, col, 76);
        str2 := DECL.AddMono(CHR(FLOOR(e1.Value)));
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        e.T := sttypes[TSTRING];
        e.eType := eCONST
      йнмеж
    |stLONG:
      pExpr(e1);
      Assert(e1.T.tType = TREAL, line, col, 71);
      еякх e1.eType = eCONST рнцдю
        e.Value := e1.Value;
        e.eType := eCONST
      йнмеж;
      Load(e1);
      e.T := sttypes[TLONGREAL]
    |stSHORT:
      pExpr(e1);
      Assert(e1.T.tType = TLONGREAL, line, col, 70);
      еякх e1.eType = eCONST рнцдю
        Assert(ABS(e1.Value) <= LONG(ЛйНМЯР.БЕЫ_ЛЮЙЯ), line, col, DECL.FOVER);
        Assert(ABS(e1.Value) >= LONG(ЛйНМЯР.БЕЫ_ЛХМ), line, col, DECL.UNDER);
        e.Value := e1.Value;
        e.eType := eCONST
      йнмеж;
      Load(e1);
      e.T := sttypes[TREAL]
    |stLENGTH:
      pExpr(e1);
      Assert(IsString(e1), line, col, 141);
      еякх e1.T.tType = TSTRING рнцдю
        str := DECL.яРП_оНКСВ(e1.Value);
        еякх str.Len = 1 рнцдю
          X86.Mono(str.Number);
          X86.StrMono
        йнмеж;
        e.Value := LONG(FLT(LENGTH(str.Str)));
        e.eType := eCONST
      йнмеж;
      Str(e1);
      e.T := sttypes[TINTEGER];
      X86.StFunc(X86.stLENGTH)
    |sysADR:
      Assert((ЛяЙЮМ.tLex = lxIDENT) хкх (ЛяЙЮМ.tLex = lxSTRING) хкх (ЛяЙЮМ.tLex = lxCHX), line, col, 43);
      еякх ЛяЙЮМ.tLex = lxIDENT рнцдю
        Designator(e1);
        Assert((e1.eType = eVAR) хкх (e1.eType = ePROC) хкх (e1.T = sttypes[TSTRING]), line, col, 43);
        еякх e1.eType = ePROC рнцдю
          X86.PushInt(e1.id.Number)
        йнмеж
      хмюве
        pFactor(e1)
      йнмеж;
      еякх e1.T = sttypes[TSTRING] рнцдю
        str := DECL.яРП_оНКСВ(e1.Value);
        еякх str.Len = 1 рнцдю
          X86.Drop;
          X86.PushInt(str.Number)
        йнмеж
      йнмеж;
      e.T := sttypes[TINTEGER];
      X86.ADR(DECL.Dim(e1.T))
    |sysBIT:
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      pExpr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      X86.StFunc(X86.sysBIT);
      e.T := sttypes[TBOOLEAN]
    |sysSIZE, sysTYPEID:
      DECL.оПНЖЕДСПпЮГЛ_сЯР;
      Check(lxIDENT);
      T := DECL.IdType(line, col);
      Assert(T # осярн, line, col, 42);
      e.eType := eCONST;
      e.T := sttypes[TINTEGER];
      еякх func = sysTYPEID рнцдю
        Assert(T.tType IN {TRECORD, TPOINTER}, line, col, 47);
        еякх T.tType = TPOINTER рнцдю
          T := T.Base
        йнмеж;
        e.Value := LONG(FLT(T.Number));
        X86.PushConst(T.Number)
      хмюве
        e.Value := LONG(FLT(T.Size));
        X86.PushConst(T.Size)
      йнмеж
    хмюве
      Assert(кнфэ, line2, col2, 73)
    йнмеж;
    Check(lxRRound);
    Next
  йнмеж StFunc;

опнжедспю ProcTypeComp(T1, T2: DECL.РСрХО): BOOLEAN;
  оепел
    sp: INTEGER;
    stk: люяяхб 100, 2 хг DECL.РСрХО;

    опнжедспю ProcTypeComp1(T1, T2: DECL.РСрХО): BOOLEAN;
      оепел
        fp, ft: DECL.РСоНКЕ;
        Res: BOOLEAN;

      опнжедспю TypeComp(T1, T2: DECL.РСрХО): BOOLEAN;
        оепел
          Res: BOOLEAN;
        мювюкн
          еякх (T1.tType = TARRAY) & (T2.tType = TARRAY) & (T1.Len = 0) & (T2.Len = 0) рнцдю
            Res := TypeComp(T1.Base, T2.Base)
          хмюве
            Res := ProcTypeComp1(T1, T2)
          йнмеж
          бепмсрэ Res
        йнмеж TypeComp;

      опнжедспю Check(): BOOLEAN;
        оепел
          i: INTEGER;
          res: BOOLEAN;
        мювюкн
          i := 0;
          res := кнфэ;
          онйю (i < sp) & ~res декюрэ
            res := ((stk[i][0] = T1) & (stk[i][1] = T2)) хкх ((stk[i][0] = T2) & (stk[i][1] = T1));
            INC(i)
          йнмеж
          бепмсрэ res
        йнмеж Check;

      мювюкн
        INC(sp);
        stk[sp][0] := T1;
        stk[sp][1] := T2;
        еякх Check() рнцдю
          Res := хярхмю
        хмюве
          еякх (T1.tType = TPROC) & (T2.tType = TPROC) & (T1 # T2) рнцдю
            Res := (T1.Call = T2.Call) & (T1.Fields.ЯВЕРВХЙ = T2.Fields.ЯВЕРВХЙ) & ProcTypeComp1(T1.Base, T2.Base);
            fp := T1.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ);
            ft := T2.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ);
            онйю Res & (fp # осярн) декюрэ
              Res := (fp.ByRef = ft.ByRef) & TypeComp(fp.T, ft.T);
              fp := fp.ЯКЕДСЧЫ(DECL.РСоНКЕ);
              ft := ft.ЯКЕДСЧЫ(DECL.РСоНКЕ)
            йнмеж
          хмюве
            Res := T1 = T2
          йнмеж
        йнмеж;
        DEC(sp)
        бепмсрэ Res
      йнмеж ProcTypeComp1;

  мювюкн
    sp := -1
    бепмсрэ ProcTypeComp1(T1, T2)
  йнмеж ProcTypeComp;

опнжедспю ArrComp(Ta, Tf: DECL.РСрХО): BOOLEAN;
  оепел
    Res: BOOLEAN;
  мювюкн
    еякх (Tf.tType = TARRAY) & (Tf.Len = 0) & (Ta.tType = TARRAY) рнцдю
      Res := ArrComp(Ta.Base, Tf.Base)
    хмюве
      Res := ProcTypeComp(Ta, Tf)
    йнмеж
    бепмсрэ Res
  йнмеж ArrComp;

опнжедспю AssComp(e: DECL.РбШПЮФЕМХЕ; T: DECL.РСрХО; param: BOOLEAN): BOOLEAN;
  оепел
    Res: BOOLEAN;
  мювюкн
    бшанп T.tType хг
    |TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN, TCARD16:
      Res := e.T = T
    |TCHAR:
      еякх e.T.tType = TSTRING рнцдю
        Res := LenString(e.Value) = 1
      хмюве
        Res := e.T.tType = TCHAR
      йнмеж
    |TARRAY:
      еякх param рнцдю
        еякх T.Len = 0 рнцдю
          еякх (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) рнцдю
            Res := хярхмю
          хмюве
            Res := ArrComp(e.T, T)
          йнмеж
        хмюве
          еякх (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) рнцдю
            Res := LenString(e.Value) <= T.Len
          хмюве
            Res := e.T = T
          йнмеж
        йнмеж
      хмюве
        еякх T.Len = 0 рнцдю
          Res := кнфэ
        юеякх (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) рнцдю
          Res := LenString(e.Value) <= T.Len
        хмюве
          Res := e.T = T
        йнмеж
      йнмеж
    |TRECORD: Res := BaseOf(T, e.T)
    |TPOINTER: Res := BaseOf(T, e.T) хкх (e.T.tType = TNIL)
    |TPROC: Res := (e.T.tType = TNIL) хкх (e.eType = ePROC) & ProcTypeComp(e.id.T, T) хкх
      (e.eType # ePROC) & ProcTypeComp(e.T, T)
    хмюве
      Res := кнфэ
    йнмеж
    бепмсрэ Res
  йнмеж AssComp;

опнжедспю ParamComp(e: DECL.РбШПЮФЕМХЕ; T: DECL.РСрХО; ByRef: BOOLEAN): BOOLEAN;
  оепел
    Res: BOOLEAN;
  мювюкн
    еякх ByRef рнцдю
      еякх e.eType = eVAR рнцдю
        бшанп T.tType хг
        |TINTEGER, TREAL, TLONGREAL, TCHAR,
         TSET, TBOOLEAN, TPOINTER, TCARD16:
          Res := e.T = T
        |TARRAY:
          еякх T.Len > 0 рнцдю
            Res := e.T = T
          хмюве
            Res := ArrComp(e.T, T)
          йнмеж
        |TRECORD:
          Res := BaseOf(T, e.T)
        |TPROC:
          Res := ProcTypeComp(e.T, T)
        хмюве
        йнмеж
      хмюве
        Res := кнфэ
      йнмеж
    хмюве
      Res := AssComp(e, T, хярхмю)
    йнмеж
    бепмсрэ Res
  йнмеж ParamComp;

опнжедспю Call(param: DECL.РСоНКЕ);
  оепел
    line, col, i, n: INTEGER;
    e1: DECL.РбШПЮФЕМХЕ;
    s: DECL.РСйНМЯРяРП;
    A: X86.TIDX;
    TA: DECL.РСрХО;
  мювюкн
    онйю param # осярн декюрэ
      Coord(line, col);
      X86.Param;
      pExpr(e1);
      Assert(ParamComp(e1, param.T, param.ByRef), line, col, 114);
      Assert(~(param.ByRef & e1.Read), line, col, 115);
      Assert(~((e1.eType = ePROC) & (e1.id.Level > 3)), line, col, 116);
      еякх (e1.eType = eVAR) & ~param.ByRef рнцдю
        X86.Load(e1.T.tType)
      йнмеж;
      еякх param.ByRef & (e1.T.tType = TRECORD) рнцдю
        еякх e1.vparam рнцдю
          X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
          X86.Load(TINTEGER)
        юеякх e1.deref рнцдю
          X86.DerefType(0)
        хмюве
          X86.PushConst(e1.T.Number)
        йнмеж
      йнмеж;
      еякх ~param.ByRef & (param.T.tType IN {TREAL, TLONGREAL}) рнцдю
        X86.DropFpu(param.T.tType = TLONGREAL)
      йнмеж;
      еякх (e1.T.tType = TSTRING) & (param.T.tType = TARRAY) рнцдю
        s := DECL.яРП_оНКСВ(e1.Value);
        еякх s.Len = 1 рнцдю
          X86.Mono(s.Number)
        йнмеж;
        еякх param.T.Len = 0 рнцдю
          A[0] := s.Len + 1;
          X86.OpenArray(A, 1)
        йнмеж
      йнмеж;
      еякх (e1.T.tType = TARRAY) & (DECL.Dim(param.T) > DECL.Dim(e1.T)) рнцдю
        n := DECL.Dim(param.T) - DECL.Dim(e1.T);
        TA := DECL.OpenBase(e1.T);
        дкъ i := 0 дн n - 1 декюрэ
          A[i] := TA.Len;
          TA := TA.Base
        йнмеж;
        еякх DECL.Dim(e1.T) = 0 рнцдю
          X86.OpenArray(A, n)
        хмюве
          X86.ExtArray(A, n, DECL.Dim(e1.T))
        йнмеж
      йнмеж;
      param := param.ЯКЕДСЧЫ(DECL.РСоНКЕ);
      еякх param # осярн рнцдю
        Check(lxComma);
        Next
      йнмеж
    йнмеж;
    Check(lxRRound);
    Next
  йнмеж Call;

опнжедспю Factor(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    line, col, ccall, p: INTEGER;
    begcall: X86.ASMLINE;
    s, str2: DECL.РСйНМЯРяРП;
  мювюкн
    e.eType := eCONST;
    e.vparam := кнфэ;
    бшанп ЛяЙЮМ.tLex хг
    |lxIDENT:
      begcall := X86.current;
      Designator(e);
      еякх e.eType = ePROC рнцдю
        еякх ЛяЙЮМ.tLex = lxLRound рнцдю
          Assert2(e.id.T.Base.tType # TVOID, 73);
          Next;
          X86.PushCall(begcall);
          Call(e.id.T.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ));
          X86.EndCall;
          e.eType := eEXP;
          e.T := e.id.T.Base;
          еякх e.id.Level = 3 рнцдю
            ccall := 0
          юеякх e.id.Level > DECL.curBlock.Level рнцдю
            ccall := 1
          хмюве
            ccall := 2
          йнмеж;
          X86.Call(e.id.Number, хярхмю, e.T.tType IN {TREAL, TLONGREAL}, e.id.T.Call, ccall, e.id.Level - 3,
            DECL.curBlock.Level - 3, e.id.ParamSize, DECL.curBlock.LocalSize)
        хмюве
          X86.PushInt(e.id.Number)
        йнмеж
      юеякх (e.eType = eVAR) & (e.T.tType = TPROC) & (ЛяЙЮМ.tLex = lxLRound) рнцдю
        Assert2(e.T.Base.tType # TVOID, 73);
        Next;
        X86.PushCall(begcall);
        Call(e.T.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ));
        X86.EndCall;
        e.eType := eEXP;
        X86.CallVar(хярхмю, e.T.Base.tType IN {TREAL, TLONGREAL}, e.T.Call, e.T.Len, DECL.curBlock.LocalSize);
        e.T := e.T.Base;
      юеякх e.eType IN {eSTPROC, eSYSPROC} рнцдю
        StFunc(e, e.id.StProc)
      йнмеж
    |ЛйНМЯР.ЙЯосярн:
      e.T := sttypes[TNIL];
      e.Value := 0.0D0;
      X86.PushConst(0);
      Next
    |ЛйНМЯР.ЙЯхярхмю:
      e.T := sttypes[TBOOLEAN];
      e.Value := 1.0D0;
      X86.PushConst(1);
      Next
    |ЛйНМЯР.ЙЯкнфэ:
      e.T := sttypes[TBOOLEAN];
      e.Value := 0.0D0;
      X86.PushConst(0);
      Next
    |lxCHX, lxSTRING:
      еякх ЛяЙЮМ.tLex = lxSTRING рнцдю
        ЛяЙЮМ.GetLexStr(Lex);
        str2 := DECL.яРП_яНГДЮРЭ(Lex);
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        s := DECL.яРП_оНКСВ(e.Value);
        еякх s.Len = 1 рнцдю
          X86.PushConst(ORD(s.Str[0]))
        хмюве
          X86.PushInt(s.Number)
        йнмеж
      хмюве
        str2 := DECL.AddMono(ЛяЙЮМ.vCHX);
        SYSTEM.GET(SYSTEM.ADR(str2), p);
        e.Value := LONG(FLT(p));
        X86.PushConst(ORD(ЛяЙЮМ.vCHX))
      йнмеж;
      e.T := sttypes[TSTRING];
      Next
    |lxREAL:
      e.T := sttypes[TREAL];
      e.Value := ЛяЙЮМ.vFLT;
      X86.PushFlt(ЛяЙЮМ.vFLT);
      Next
    |lxLONGREAL:
      e.T := sttypes[TLONGREAL];
      e.Value := ЛяЙЮМ.vFLT;
      X86.PushFlt(ЛяЙЮМ.vFLT);
      Next
    |lxINT, lxHEX:
      e.T := sttypes[TINTEGER];
      e.Value := LONG(FLT(ЛяЙЮМ.vINT));
      X86.PushConst(ЛяЙЮМ.vINT);
      Next
    |lxLRound:
      Next;
      pExpr(e);
      Check(lxRRound);
      Next
    |lxNot:
      Next;
      Coord(line, col);
      Factor(e);
      Assert(e.T.tType = TBOOLEAN, line, col, 37);
      Load(e);
      еякх e.eType = eCONST рнцдю
        e.Value := LONG(FLT(ORD(e.Value = 0.0D0)))
      хмюве
        e.eType := eEXP
      йнмеж;
      X86.Not;
      e.vparam := кнфэ
    |lxLCurly:
      Set(e)
    хмюве
      Assert2(кнфэ, 36)
    йнмеж
  йнмеж Factor;

опнжедспю IsChr(a: DECL.РбШПЮФЕМХЕ): BOOLEAN;
    бепмсрэ (a.T.tType = TSTRING) & (LenString(a.Value) = 1) хкх (a.T.tType = TCHAR)
  йнмеж IsChr;

опнжедспю StrRel(a, b: DECL.РбШПЮФЕМХЕ; Op: INTEGER);
  мювюкн
    еякх ~(IsChr(a) хкх IsChr(b)) рнцдю
      X86.strcmp(Op, 0)
    юеякх IsChr(a) & IsChr(b) рнцдю
      X86.CmpInt(Op)
    юеякх IsChr(a) рнцдю
      X86.strcmp(Op, 1)
    хмюве
      X86.strcmp(Op, -1)
    йнмеж
  йнмеж StrRel;

опнжедспю log2(n: INTEGER): INTEGER;
  оепел x, i: INTEGER;
  мювюкн
    x := 1;
    i := 0;
    онйю (x # n) & (i < 31) декюрэ
      x := LSL(x, 1);
      INC(i)
    йнмеж;
    еякх x # n рнцдю
      i := -1
    йнмеж
    бепмсрэ i
  йнмеж log2;

опнжедспю Operation(оеп a, b: DECL.РбШПЮФЕМХЕ; Op, line, col: INTEGER);
  оепел n, m: INTEGER;
  мювюкн
    бшанп Op хг
    |lxPlus, lxMinus, lxMult, lxSlash:
      Assert((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}) & (a.T.tType = b.T.tType), line, col, 37);
      Assert(~((Op = lxSlash) & (a.T.tType = TINTEGER)), line, col, 37);
      бшанп a.T.tType хг
      |TINTEGER: X86.Int(Op)
      |TSET: X86.Set(Op)
      |TREAL, TLONGREAL: X86.farith(Op)
      хмюве
      йнмеж
    |lxDIV, lxMOD:
      Assert((a.T.tType = TINTEGER) & (b.T.tType = TINTEGER), line, col, 37);
      еякх b.eType = eCONST рнцдю
        m := FLOOR(b.Value);
        Assert(m # 0, line, col, 48);
        n := log2(m);
        еякх n = -1 рнцдю
          X86.idivmod(Op = lxMOD)
        хмюве
          X86.Drop;
          еякх Op = lxMOD рнцдю
            n := ORD(-BITS(LSL(-1, n)));
            X86.PushConst(n);
            X86.Set(lxMult)
          хмюве
            X86.PushConst(n);
            X86.StFunc(X86.stASR)
          йнмеж
        йнмеж
      хмюве
        X86.idivmod(Op = lxMOD)
      йнмеж
    |lxAnd, ЛйНМЯР.lxOR:
      Assert((a.T.tType = TBOOLEAN) & (b.T.tType = TBOOLEAN), line, col, 37)
    |ЛйНМЯР.ЙЯб:
      Assert((a.T.tType = TINTEGER) & (b.T.tType = TSET), line, col, 37);
      X86.inset
    |lxLT, lxLE, lxGT, lxGE:
      Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL}) & (a.T.tType = b.T.tType)) хкх
        (IsChr(a) хкх IsString(a)) & (IsChr(b) хкх IsString(b)) хкх
        (a.T.tType = TSET) & (b.T.tType = TSET) & ((Op = lxLE) хкх (Op = lxGE)), line, col, 37);
      еякх a.T.tType IN {TREAL, TLONGREAL} рнцдю
        X86.fcmp(Op)
      юеякх a.T.tType = TSET рнцдю
        X86.Inclusion(Op)
      юеякх IsString(a) хкх IsString(b) рнцдю
        StrRel(a, b, Op)
      хмюве
        X86.CmpInt(Op)
      йнмеж
    |lxEQ, lxNE:
      Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN}) & (a.T.tType = b.T.tType)) хкх
        (IsChr(a) хкх IsString(a)) & (IsChr(b) хкх IsString(b)) хкх
        (a.T.tType IN {TPOINTER, TPROC, TNIL}) & (b.T.tType = TNIL) хкх
        (b.T.tType IN {TPOINTER, TPROC, TNIL}) & (a.T.tType = TNIL) хкх
        (a.T.tType = TPOINTER) & (b.T.tType = TPOINTER) & (BaseOf(a.T, b.T) хкх BaseOf(b.T, a.T)) хкх
        (a.T.tType = TPROC) & ProcTypeComp(b.T, a.T) хкх (a.eType = ePROC) & ProcTypeComp(b.T, a.id.T) хкх
        (b.eType = ePROC) & ProcTypeComp(a.T, b.id.T), line, col, 37);
      еякх a.T.tType IN {TREAL, TLONGREAL} рнцдю
        X86.fcmp(Op)
      юеякх IsString(a) хкх IsString(b) рнцдю
        StrRel(a, b, Op)
      хмюве
        X86.CmpInt(Op)
      йнмеж
    хмюве
    йнмеж;
    еякх (a.eType # eCONST) хкх (b.eType # eCONST) рнцдю
      a.eType := eEXP;
      еякх DECL.Relation(Op) рнцдю
        a.T := sttypes[TBOOLEAN]
      йнмеж
    хмюве
      DECL.Calc(a.Value, b.Value, a.T, b.T, Op, line, col, a.Value, a.T)
    йнмеж;
    a.vparam := кнфэ
  йнмеж Operation;

опнжедспю Term(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    a: DECL.РбШПЮФЕМХЕ;
    Op, line, col, L: INTEGER;
  мювюкн
    Factor(e);
    онйю (ЛяЙЮМ.tLex = lxMult) хкх (ЛяЙЮМ.tLex = lxSlash) хкх
      (ЛяЙЮМ.tLex = lxDIV) хкх (ЛяЙЮМ.tLex = lxMOD) хкх
       (ЛяЙЮМ.tLex = lxAnd) декюрэ
      Load(e);
      Coord(line, col);
      Op := ЛяЙЮМ.tLex;
      Next;
      еякх Op = lxAnd рнцдю
        L := X86.NewLabel();
        X86.IfWhile(L, кнфэ)
      йнмеж;
      Factor(a);
      Load(a);
      еякх Op = lxAnd рнцдю
        X86.Label(L)
      йнмеж;
      Operation(e, a, Op, line, col)
    йнмеж
  йнмеж Term;

опнжедспю Simple(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    a: DECL.РбШПЮФЕМХЕ;
    Op, line, col, uOp, uline, ucol, L: INTEGER;
  мювюкн
    uOp := 0;
    еякх (ЛяЙЮМ.tLex = lxPlus) хкх (ЛяЙЮМ.tLex = lxMinus) рнцдю
      Coord(uline, ucol);
      uOp := ЛяЙЮМ.tLex;
      Next
    йнмеж;
    Term(e);
    еякх uOp # 0 рнцдю
      Assert(e.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}, uline, ucol, 37);
      Load(e);
      еякх uOp = lxMinus рнцдю
        бшанп e.T.tType хг
        |TINTEGER: X86.NegInt
        |TSET: X86.NegSet
        |TREAL, TLONGREAL: X86.fneg
        хмюве
        йнмеж
      йнмеж;
      еякх (uOp = lxMinus) & (e.eType = eCONST) рнцдю
        бшанп e.T.tType хг
        |TINTEGER:
          Assert(e.Value # LONG(FLT(ЛйНМЯР.ЖЕКНЕ_ЛХМ)), uline, ucol, DECL.IOVER)
        |TSET:
          e.Value := -LONG(FLT(ORD(-BITS(FLOOR(e.Value)))))
        хмюве
        йнмеж;
        e.Value := -e.Value
      йнмеж;
      еякх e.eType # eCONST рнцдю
        e.eType := eEXP
      йнмеж;
      e.vparam := кнфэ
    йнмеж;
    онйю (ЛяЙЮМ.tLex = lxPlus) хкх (ЛяЙЮМ.tLex = lxMinus) хкх (ЛяЙЮМ.tLex = ЛйНМЯР.lxOR) декюрэ
      Load(e);
      Coord(line, col);
      Op := ЛяЙЮМ.tLex;
      Next;
      еякх Op = ЛйНМЯР.lxOR рнцдю
        L := X86.NewLabel();
        X86.IfWhile(L, хярхмю)
      йнмеж;
      Term(a);
      Load(a);
      еякх Op = ЛйНМЯР.lxOR рнцдю
        X86.Label(L)
      йнмеж;
      Operation(e, a, Op, line, col)
    йнмеж
  йнмеж Simple;

опнжедспю Expr(оеп e: DECL.РбШПЮФЕМХЕ);
  оепел
    a: DECL.РбШПЮФЕМХЕ;
    Op, line, col, line2, col2, fpu: INTEGER;
    T: DECL.РСрХО;
    beg: X86.ASMLINE;
    s: DECL.РСйНМЯРяРП;
  мювюкн
    fpu := X86.fpu;
    beg := X86.current;
    Simple(e);
    еякх DECL.Relation(ЛяЙЮМ.tLex) рнцдю
      Coord(line, col);
      Op := ЛяЙЮМ.tLex;
      Next;
      еякх Op = ЛйНМЯР.ЙЯеярэ рнцдю
        Assert(e.T.tType IN {TRECORD, TPOINTER}, line, col, 37);
        еякх e.T.tType = TRECORD рнцдю
          Assert(e.vparam, line, col, 37)
        йнмеж;
        Check(lxIDENT);
        Coord(line2, col2);
        T := DECL.IdType(line2, col2);
        Assert(T # осярн, line2, col2, 42);
        еякх e.T.tType = TRECORD рнцдю
          Assert(T.tType = TRECORD, line2, col2, 106)
        хмюве
          Assert(T.tType = TPOINTER, line2, col2, 107)
        йнмеж;
        Assert(BaseOf(e.T, T), line, col, 37);
        еякх e.T.tType = TRECORD рнцдю
          X86.Drop;
          X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
        йнмеж;
        Load(e);
        еякх e.T.tType = TPOINTER рнцдю
          T := T.Base
        йнмеж;
        X86.Guard(T.Number, хярхмю);
        e.T := sttypes[TBOOLEAN];
        e.eType := eEXP;
        e.vparam := кнфэ
      хмюве
        Load(e);
        Str(e);
        Simple(a);
        Load(a);
        Str(a);
        Operation(e, a, Op, line, col)
      йнмеж
    йнмеж;
    еякх e.eType = eCONST рнцдю
      X86.Del(beg);
      X86.Setfpu(fpu);
      еякх ~DECL.Const рнцдю
        бшанп e.T.tType хг
        |TREAL, TLONGREAL:
          X86.PushFlt(e.Value)
        |TINTEGER, TSET, TBOOLEAN, TNIL:
          X86.PushConst(FLOOR(e.Value))
        |TSTRING:
          s := DECL.яРП_оНКСВ(e.Value);
          еякх s.Len = 1 рнцдю
            X86.PushConst(ORD(s.Str[0]))
          хмюве
            X86.PushInt(s.Number)
          йнмеж
        хмюве
        йнмеж
      йнмеж
    йнмеж
  йнмеж Expr;

опнжедспю IfWhileOper(wh: BOOLEAN);
  оепел
    e: DECL.РбШПЮФЕМХЕ;
    line, col, L, L3: INTEGER;
  мювюкн
    L := X86.NewLabel();
    еякх wh рнцдю
      X86.Label(L)
    йнмеж;
    онбрнпърэ
      Next;
      Coord(line, col);
      Expr(e);
      Assert(e.T.tType = TBOOLEAN, line, col, 117);
      Load(e);
      еякх wh рнцдю
        Check(ЛйНМЯР.ЙЯдекюрэ)
      хмюве
        Check(ЛйНМЯР.ЙЯрнцдю)
      йнмеж;
      L3 := X86.NewLabel();
      X86.ifwh(L3);
      Next;
      pOpSeq;
      X86.jmp(X86.JMP, L);
      X86.Label(L3)
    онйюме ЛяЙЮМ.tLex # ЛйНМЯР.ЙЯюеякх;
    еякх ~wh & (ЛяЙЮМ.tLex = ЛйНМЯР.ЙЯхмюве) рнцдю
      Next;
      pOpSeq
    йнмеж;
    Check(ЛйНМЯР.ЙЯйнмеж);
    еякх ~wh рнцдю
      X86.Label(L)
    йнмеж;
    Next
  йнмеж IfWhileOper;

опнжедспю RepeatOper;
  оепел
    e: DECL.РбШПЮФЕМХЕ;
    line, col, L: INTEGER;
  мювюкн
    Next;
    L := X86.NewLabel();
    X86.Label(L);
    pOpSeq;
    Check(ЛйНМЯР.ЙЯонйюме);
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType = TBOOLEAN, line, col, 117);
    Load(e);
    X86.ifwh(L)
  йнмеж RepeatOper;

опнжедспю ForOper;
  оепел
    e: DECL.РбШПЮФЕМХЕ;
    line, col, LBeg, LEnd, iValue: INTEGER;
    Value: LONGREAL;
    T: DECL.РСрХО;
    name: ЛрХОШ.РСсГЕК;
    id: DECL.РСхЛЪ;
  мювюкн
    Next;
    Check(lxIDENT);
    name := ЛяЙЮМ.id;
    id := DECL.GetIdent(name);
    Assert2(id # осярн, 42);
    Assert2(id.iType = IDVAR, 126);
    Assert2(id.VarKind = 0, 127);
    Assert2(id.T.tType = TINTEGER, 128);
    Assert2(id.Level = DECL.unit.Level, 129);
    Next;
    Check(lxAssign);
    Next;
    Coord(line, col);
    еякх id.Level = 3 рнцдю
      X86.GlobalAdr(id.Offset)
    хмюве
      X86.LocalAdr(id.Offset, 0)
    йнмеж;
    X86.Dup;
    Expr(e);
    Assert(e.T.tType = TINTEGER, line, col, 52);
    Load(e);
    X86.Save(TINTEGER);
    Check(ЛйНМЯР.ЙЯдн);
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType = TINTEGER, line, col, 52);
    Load(e);
    iValue := 1;
    еякх ЛяЙЮМ.tLex = lxBY рнцдю
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      iValue := FLOOR(Value);
      Assert(iValue # 0, line, col, 122)
    йнмеж;
    Check(ЛйНМЯР.ЙЯдекюрэ);
    Next;
    X86.For(iValue > 0, LBeg, LEnd);
    pOpSeq;
    X86.NextFor(iValue, LBeg, LEnd);
    Check(ЛйНМЯР.ЙЯйнмеж);
    Next
  йнмеж ForOper;

опнжедспю CheckLabel(a, b: INTEGER; Labels: ЛрХОШ.РСяОХЯНЙ): BOOLEAN;
  оепел cur: LABEL;
  мювюкн
    cur := Labels.ОПЕДШДСЫ(LABEL);
    онйю (cur # осярн) & ((b < cur.a) хкх (a > cur.b)) декюрэ
      cur := cur.ЯКЕДСЧЫ(LABEL)
    йнмеж
    бепмсрэ cur = осярн
  йнмеж CheckLabel;

опнжедспю LabelVal(оеп a: INTEGER; int: BOOLEAN);
  оепел
    Value: LONGREAL;
    T: DECL.РСрХО;
    s: DECL.РСйНМЯРяРП;
    line, col: INTEGER;
  мювюкн
    Coord(line, col);
    DECL.ConstExpr(Value, T);
    еякх int рнцдю
      Assert(T.tType = TINTEGER, line, col, 161);
      a := FLOOR(Value)
    хмюве
      Assert(T.tType = TSTRING, line, col, 55);
      s := DECL.яРП_оНКСВ(Value);
      Assert(s.Len = 1, line, col, 94);
      a := ORD(s.Str[0])
    йнмеж
  йнмеж LabelVal;

опнжедспю Label(int: BOOLEAN; Labels: ЛрХОШ.РСяОХЯНЙ; LBeg: INTEGER);
  оепел a, b: INTEGER; label: LABEL; line, col: INTEGER;
  мювюкн
    Coord(line, col);
    LabelVal(a, int);
    b := a;
    еякх ЛяЙЮМ.tLex = lxDbl рнцдю
      Next;
      LabelVal(b, int)
    йнмеж;
    Assert(a <= b, line, col, 54);
    Assert(CheckLabel(a, b, Labels), line, col, 100);
    NEW(label);
    DECL.оЮЛнЬ_оПНБЕПХРЭ(label = осярн);
    label.a := a;
    label.b := b;
    ЛяОХЯ.дНАЮБХРЭ(Labels, label);
    X86.CaseLabel(a, b, LBeg)
  йнмеж Label;

опнжедспю Variant(int: BOOLEAN; Labels: ЛрХОШ.РСяОХЯНЙ; EndCase: INTEGER);
  оепел LBeg, LEnd: INTEGER;
  мювюкн
    LBeg := X86.NewLabel();
    LEnd := X86.NewLabel();
    еякх ~((ЛяЙЮМ.tLex = lxStick) хкх (ЛяЙЮМ.tLex = ЛйНМЯР.ЙЯйнмеж)) рнцдю
      Label(int, Labels, LBeg);
      онйю ЛяЙЮМ.tLex = lxComma декюрэ
        Next;
        Label(int, Labels, LBeg)
      йнмеж;
      Check(lxColon);
      Next;
      X86.jmp(X86.JMP, LEnd);
      X86.Label(LBeg);
      pOpSeq;
      X86.jmp(X86.JMP, EndCase);
      X86.Label(LEnd)
    йнмеж
  йнмеж Variant;

опнжедспю CaseOper;
  оепел
    e: DECL.РбШПЮФЕМХЕ;
    int: BOOLEAN;
    line, col, EndCase: INTEGER;
    Labels: ЛрХОШ.РСяОХЯНЙ;
  мювюкн
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType IN {TCHAR, TSTRING, TINTEGER}, line, col, 156);
    Assert(~((e.T.tType = TSTRING) & (LenString(e.Value) # 1)), line, col, 94);
    int := e.T.tType = TINTEGER;
    Check(ЛйНМЯР.ЙЯхг);
    Load(e);
    X86.Drop;
    Labels := ЛяОХЯ.яНГДЮРЭ();
    DECL.оЮЛнЬ_оПНБЕПХРЭ(Labels = осярн);
    Next;
    EndCase := X86.NewLabel();
    Variant(int, Labels, EndCase);
    онйю ЛяЙЮМ.tLex = lxStick декюрэ
      Next;
      Variant(int, Labels, EndCase)
    йнмеж;
    еякх ЛяЙЮМ.tLex = ЛйНМЯР.ЙЯхмюве рнцдю
      Next;
      pOpSeq
    хмюве
      ЛсРХКЭ.йНДяРПНЙЮ_сЯР(DECL.UnitNumber, ЛяЙЮМ.line);
      X86.OnError(7)
    йнмеж;
    Check(ЛйНМЯР.ЙЯйнмеж);
    X86.Label(EndCase);
    Next;
    ЛяОХЯ.нВХЯРХРЭ(Labels)
  йнмеж CaseOper;

опнжедспю CheckCode(Code: ЛяРП.РяРПНЙЮ; Len, line, col: INTEGER);
  оепел i: INTEGER;
  мювюкн
    Assert(~ODD(Len), line, col, 34);
    дкъ i := 0 дн Len - 1 декюрэ
      Assert(ЛяЙЮМ.вХЯКН16_оНКСВ(Code[i]), line, col, 34)
    йнмеж
  йнмеж CheckCode;

опнжедспю StProc(proc: INTEGER);
  оепел
    line, col, line2, col2, iValue: INTEGER;
    e1, e2: DECL.РбШПЮФЕМХЕ;
    Value: LONGREAL;
    T: DECL.РСрХО;
    str: DECL.РСйНМЯРяРП;
    begcall: X86.ASMLINE;
  мювюкн
    Coord(line2, col2);
    Check(lxLRound);
    Next;
    Coord(line, col);
    бшанп proc хг
    |stINC, stDEC:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TINTEGER, line, col, 128);
      еякх ЛяЙЮМ.tLex = lxComma рнцдю
        Next;
        Coord(line, col);
        DECL.ConstExpr(Value, T);
        Assert(T.tType = TINTEGER, line, col, 52);
        iValue := FLOOR(Value);
        Assert(iValue # 0, line, col, 122);
        еякх iValue < 0 рнцдю
          еякх proc = stINC рнцдю
            proc := stDEC
          хмюве
            proc := stINC
          йнмеж;
          iValue := -iValue
        йнмеж;
        еякх iValue # 1 рнцдю
          X86.PushConst(iValue);
          еякх proc = stDEC рнцдю
            X86.StProc(X86.stDEC)
          хмюве
            X86.StProc(X86.stINC)
          йнмеж
        хмюве
          еякх proc = stDEC рнцдю
            X86.StProc(X86.stDEC1)
          хмюве
            X86.StProc(X86.stINC1)
          йнмеж
        йнмеж
      хмюве
        еякх proc = stDEC рнцдю
          X86.StProc(X86.stDEC1)
        хмюве
          X86.StProc(X86.stINC1)
        йнмеж
      йнмеж
    |stINCL, stEXCL:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TSET, line, col, 138);
      Check(lxComma);
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      iValue := FLOOR(Value);
      Assert(ASR(iValue, 5) = 0, line, col, 53);
      еякх proc = stINCL рнцдю
        X86.PushConst(ORD({iValue}));
        X86.StProc(X86.stINCL)
      хмюве
        X86.PushConst(ORD(-{iValue}));
        X86.StProc(X86.stEXCL)
      йнмеж
    |stCOPY:
      Expr(e1);
      Assert(IsString(e1), line, col, 141);
      Check(lxComma);
      еякх e1.T.tType = TSTRING рнцдю
        str := DECL.яРП_оНКСВ(e1.Value);
        еякх str.Len = 1 рнцдю
          X86.Mono(str.Number);
          X86.StrMono
        йнмеж
      йнмеж;
      Str(e1);
      Next;
      Coord(line, col);
      Designator(e2);
      Assert(e2.eType = eVAR, line, col, 63);
      Assert(IsString(e2), line, col, 143);
      Assert(~e2.Read, line, col, 115);
      Str(e2);
      X86.StProc(X86.stCOPY)
    |stNEW, stDISPOSE:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(~e1.Read, line, col, 115);
      Assert(e1.T.tType = TPOINTER, line, col, 145);
      еякх proc = stNEW рнцдю
        X86.PushConst(e1.T.Base.Number);
        X86.PushConst(X86.Align(e1.T.Base.Size + 8, 32));
        X86.newrec
      хмюве
        X86.disprec
      йнмеж
    |stASSERT:
      Expr(e1);
      Assert(e1.T.tType = TBOOLEAN, line, col, 117);
      Load(e1);
      еякх ЛяЙЮМ.tLex = lxComma рнцдю
        Next;
        Coord(line, col);
        DECL.ConstExpr(Value, T);
        Assert(T.tType = TINTEGER, line, col, 52);
        Assert((Value >= 0.0D0) & (Value <= 127.0D0), line, col, 95);
        X86.Assert(X86.stASSERT, FLOOR(Value))
      хмюве
        X86.Assert(X86.stASSERT1, 0)
      йнмеж
    |stPACK, stUNPK:
      Designator(e1);
      Assert(e1.eType = eVAR, line, col, 63);
      Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 149);
      Assert(~e1.Read, line, col, 115);
      Check(lxComma);
      Next;
      Coord(line, col);
      еякх proc = stUNPK рнцдю
        Designator(e2);
        Assert(e2.eType = eVAR, line, col, 63);
        Assert(e2.T.tType = TINTEGER, line, col, 128);
        Assert(~e2.Read, line, col, 115);
        еякх e1.T.tType = TLONGREAL рнцдю
          X86.StProc(X86.stUNPK)
        хмюве
          X86.StProc(X86.stUNPK1)
        йнмеж
      хмюве
        Expr(e2);
        Assert(e2.T.tType = TINTEGER, line, col, 52);
        Load(e2);
        еякх e1.T.tType = TLONGREAL рнцдю
          X86.StProc(X86.stPACK)
        хмюве
          X86.StProc(X86.stPACK1)
        йнмеж
      йнмеж
    |sysBIT:
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1)
    |sysPUT, sysGET:
      begcall := X86.current;
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      Next;
      Coord(line, col);
      еякх proc = sysGET рнцдю
        X86.PushCall(begcall);
        X86.Param;
        Designator(e2);
        Assert(e2.eType = eVAR, line, col, 63);
        Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16}, line, col, 154);
        Assert(~e2.Read, line, col, 115);
        X86.EndCall;
        X86.Load(e2.T.tType);
        X86.Save(e2.T.tType)
      хмюве
        Expr(e2);
        Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16, TSTRING}, line, col, 153);
        еякх e2.T.tType = TSTRING рнцдю
          Assert(LenString(e2.Value) = 1, line, col, 94)
        йнмеж;
        Load(e2);
        X86.Save(e2.T.tType)
      йнмеж
    |sysCODE:
      Assert(ЛяЙЮМ.tLex = lxSTRING, line, col, 150);
      ЛяЙЮМ.GetLexStr(Lex);
      CheckCode(Lex, ЛяЙЮМ.count - 1, line, col);
      X86.Asm(Lex);
      Next
    |sysMOVE:
      begcall := X86.current;
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      X86.PushCall(begcall);
      X86.Param;
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
      Check(lxComma);
      X86.EndCall;
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TINTEGER, line, col, 52);
      Load(e1);
    хмюве
      Assert(кнфэ, line2, col2, 132)
    йнмеж;
    Check(lxRRound);
    Next;
    еякх proc = sysMOVE рнцдю
      X86.StProc(X86.sysMOVE);
    юеякх proc = sysBIT рнцдю
      Check(lxAssign);
      Next;
      Coord(line, col);
      Expr(e1);
      Assert(e1.T.tType = TBOOLEAN, line, col, 117);
      Load(e1);
      X86.StProc(X86.sysBIT)
    йнмеж
  йнмеж StProc;

опнжедспю IdentOper;
  оепел
    e1, e2: DECL.РбШПЮФЕМХЕ;
    line, col, ccall: INTEGER;
    begcall: X86.ASMLINE;
    s: DECL.РСйНМЯРяРП;
  мювюкн
    Coord(line, col);
    begcall := X86.current;
    Designator(e1);
    Assert(e1.eType # eCONST, line, col, 130);
    еякх (e1.eType = eVAR) & (e1.T.tType # TPROC) рнцдю
      Check(lxAssign);
      Assert(~e1.Read, line, col, 115);
      Next;
      Coord(line, col);
      Expr(e2);
      Assert(AssComp(e2, e1.T, кнфэ), line, col, 131);
      Load(e2);
      еякх e1.T.tType = TRECORD рнцдю
        X86.PushConst(e1.T.Size);
        X86.PushConst(e1.T.Number);
        еякх e1.vparam рнцдю
          X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
          X86.Load(TINTEGER)
        юеякх e1.deref рнцдю
          X86.DerefType(12)
        хмюве
          X86.PushConst(e1.T.Number)
        йнмеж
      юеякх e2.T.tType = TARRAY рнцдю
        X86.PushConst(e2.T.Size)
      юеякх (e2.T.tType = TSTRING) & (e1.T.tType = TARRAY) рнцдю
        s := DECL.яРП_оНКСВ(e2.Value);
        еякх s.Len = 1 рнцдю
          X86.Mono(s.Number)
        йнмеж;
        X86.PushConst(ЛсРХКЭ.лХМХЛСЛ(s.Len + 1, e1.T.Len))
      йнмеж;
      X86.Save(e1.T.tType)
    юеякх e1.eType = ePROC рнцдю
      Assert((e1.id.T.Base.tType = TVOID) хкх (e1.id.T.Call = DECL.winapi), line, col, 132);
      еякх e1.id.ParamCount > 0 рнцдю
        Check(lxLRound);
        Next;
        X86.PushCall(begcall);
        Call(e1.id.T.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ));
        X86.EndCall
      юеякх ЛяЙЮМ.tLex = lxLRound рнцдю
        Next;
        Check(lxRRound);
        Next
      йнмеж;
      еякх e1.id.Level = 3 рнцдю
        ccall := 0
      юеякх e1.id.Level > DECL.curBlock.Level рнцдю
        ccall := 1
      хмюве
        ccall := 2
      йнмеж;
      X86.Call(e1.id.Number, кнфэ, кнфэ, e1.id.T.Call, ccall, e1.id.Level - 3, DECL.curBlock.Level - 3, e1.id.ParamSize, DECL.curBlock.LocalSize)
    юеякх e1.eType IN {eSTPROC, eSYSPROC} рнцдю
      StProc(e1.id.StProc)
    юеякх (e1.eType = eVAR) & (e1.T.tType = TPROC) рнцдю
      еякх ЛяЙЮМ.tLex = lxLRound рнцдю
        Next;
        Assert((e1.T.Base.tType = TVOID) хкх (e1.T.Call = DECL.winapi), line, col, 132);
        X86.PushCall(begcall);
        Call(e1.T.Fields.ОПЕДШДСЫ(DECL.РСоНКЕ));
        X86.EndCall;
        X86.CallVar(кнфэ, кнфэ, e1.T.Call, e1.T.Len, DECL.curBlock.LocalSize)
      юеякх ЛяЙЮМ.tLex = lxAssign рнцдю
        Assert(~e1.Read, line, col, 115);
        Next;
        Coord(line, col);
        Expr(e2);
        Assert(AssComp(e2, e1.T, кнфэ), line, col, 131);
        Assert(~((e2.eType = ePROC) & (e2.id.Level > 3)), line, col, 116);
        еякх e2.eType = eVAR рнцдю
          X86.Load(TPROC)
        йнмеж;
        X86.Save(TPROC)
      хмюве
        Assert2(e1.T.Fields.ЯВЕРВХЙ = 0, 155);
        Assert((e1.T.Base.tType = TVOID) хкх (e1.T.Call = DECL.winapi), line, col, 132);
        X86.CallVar(кнфэ, кнфэ, e1.T.Call, e1.T.Len, DECL.curBlock.LocalSize)
      йнмеж
    йнмеж
  йнмеж IdentOper;

опнжедспю Operator;
  мювюкн
    ЛсРХКЭ.йНДяРПНЙЮ_сЯР(DECL.UnitNumber, ЛяЙЮМ.line);
    бшанп ЛяЙЮМ.tLex хг
    |lxIDENT: IdentOper
    |ЛйНМЯР.ЙЯеякх, ЛйНМЯР.ЙЯонйю: IfWhileOper(ЛяЙЮМ.tLex = ЛйНМЯР.ЙЯонйю)
    |ЛйНМЯР.ЙЯонбрнп: RepeatOper
    |ЛйНМЯР.ЙЯдкъ: ForOper
    |ЛйНМЯР.ЙЯбшанп: CaseOper
    хмюве
    йнмеж
  йнмеж Operator;

опнжедспю OpSeq;
  мювюкн
    Operator;
    онйю ЛяЙЮМ.tLex = lxSemi декюрэ
      Next;
      Operator
    йнмеж
  йнмеж OpSeq;

опнжедспю яРЮПР;
  оепел SelfName, SelfPath, CName, CExt, FName, Path, StdPath,
      Name, Ext, temp, system, stk, felf: ЛяРП.РяРПНЙЮ;
      platform, stksize: INTEGER;

    опнжедспю getstksize(): INTEGER;
    оепел res, i: INTEGER;
    мювюкн
      res := 0;
      i := 0;
      онйю ЛяЙЮМ.жХТПЮ_оПНБЕПХРЭ(stk[i]) декюрэ
        INC(i)
      йнмеж;
      еякх stk[i] <= 20X рнцдю
        stk[i] := 0X;
        res := ЛяЙЮМ.яРП_Б_жЕК(stk)
      йнмеж;
      еякх res = 0 рнцдю
        res := 1
      йнмеж
      бепмсрэ res
    йнмеж getstksize;

    опнжедспю getver(): INTEGER;
    оепел res, i: INTEGER; err: BOOLEAN;

      опнжедспю hexdgt(c: CHAR): BOOLEAN;
        бепмсрэ ("0" <= c) & (c <= "9") хкх
               ("A" <= c) & (c <= "F") хкх
               ("a" <= c) & (c <= "f")
      йнмеж hexdgt;

      опнжедспю hex(c: CHAR): INTEGER;
      оепел res: INTEGER;
      мювюкн
        еякх    ("0" <= c) & (c <= "9") рнцдю
          res := ORD(c) - ORD("0")
        юеякх ("A" <= c) & (c <= "F") рнцдю
          res := ORD(c) - ORD("A") + 10
        юеякх ("a" <= c) & (c <= "f") рнцдю
          res := ORD(c) - ORD("a") + 10
        йнмеж
        бепмсрэ res
      йнмеж hex;

    мювюкн
      res := 0;
      i := 0;
      err := stk[i] # "0"; INC(i);
      err := err хкх (stk[i] # "x"); INC(i);
      онйю ~err & hexdgt(stk[i]) декюрэ
        INC(i)
      йнмеж;
      err := err хкх (i = 2);
      еякх stk[i] <= 20X рнцдю
        stk[i] := 0X
      хмюве
        err := хярхмю
      йнмеж;
      i := 2;
      онйю ~err & (stk[i] # 0X) декюрэ
        res := LSL(res, 4) + hex(stk[i]);
        INC(i)
      йнмеж;
      еякх res = 0 рнцдю
        res := 1
      йнмеж
      бепмсрэ res
    йнмеж getver;

  мювюкн
    еякх ЛсРХКЭ.ParamCount < 2 рнцдю
      ЛнЬ.яННАЫ(59);
      ЛоПНЖ.гЮЙНМВХРЭ(1)
    йнмеж;
    ЛсРХКЭ.яРПоЮПЮЛ(SelfName, 0);
    ЛсРХКЭ.яРПоЮПЮЛ(FName, 1);
    ЛсРХКЭ.яРПоЮПЮЛ(system, 2);
    ЛсРХКЭ.яРПоЮПЮЛ(stk, 3);
    pExpr := Expr;
    pFactor := Factor;
    pOpSeq := OpSeq;
    ЛяРП.пЮГДЕКХРЭ(FName, Path, Name, Ext);
    еякх Ext # ЛйНМЯР.ПЮЯЬХП рнцдю
      ЛнЬ.яННАЫ(121);
      ЛоПНЖ.гЮЙНМВХРЭ(1)
    йнмеж;
    ЛяРП.пЮГДЕКХРЭ(SelfName, SelfPath, CName, CExt);
    temp := Name;
    еякх ЛсРХКЭ.streq(system, "obj") рнцдю
      platform := 6;
    ЛяРП.яКНФХРЭ(temp, ".obj", temp)
    юеякх ЛсРХКЭ.streq(system, "elf") рнцдю
      platform := 5;
      felf := SelfPath;
      ЛяРП.яКНФХРЭ(felf, "Elf", felf);
      X86.setfelf(felf)
    юеякх ЛсРХКЭ.streq(system, "kos") рнцдю
      platform := 4;
      ЛяРП.яКНФХРЭ(temp, ".kex", temp)
    юеякх ЛсРХКЭ.streq(system, "con") рнцдю
      platform := 3;
      ЛяРП.яКНФХРЭ(temp, ".exe", temp)
    юеякх ЛсРХКЭ.streq(system, "gui") рнцдю
      platform := 2;
      ЛяРП.яКНФХРЭ(temp, ".exe", temp)
    юеякх ЛсРХКЭ.streq(system, "dll") рнцдю
      platform := 1;
      ЛяРП.яКНФХРЭ(temp, ".dll", temp)
    хмюве
      ЛнЬ.яННАЫ(60);
      ЛоПНЖ.гЮЙНМВХРЭ(1)
    йнмеж;
    еякх platform IN {1,2,3,4} рнцдю
      stksize := getstksize()
    хмюве
      stksize := 1
    йнмеж;
    еякх platform = 6 рнцдю
      stksize := getver()
    йнмеж;
    ЛяРП.яКНФХРЭ(SelfPath, "Lib", SelfPath);
    ЛяРП.яКНФХРЭ(SelfPath, ЛйНМЯР.ЯКЩЬ, SelfPath);
    еякх platform = 5 рнцдю
      ЛяРП.яКНФХРЭ(SelfPath, "Linux32", SelfPath)
    юеякх platform IN {4, 6} рнцдю
      ЛяРП.яКНФХРЭ(SelfPath, "KolibriOS", SelfPath)
    юеякх platform IN {1, 2, 3} рнцдю
      ЛяРП.яКНФХРЭ(SelfPath, "Windows32", SelfPath)
    йнмеж;
    ЛяРП.яКНФХРЭ(SelfPath, ЛйНМЯР.ЯКЩЬ, SelfPath);
    X86.Init(DECL.оЮЛнЬ_оПНБЕПХРЭ, platform);
    X86.Prolog(temp);
    DECL.Program(SelfPath, Path, Name, Ext, platform IN {1, 2, 3}, OpSeq, Expr, AssComp, sttypes);
    DECL.Compile(platform, stksize);
    ЛйНМЯ.яРПНЙЮ_оЕВЮРЭ("   +йНЛОХКЪЖХЪ СЯОЕЬМЮ!"); ЛйНМЯ.мНБяРП;
    ЛйНМЯ.бПЕЛЪ_гЮРПЮВЕМН
  йнмеж яРЮПР;

мювюкн
  яРЮПР
йнмеж Compiler.
