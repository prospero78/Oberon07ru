(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.
   *)
лндскэ ЛНДюЯЛ86_32;

хлонпр ЛсРХКЭ := ЛНДсРХКЭ,
   mSys := SYSTEM,
   ЛяЙЮМ := ЛНДяЙЮМЕП,
   ЛтЮИК := ЛНДтЮИК,
   ЛйНМЯР := ЛНДйНМЯРЮМРШ,
   ЛйНМЯ := ЛНДйНМЯНКЭ,
   ЛнЬ := ЛНДнЬХАЙХ,
   ЛоПНЖ := ЛНДоПНЖЕЯЯ,
   ЛоЮЛ := ЛНДоЮЛЪРЭ,
   ЛгБЕМН := ЛНДгБЕМН,
   ЛжЕОЭ := ЛНДжЕОЭ,
   ЛяРП := ЛНДяРПНЙХ,
   ЛгБяСЫ := ЛНДгБЕМНяСЫ;

йнмяр

   ADIM* = 5;

   lxLE = 75; lxGE = 76;

   JMP* = 0E9X; CALL = 0E8X;
   JE = 84X; JNE = 85X; JLE = 8EX; JGE = 8DX; JG = 8FX; JL = 8CX;

   JCMD = 1; LCMD = 2; GCMD = 3; OCMD = 4; ECMD = 5;
   PUSHEAX = 6; PUSHECX = 7; PUSHEDX = 8; POPEAX = 9; POPECX = 10; POPEDX = 11;
   ICMP1 = 13; ICMP2 = 14;

   defcall = 0; stdcall = 1; cdecl = 2; winapi = 3;

   _rset* = 0; _inset* = 1; _saverec* = 2; _length* = 3; _checktype* = 4; _strcmp* = 5;
   _lstrcmp* = 6; _rstrcmp* = 7; _savearr* = 8; _newrec* = 9; _disprec* = 10; _arrayidx* = 11;
   _arrayrot* = 12; _assrt* = 13; _strcopy* = 14; _arrayidx1* = 15; _init* = 16; _close* = 17; _halt* = 18;
   ASSRT = 19; hInstance = 20; SELFNAME = 21; RTABLE = 22;LoadLibrary = 23; GetProcAddress = 24;
   Exports = 25; szSTART = 26; START = 27; szversion = 28; HALT = 29;

   FREGS = 8;

рхош

   РоПНЖЕДСПЮ = опнжедспю (err: аскебн);

   РюДПЕЯ = гюохяэ
         ЮДПЕЯ : жекне
      йнмеж;
   
   РюДПйНД = гюохяэ (РюДПЕЯ)
         ЙНД : жекне
      йнмеж;
      
   РюДПоЕПЕЛ = гюохяэ (РюДПЕЯ)
         ОЕПЕЛ : жекне
      йнмеж;
   
   РСгБЕМНюЯЛ* = сйюгюрекэ мю гюохяэ (ЛгБЕМН.РгБЕМН)
         ЙНД : РюДПйНД;
         ОЕПЕЛ : РюДПоЕПЕЛ;
         ЮДП : РюДПЕЯ;
         ЙЛД, clen, tcmd : жекне;
         АйНПНРЙНЕ: аскебн
      йнмеж;

   TFLT = люяяхб 2 хг жекне;

   TIDX* = люяяхб ADIM хг жекне;

   РяЕЙЖХЪхЛЪ = люяяхб 8 хг кхр;

   РяЕЙЖХЪ = гюохяэ
         ХЛЪ: РяЕЙЖХЪхЛЪ;
         size, adr, sizealign, OAPfile, reserved6, reserved7, reserved8, attrflags: жекне
      йнмеж;

   РгЮЦНКНБНЙ = гюохяэ
         msdos: люяяхб 180 хг кхр;
         typecomp, seccount: mSys.CARD16;
         time, reserved1, reserved2: жекне;
         PEoptsize, infflags, PEfile, compver: mSys.CARD16;
         codesize, datasize, initdatasize, startadr,
         codeadr, rdataadr, loadadr, secalign, filealign,
         oldestver, version, oldestverNT, reserved3,
         filesize, headersize, dllcrc: жекне;
         UI, reserved4: mSys.CARD16;
         stksize, stkalloc, heapsize, heapalloc, reserved5, structcount: жекне;
         structs: люяяхб 16 хг гюохяэ adr, size: жекне йнмеж;
         sections: люяяхб 3 хг РяЕЙЖХЪ
      йнмеж;

   РгЮЦНКНБНЙCoff = гюохяэ
         Machine: mSys.CARD16;
         NumberOfSections: mSys.CARD16;
         TimeDateStamp,
         PointerToSymbolTable,
         NumberOfSymbols: жекне;
         SizeOfOptionalHeader,
         Characteristics: mSys.CARD16;
         text, data, bss: РяЕЙЖХЪ
      йнмеж;

   РгЮЦНКНБНЙKol = гюохяэ
         menuet01: люяяхб 8 хг кхр;
         ver, start, size, mem, sp, param, path: жекне
      йнмеж;

   ETABLE = гюохяэ
         reserved1, time, reserved2, dllnameoffset, firstnum, adrcount,
         namecount, arradroffset, arrnameptroffset, arrnumoffset: жекне;
         arradr, arrnameptr: люяяхб 10000H хг жекне;
         arrnum: люяяхб 10000H хг mSys.CARD16;
         text: люяяхб 1000000 хг кхр;
         textlen, size: жекне
      йнмеж;

   РпЕКНЙ = гюохяэ
         ЯРПЮМХЖЮ, Size: жекне;
         reloc: люяяхб 1024 хг mSys.CARD16
      йнмеж;

оепел
   asmlist: ЛжЕОЭ.РСжЕОЭ;
   start: РСгБЕМНюЯЛ;
   MemErr: РоПНЖЕДСПЮ;
   dll, con, gui, kos, elf, obj: аскебн;
   Lcount, reccount, topstk: жекне;
   recarray: люяяхб 2048 хг жекне;
   current*: РСгБЕМНюЯЛ;
   callstk: люяяхб 1024, 2 хг РСгБЕМНюЯЛ;
   OutFile: ЛяРП.РяРПНЙЮ;
   Code: люяяхб 4000000 хг кхр; ccount: жекне; Data: люяяхб 1000000 хг кхр; dcount: жекне;
   Labels: люяяхб 200000 хг жекне;
   rdata: люяяхб 400H хг жекне;
   Header: РгЮЦНКНБНЙ;
   etable: ETABLE;
   ExecName: ЛяРП.РяРПНЙЮ;
   LoadAdr: жекне; Reloc: люяяхб 200000 хг кхр; rcount: жекне;
   RtlProc: люяяхб 20 хг жекне; OutFilePos: жекне;
   RelocSection: РяЕЙЖХЪ;
   felf: ЛяРП.РяРПНЙЮ;
   fpu*: жекне;
   isfpu: аскебн;
   maxfpu: жекне;
   fpucmd: РСгБЕМНюЯЛ;
   kosexp: люяяхб 65536 хг гюохяэ
      СгБЕМНяСЫ: ЛгБяСЫ.РСгБЕМНяСЫ;
      Adr, NameLabel: жекне
   йнмеж;
   kosexpcount: жекне;

опнжедспю setfelf*(name: ЛяРП.РяРПНЙЮ);
   мювюкн
      felf := name
   йнмеж setfelf;

опнжедспю AddRtlProc*(idx, proc: жекне);
   мювюкн
      RtlProc[idx] := proc
   йнмеж AddRtlProc;

опнжедспю IntToCard16(i: жекне): mSys.CARD16;
   оепел
      w: mSys.CARD16;
   мювюкн
      mSys.GET(mSys.ADR(i), w)
      бепмсрэ w
   йнмеж IntToCard16;

опнжедспю CopyStr(оеп Dest: люяяхб хг кхр; Source: люяяхб хг кхр; оеп di: жекне; si: жекне);
   мювюкн
      бшв(di);
      онбрнпърэ
      дна(di);
      Dest[di] := Source[si];
      дна(si)
      онйюме Dest[di] = 0X
   йнмеж CopyStr;

опнжедспю exch(оеп a, b: жекне);
   оепел
      c: жекне;
   мювюкн
      c := a;
      a := b;
      b := c
   йнмеж exch;

опнжедспю Sort(оеп NamePtr, Adr: люяяхб хг жекне; Text: люяяхб хг кхр; LB, RB: жекне);
   оепел
      L, R: жекне;

   опнжедспю strle(s1, s2: жекне): аскебн; (* БНР ЩРН ВРН??? МЕ ПЮАНРЮЕР? *)
      оепел
         S1, S2: люяяхб 256 хг кхр; i: жекне;
      мювюкн
         i := 0;
         CopyStr(S1, Text, i, s1);
         i := 0;
         CopyStr(S2, Text, i, s2)
         бепмсрэ S1 <= S2
      йнмеж strle;

   мювюкн
      еякх LB < RB рнцдю
         L := LB;
         R := RB;
         онбрнпърэ
            онйю (L < RB) & strle(NamePtr[L], NamePtr[LB]) декюрэ
               дна(L)
            йнмеж;
            онйю (R > LB) & strle(NamePtr[LB], NamePtr[R]) декюрэ
               бшв(R)
            йнмеж;
            еякх L < R рнцдю
               exch(NamePtr[L], NamePtr[R]);
               exch(Adr[L], Adr[R])
            йнмеж
            онйюме L >= R;
               еякх R > LB рнцдю
                  exch(NamePtr[LB], NamePtr[R]);
                  exch(Adr[LB], Adr[R]);
                  Sort(NamePtr, Adr, Text, LB, R - 1)
               йнмеж;
               Sort(NamePtr, Adr, Text, R + 1, RB)
      йнмеж
   йнмеж Sort;

опнжедспю PackExport(Name: люяяхб хг кхр);
   оепел
      i: жекне;
   мювюкн
      Sort(etable.arrnameptr, etable.arradr, etable.text, 0, etable.namecount - 1);
      дкъ i := 0 дн etable.namecount - 1 декюрэ
         etable.arrnum[i] := IntToCard16(i)
      йнмеж;
      etable.size := 40 + etable.adrcount * 4 + etable.namecount * 6;
      etable.arradroffset := 40;
      etable.arrnameptroffset := 40 + etable.adrcount * 4;
      etable.arrnumoffset := etable.arrnameptroffset + etable.namecount * 4;
      etable.dllnameoffset := etable.size + etable.textlen;
      CopyStr(etable.text, Name, etable.textlen, 0);
      дна(etable.textlen);
      дкъ i := 0 дн etable.namecount - 1 декюрэ
         etable.arrnameptr[i] := etable.arrnameptr[i] + etable.size
      йнмеж;
      etable.size := etable.size + etable.textlen
   йнмеж PackExport;

опнжедспю ProcExport*(Number: жекне; СгБЕМНяСЫ_: ЛгБяСЫ.РСгБЕМНяСЫ; NameLabel: жекне);
   мювюкн
      еякх dll рнцдю
         etable.arradr[etable.adrcount] := Number;
         дна(etable.adrcount);
         etable.arrnameptr[etable.namecount] := etable.textlen;
         дна(etable.namecount);
         CopyStr(etable.text, СгБЕМНяСЫ_.ЯРПхЛЪ, etable.textlen, 0);
         дна(etable.textlen)
      юеякх obj рнцдю
         kosexp[kosexpcount].СгБЕМНяСЫ := СгБЕМНяСЫ_;
         kosexp[kosexpcount].Adr := Number;
         kosexp[kosexpcount].NameLabel := NameLabel;
         дна(kosexpcount)
      йнмеж
   йнмеж ProcExport;

опнжедспю Err(code: жекне);
   мювюкн
      бшанп code хг
         |1: ЛнЬ.яННАЫ(67); ЛйНМЯ.яРПНЙЮ_оЕВЮРЭ(OutFile)
         |2: ЛнЬ.яННАЫ(69); ЛйНМЯ.яРПНЙЮ_оЕВЮРЭ(OutFile)
         |3: ЛнЬ.яННАЫ(58)
         |4: ЛнЬ.яННАЫ(88)
      хмюве
      йнмеж;
      ЛйНМЯ.мНБяРП;
      ЛоПНЖ.гЮЙНМВХРЭ(1)
   йнмеж Err;

опнжедспю Align*(n, m: жекне): жекне;
      бепмсрэ n + (m - n няр m) няр m
   йнмеж Align;

опнжедспю PutReloc(R: РпЕКНЙ);
   оепел
      i: жекне;
   мювюкн
      mSys.PUT(mSys.ADR(Reloc[rcount]), R.ЯРПЮМХЖЮ);
      дна(rcount, 4);
      mSys.PUT(mSys.ADR(Reloc[rcount]), R.Size);
      дна(rcount, 4);
      дкъ i := 0 дн гяо(R.Size - 8, 1) - 1 декюрэ
         mSys.PUT(mSys.ADR(Reloc[rcount]), R.reloc[i]);
         дна(rcount, 2)
      йнмеж
   йнмеж PutReloc;

опнжедспю InitArray(оеп adr: жекне; chars: ЛяРП.РяРПНЙЮ);
   оепел
      i, x, n: жекне;
   мювюкн
      n := LEN(chars) - 1;
      i := 0;
      онйю (i < n) & (chars[i] # 0X) декюрэ
         x := ЛяЙЮМ.вХЯКН16_Б_жЕКНЕ(chars[i]) * 16 + ЛяЙЮМ.вХЯКН16_Б_жЕКНЕ(chars[i + 1]);
         mSys.PUT(adr, бкхр(x));
         дна(adr);
         дна(i, 2)
      йнмеж
   йнмеж InitArray;

опнжедспю WriteF(F, A, N: жекне);
   мювюкн
      еякх ЛтЮИК.гЮОХЯЮРЭ(F, A, N) # N рнцдю
         Err(2)
      йнмеж
   йнмеж WriteF;

опнжедспю Write(A, N: жекне);
   мювюкн
      mSys.MOVE(A, OutFilePos, N);
      OutFilePos := OutFilePos + N
   йнмеж Write;

опнжедспю Fill(n: жекне; c: кхр);
   оепел 
      i: жекне;
   мювюкн
      дкъ i := 1 дн n декюрэ
         Write(mSys.ADR(c), 1)
      йнмеж
   йнмеж Fill;

опнжедспю SetSection(оеп Section: РяЕЙЖХЪ; name: РяЕЙЖХЪхЛЪ; size, adr, sizealign, OAPfile, attrflags: жекне);
   мювюкн
      Section.ХЛЪ := name;
      Section.size := size;
      Section.adr := adr;
      Section.sizealign := sizealign;
      Section.OAPfile := OAPfile;
      Section.attrflags := attrflags;
   йнмеж SetSection;

опнжедспю WritePE(FName: люяяхб хг кхр; stksize, codesize, datasize, rdatasize, gsize: жекне);
   CONST
      textattr = 60000020H; rdataattr = 40000040H; dataattr = 0C0000040H; relocattr = 42000040H;
   оепел
      i, F, adr, acodesize, compver, version, stkalloc, heapsize, heapalloc, filesize, filebuf: жекне;
      cur: РСгБЕМНюЯЛ;
   мювюкн
      compver := 0;
      version := 0;
      stkalloc := stksize;
      heapsize := 100000H;
      heapalloc := 100000H;
      acodesize := Align(codesize, 1000H) + 1000H;
      adr := mSys.ADR(rdata);
      filesize := acodesize + Align(rdatasize, 1000H) + Align(datasize, 1000H) + Align(rcount, 1000H);

      InitArray(adr, "5000000040000000000000003400000000000000000000006200000000000000");
      InitArray(adr, "0000000000000000000000000000000000000000500000004000000000000000");
      InitArray(adr, "A4014C6F61644C6962726172794100001F0147657450726F6341646472657373");
      InitArray(adr, "00006B65726E656C33322E646C6C0000");

      rdata[ 0] := acodesize + 50H;
      rdata[ 1] := acodesize + 40H;
      rdata[ 3] := acodesize + 34H;
      rdata[ 6] := acodesize + 62H;
      rdata[ 7] := acodesize;
      rdata[13] := acodesize + 50H;
      rdata[14] := acodesize + 40H;

      adr := mSys.ADR(Header.msdos);
      InitArray(adr, "4D5A90000300000004000000FFFF0000B8000000000000004000000000000000");
      InitArray(adr, "00000000000000000000000000000000000000000000000000000000B0000000");
      InitArray(adr, "0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F");
      InitArray(adr, "742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000");
      InitArray(adr, "5DCF9F8719AEF1D419AEF1D419AEF1D497B1E2D413AEF1D4E58EE3D418AEF1D4");
      InitArray(adr, "5269636819AEF1D4000000000000000050450000");
      Header.typecomp := IntToCard16(014CH);
      еякх dll рнцдю
         Header.seccount := IntToCard16(0004H);
         Header.infflags := IntToCard16(210EH)
      хмюве
         Header.seccount := IntToCard16(0003H);
         Header.infflags := IntToCard16(010FH)
      йнмеж;
      Header.time := ЛйНМЯР.ДЮРЮ;
      Header.PEoptsize := IntToCard16(00E0H);
      Header.PEfile := IntToCard16(010BH);
      Header.compver := IntToCard16(compver);
      Header.codesize := Align(codesize, 200H);
      Header.datasize := Align(datasize + gsize, 200H) + Align(rdatasize, 200H) + Align(rcount, 200H);
      Header.startadr := 1000H;
      Header.codeadr := 1000H;
      Header.rdataadr := Header.codeadr + Align(codesize, 1000H);
      Header.loadadr := LoadAdr;
      Header.secalign := 1000H;
      Header.filealign := 0200H;
      Header.oldestver := 0004H;
      Header.version := version;
      Header.oldestverNT := 0004H;
      Header.filesize := Align(codesize, 1000H) + Align(datasize + gsize, 1000H) + Align(rdatasize, 1000H) + Align(rcount, 1000H) + 1000H;
      Header.headersize := 0400H;
      Header.UI := IntToCard16(мкхр(con) + 2);
      Header.stksize := stksize;
      Header.stkalloc := stkalloc;
      Header.heapsize := heapsize;
      Header.heapalloc := heapalloc;
      Header.structcount := 10H;
      еякх dll рнцдю
         Header.structs[0].adr := Header.rdataadr + 0DAH;
         Header.structs[0].size := etable.size
      йнмеж;

      Header.structs[1].adr := Header.rdataadr + 0CH;
      Header.structs[1].size := 28H;
      Header.structs[12].adr := Header.rdataadr;
      Header.structs[12].size := 0CH;

      SetSection(Header.sections[0], ".text", codesize, 1000H, Align(codesize, 200H), 400H, textattr);
      SetSection(Header.sections[1], ".rdata", rdatasize, Align(codesize, 1000H) + 1000H, Align(rdatasize, 200H),
         Align(codesize, 200H) + 400H, rdataattr);
      SetSection(Header.sections[2], ".data", datasize + gsize, Align(codesize, 1000H) + Align(rdatasize, 1000H) + 1000H,
         Align(datasize, 200H), Align(codesize, 200H) + Align(rdatasize, 200H) + 400H, dataattr);

      еякх dll рнцдю
         SetSection(RelocSection, ".reloc", rcount, Header.sections[2].adr + Align(datasize + gsize, 1000H), Align(rcount, 200H),
            Header.sections[2].OAPfile + Align(datasize, 200H), relocattr);
         Header.structs[5].adr := RelocSection.adr;
         Header.structs[5].size := rcount
      йнмеж;

      F := ЛтЮИК.яНГДЮРЭ(FName);
      еякх F = 0 рнцдю
         Err(1)
      йнмеж;
      OutFilePos := ЛоЮЛ.оНКСВ(filesize);
      filebuf := OutFilePos;
      ЛоЮЛ.лЮКН(OutFilePos = 0);

      Write(mSys.ADR(Header), mSys.SIZE(РгЮЦНКНБНЙ));
      еякх dll рнцдю
         Write(mSys.ADR(RelocSection), mSys.SIZE(РяЕЙЖХЪ));
         Fill(Align(mSys.SIZE(РгЮЦНКНБНЙ) + mSys.SIZE(РяЕЙЖХЪ), 200H) - (mSys.SIZE(РгЮЦНКНБНЙ) + mSys.SIZE(РяЕЙЖХЪ)), 0X)
      хмюве
         Fill(Align(mSys.SIZE(РгЮЦНКНБНЙ), 200H) - mSys.SIZE(РгЮЦНКНБНЙ), 0X)
      йнмеж;

      cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
      онйю cur # осярн декюрэ
         Write(mSys.ADR(Code[cur.ЙЛД]), cur.clen);
         cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
      йнмеж;
      Fill(Align(codesize, 200H) - codesize, 0X);
      Write(mSys.ADR(rdata), 0DAH);
      еякх dll рнцдю
         etable.time := Header.time;
         Write(mSys.ADR(etable), 40);
         Write(mSys.ADR(etable.arradr), etable.adrcount * 4);
         Write(mSys.ADR(etable.arrnameptr), etable.namecount * 4);
         Write(mSys.ADR(etable.arrnum), etable.namecount * 2);
         Write(mSys.ADR(etable.text), etable.textlen)
      йнмеж;
      Fill(Align(rdatasize, 200H) - rdatasize, 0X);
      Write(mSys.ADR(Data), datasize);
      Fill(Align(datasize, 200H) - datasize, 0X);
      еякх dll рнцдю
         Write(mSys.ADR(Reloc), rcount);
         Fill(Align(rcount, 200H) - rcount, 0X)
      йнмеж;
      WriteF(F, filebuf, OutFilePos - filebuf);
      ЛтЮИК.гЮЙПШРЭ(F)
   йнмеж WritePE;

опнжедспю New;
   оепел
      nov: РСгБЕМНюЯЛ;
   мювюкн
      мнб(nov);
      MemErr(nov = осярн);
      nov.ЙЛД := ccount;
      ЛжЕОЭ.бЯРЮБХРЭ(asmlist, nov, current);
      current := current.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
   йнмеж New;

опнжедспю Empty(varadr: жекне);
   мювюкн
      New;
      current.clen := 0;
      current.tcmd := ECMD;
      current.ОЕПЕЛ.ЮДПЕЯ := varadr
   йнмеж Empty;

опнжедспю OutByte(byte: жекне);
   мювюкн
      New;
      current.clen := 1;
      Code[ccount] := бкхр(byte);
      дна(ccount)
   йнмеж OutByte;

опнжедспю OutInt(int: жекне);
   мювюкн
      New;
      current.clen := 4;
      mSys.PUT(mSys.ADR(Code[ccount]), int);
      дна(ccount, 4)
   йнмеж OutInt;

опнжедспю PushEAX;
   мювюкн
      OutByte(50H);
      current.tcmd := PUSHEAX
   йнмеж PushEAX;

опнжедспю PushECX;
   мювюкн
      OutByte(51H);
      current.tcmd := PUSHECX
   йнмеж PushECX;

опнжедспю PushEDX;
   мювюкн
      OutByte(52H);
      current.tcmd := PUSHEDX
   йнмеж PushEDX;

опнжедспю PopEAX;
   мювюкн
      OutByte(58H);
      current.tcmd := POPEAX
   йнмеж PopEAX;

опнжедспю PopECX;
   мювюкн
      OutByte(59H);
      current.tcmd := POPECX
   йнмеж PopECX;

опнжедспю PopEDX;
   мювюкн
      OutByte(5AH);
      current.tcmd := POPEDX
   йнмеж PopEDX;

опнжедспю OutCode(cmd: ЛяРП.РяРПНЙЮ);
   оепел
      a, b: жекне;
   мювюкн
      New;
      a := mSys.ADR(Code[ccount]);
      b := a;
      InitArray(a, cmd);
      ccount := a - b + ccount;
      current.clen := a - b
   йнмеж OutCode;

опнжедспю Del*(last: РСгБЕМНюЯЛ);
   мювюкн
      last.ЯКЕДСЧЫ := current.ЯКЕДСЧЫ;
      еякх current = asmlist.ЯКЕДСЧЫ рнцдю
         asmlist.ЯКЕДСЧЫ := last
      йнмеж;
      current := last
   йнмеж Del;

опнжедспю NewLabel*(): жекне;
   мювюкн
      дна(Lcount)
      бепмсрэ Lcount
   йнмеж NewLabel;

опнжедспю PushCall*(asmline: РСгБЕМНюЯЛ);
   мювюкн
      New;
      callstk[topstk][0] := asmline;
      callstk[topstk][1] := current;
      дна(topstk)
   йнмеж PushCall;

опнжедспю Param*;
   мювюкн
      current := callstk[topstk - 1][0]
   йнмеж Param;

опнжедспю бШГНБ_гЮЙНМВХРЭ*;
  мювюкн
    current := callstk[topstk - 1][1];
    бшв(topstk)
  йнмеж бШГНБ_гЮЙНМВХРЭ;

опнжедспю мЮЯРПНХРЭ*(mem: РоПНЖЕДСПЮ; UI: жекне);
  оепел
    nov: РСгБЕМНюЯЛ;
  мювюкн
    dcount := 4;
    dll := UI = 1;
    gui := UI = 2;
    con := UI = 3;
    kos := UI = 4;
    elf := UI = 5;
    obj := UI = 6;
    MemErr := mem;
    Lcount := HALT;
    asmlist := ЛжЕОЭ.яНГДЮРЭ();
    MemErr(asmlist = осярн);
    мнб(nov);
    MemErr(nov = осярн);
    ЛжЕОЭ.дНАЮБХРЭ(asmlist, nov);
    current := nov;
  йнмеж мЮЯРПНХРЭ;

опнжедспю datastr(str: ЛяРП.РяРПНЙЮ);
  оепел i, n: жекне;
  мювюкн
    i := 0;
    n := LEN(str);
    онйю (i < n) & (str[i] # 0X) декюрэ
      Data[dcount] := str[i];
      дна(dcount);
      дна(i)
    йнмеж;
    Data[dcount] := 0X;
    дна(dcount)
  йнмеж datastr;

опнжедспю dataint(n: жекне);
  мювюкн
    mSys.PUT(mSys.ADR(Data[dcount]), n);
    дна(dcount, 4)
  йнмеж dataint;

опнжедспю jmp*(jamp: кхр; label: жекне);
   оепел
      n: жекне;
   мювюкн
      New;
      бшанп jamp хг
      |JMP, CALL:
         n := 5
      |JE, JLE, JGE, JG, JL, JNE:
         Code[ccount] := 0FX;
         дна(ccount);
         n := 6
      хмюве
      йнмеж;
      current.clen := n;
      Code[ccount] := jamp;
      дна(ccount);
      current.ЙНД.ЮДПЕЯ := mSys.ADR(Code[ccount]);
      current.ОЕПЕЛ.ЮДПЕЯ := mSys.ADR(Labels[label]);
      current.tcmd := JCMD;
      current.АйНПНРЙНЕ := хярхмю;
      дна(ccount, 4)
   йнмеж jmp;

опнжедспю jmplong(jamp: кхр; label: жекне);
   мювюкн
      jmp(jamp, label);
      current.АйНПНРЙНЕ := кнфэ
   йнмеж jmplong;

опнжедспю Label*(label: жекне);
  мювюкн
    New;
    current.ОЕПЕЛ.ЮДПЕЯ := mSys.ADR(Labels[label]);
    current.tcmd := LCMD
  йнмеж Label;

опнжедспю CmdN(Number: жекне);
  мювюкн
    New;
    current.clen := 4;
    current.ЙНД.ЮДПЕЯ := mSys.ADR(Code[ccount]);
    current.ОЕПЕЛ.ЮДПЕЯ := mSys.ADR(Labels[Number]);
    current.tcmd := OCMD;
    дна(ccount, 4)
  йнмеж CmdN;

опнжедспю IntByte(bytecode, intcode: ЛяРП.РяРПНЙЮ; n: жекне);
  мювюкн
    еякх (n <= 127) & (n >= -128) рнцдю
      OutCode(bytecode);
      OutByte(n)
    хмюве
      OutCode(intcode);
      OutInt(n)
    йнмеж
  йнмеж IntByte;

опнжедспю DropFpu*(long: аскебн);
  мювюкн
    еякх long рнцдю
      OutCode("83EC08DD1C24")
    хмюве
      OutCode("83EC04D91C24")
    йнмеж;
    бшв(fpu)
  йнмеж DropFpu;

опнжедспю AfterRet(func, float: аскебн; callconv, parsize: жекне);
  мювюкн
    еякх callconv = cdecl рнцдю
      OutCode("81C4");
      OutInt(parsize)
    йнмеж;
    еякх func рнцдю
      еякх float рнцдю
        OutCode("83EC08DD1C24")
      хмюве
        PushEAX
      йнмеж
    йнмеж
  йнмеж AfterRet;

опнжедспю FpuSave(local: жекне);
  оепел i: жекне;
  мювюкн
    еякх fpu > maxfpu рнцдю
      maxfpu := fpu
    йнмеж;
    дкъ i := 1 дн fpu декюрэ
      IntByte("DD5D", "DD9D", -local - i * 8)
    йнмеж
  йнмеж FpuSave;

опнжедспю Incfpu;
  мювюкн
    еякх fpu >= FREGS рнцдю
      ЛнЬ.яННАЫйННПД(ЛяЙЮМ.ЖяРПНЙЮ, ЛяЙЮМ.col, 97, ЛтЮИК.СтЮИК.ЯРПхЛЪ);
      ЛоПНЖ.гЮЙНМВХРЭ(1)
    йнмеж;
    дна(fpu);
    isfpu := хярхмю
  йнмеж Incfpu;

опнжедспю FpuLoad(local: жекне; float: аскебн);
  оепел i: жекне;
  мювюкн
    дкъ i := fpu дн 1 он -1 декюрэ
      IntByte("DD45", "DD85", -local - i * 8)
    йнмеж;
    еякх float рнцдю
      Incfpu;
      OutCode("DD042483C408")
    йнмеж
  йнмеж FpuLoad;

опнжедспю Call*(proc: жекне; func, float: аскебн; callconv, ccall, bases, level, parsize, local: жекне);
  оепел i: жекне;
  мювюкн
    еякх ccall # 0 рнцдю
      дкъ i := level дн level - bases + мкхр(ccall = 1) + 1 он -1 декюрэ
        IntByte("FF75", "FFB5", 4 * i + 4)
      йнмеж;
      еякх ccall = 1 рнцдю
        OutByte(55H)
      йнмеж
    йнмеж;
    FpuSave(local);
    jmplong(CALL, proc);
    AfterRet(func, float, callconv, parsize);
    FpuLoad(local, func & float)
  йнмеж Call;

опнжедспю CallRTL(Proc: жекне);
  мювюкн
    New;
    current.clen := 5;
    Code[ccount] := CALL;
    дна(ccount);
    current.ЙНД.ЮДПЕЯ := mSys.ADR(Code[ccount]);
    current.ОЕПЕЛ.ЮДПЕЯ := mSys.ADR(RtlProc[Proc]);
    current.tcmd := JCMD;
    дна(ccount, 4)
  йнмеж CallRTL;

опнжедспю PushInt*(n: жекне);
  мювюкн
    OutByte(68H);
    CmdN(n)
  йнмеж PushInt;

опнжедспю Prolog*(exename: ЛяРП.РяРПНЙЮ);
  мювюкн
    ExecName := exename;
    Labels[hInstance] := -dcount;
    dataint(0);
    Labels[SELFNAME] := -dcount;
    datastr(exename);
    Label(START);
    еякх dll рнцдю
      OutCode("558BEC837D0C007507");
      CallRTL(_close);
      OutCode("EB06837D0C017409B801000000C9C20C00")
    юеякх obj рнцдю
      OutCode("558BEC")
    йнмеж;
    start := asmlist.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
  йнмеж Prolog;

опнжедспю AddRec*(base: жекне);
  мювюкн
    дна(reccount);
    recarray[reccount] := base
  йнмеж AddRec;

опнжедспю CmpOpt(inv: аскебн): жекне;
  оепел cur: РСгБЕМНюЯЛ; c: жекне;
  мювюкн
    c := мкхр(Code[current.ОПЕДШДСЫ.ОПЕДШДСЫ(РСгБЕМНюЯЛ).ЙЛД]);
    еякх inv рнцдю
      еякх ODD(c) рнцдю
        бшв(c)
      хмюве
        дна(c)
      йнмеж
    йнмеж;
    cur := current;
    онбрнпърэ
      cur.tcmd := 0;
      cur.clen := 0;
      cur := cur.ОПЕДШДСЫ(РСгБЕМНюЯЛ)
    онйюме cur.tcmd = ICMP1;
    cur.tcmd := 0;
    cur.clen := 0
    бепмсрэ c - 16
  йнмеж CmpOpt;

опнжедспю ifwh*(L: жекне);
  оепел c: жекне;
  мювюкн
    еякх current.ОПЕДШДСЫ(РСгБЕМНюЯЛ).tcmd = ICMP2 рнцдю
      c := CmpOpt(хярхмю);
      OutCode("5A583BC2");
      jmp(бкхр(c), L)
    хмюве
      PopECX;
      OutCode("85C9");
      jmp(JE, L)
    йнмеж
  йнмеж ifwh;

опнжедспю PushConst*(Number: жекне);
   мювюкн
      IntByte("6A", "68", Number);
      current.ОПЕДШДСЫ(РСгБЕМНюЯЛ).ОЕПЕЛ.ЮДПЕЯ := Number
   йнмеж PushConst;

опнжедспю IfWhile*(L: жекне; orop: аскебн);
  оепел c, L1: жекне;
  мювюкн
    L1 := NewLabel();
    еякх current.ОПЕДШДСЫ(РСгБЕМНюЯЛ).tcmd = ICMP2 рнцдю
      c := CmpOpt(orop);
      OutCode("5A583BC2");
      jmp(бкхр(c), L1);
      PushConst(мкхр(orop))
    хмюве
      PopECX;
      OutCode("85C9");
      еякх orop рнцдю
        jmp(JE, L1)
      хмюве
        jmp(JNE, L1)
      йнмеж;
      PushECX
    йнмеж;
    jmp(JMP, L);
    Label(L1)
  йнмеж IfWhile;

опнжедспю newrec*;
  мювюкн
    CallRTL(_newrec)
  йнмеж newrec;

  опнжедспю disprec*;
  мювюкн
    CallRTL(_disprec)
  йнмеж disprec;

опнжедспю String*(Number, Len: жекне; str: ЛяРП.РяРПНЙЮ);
  мювюкн
    Labels[Number] := -dcount;
    еякх Len > 1 рнцдю
      datastr(str)
    юеякх Len = 1 рнцдю
      dataint(мкхр(str[0]))
    хмюве
      dataint(0)
    йнмеж
  йнмеж String;

опнжедспю InsertFpuInit;
  оепел t: РСгБЕМНюЯЛ;
  мювюкн
    еякх isfpu рнцдю
      t := current;
      current := fpucmd;
      еякх maxfpu > 0 рнцдю
        OutCode("83EC");
        OutByte(maxfpu * 8)
      йнмеж;
      OutCode("DBE3");
      current := t
    йнмеж
  йнмеж InsertFpuInit;

опнжедспю ProcBeg*(Number, Local: жекне; Module: аскебн);
  оепел i: жекне;
  мювюкн
    еякх Module рнцдю
      OutCode("EB0C");
      Label(Number + 3);
      PushInt(Number + 2);
      jmplong(JMP, HALT);
      Label(Number + 1)
    хмюве
      Label(Number)
    йнмеж;
    OutCode("558BEC");
    еякх Local > 12 рнцдю
      IntByte("83EC", "81EC", Local);
      OutCode("8BD733C08BFCB9");
      OutInt(гяо(Local, 2));
      OutCode("9CFCF3AB8BFA9D")
    хмюве
      дкъ i := 4 дн Local он 4 декюрэ
        OutCode("6A00")
      йнмеж
    йнмеж;
    fpucmd := current;
    fpu := 0;
    maxfpu := 0;
    isfpu := кнфэ
  йнмеж ProcBeg;

опнжедспю Leave*;
  мювюкн
    OutByte(0C9H);
    InsertFpuInit
  йнмеж Leave;

опнжедспю ProcEnd*(Number, Param: жекне; func, float: аскебн);
  мювюкн
    еякх func & ~float рнцдю
      PopEAX
    йнмеж;
    OutByte(0C9H);
    еякх Param = 0 рнцдю
      OutByte(0C3H)
    хмюве
      OutByte(0C2H);
      OutByte(Param няр 256);
      OutByte(гяо(Param, 8))
    йнмеж;
    InsertFpuInit
  йнмеж ProcEnd;

опнжедспю Module*(Name: ЛяРП.РяРПНЙЮ; Number: жекне);
  мювюкн
    String(Number + 2, LENGTH(Name), Name);
    jmplong(JMP, Number + 1)
  йнмеж Module;

опнжедспю Asm*(s: ЛяРП.РяРПНЙЮ);
  мювюкн
    OutCode(s)
  йнмеж Asm;

опнжедспю GlobalAdr*(offset: жекне);
  мювюкн
    OutByte(0BAH);
    OutInt(offset);
    current.ЙНД.ЮДПЕЯ := mSys.ADR(Code[ccount - 4]);
    current.tcmd := GCMD;
    PushEDX
  йнмеж GlobalAdr;

опнжедспю Mono*(Number: жекне);
  мювюкн
    PopEDX;
    PushInt(Number)
  йнмеж Mono;

опнжедспю StrMono*;
  мювюкн
    PopEDX;
    OutCode("6A02");
    PushEDX
  йнмеж StrMono;

опнжедспю Not*;
  мювюкн
    PopECX;
    OutCode("85C90F94C1");
    PushECX
  йнмеж Not;

опнжедспю NegSet*;
  мювюкн
    OutCode("F71424")
  йнмеж NegSet;

опнжедспю Int*(Op: жекне);
  мювюкн
    PopEDX;
    бшанп Op хг
    |ЛйНМЯР.НОоКЧЯ:  OutCode("011424")
    |ЛйНМЯР.НОлХМСЯ: OutCode("291424")
    |ЛйНМЯР.НОсЛМНФ:  OutCode("58F7EA"); PushEAX
    хмюве
    йнмеж
  йнмеж Int;

опнжедспю Set*(Op: жекне);
  мювюкн
    PopEDX;
    OutCode("58");
    бшанп Op хг
    |ЛйНМЯР.НОоКЧЯ:  OutCode("0B")
    |ЛйНМЯР.НОлХМСЯ: OutCode("F7D223")
    |ЛйНМЯР.НОсЛМНФ:  OutCode("23")
    |ЛйНМЯР.НОдЕКЕМ: OutCode("33")
    хмюве
    йнмеж;
    OutCode("C2");
    PushEAX
  йнмеж Set;

опнжедспю Setfpu*(newfpu: жекне);
  мювюкн
    fpu := newfpu
  йнмеж Setfpu;

опнжедспю PushFlt*(x: дкхмбеы);
  оепел f: TFLT; L: жекне;
  мювюкн
    mSys.PUT(mSys.ADR(f), x);
    Incfpu;
    еякх x = 0.0D0 рнцдю
      OutCode("D9EE")
    юеякх x = 1.0D0 рнцдю
      OutCode("D9E8")
    хмюве
      L := NewLabel();
      Labels[L] := -dcount;
      dataint(f[0]);
      dataint(f[1]);
      OutByte(0BAH);
      CmdN(L);
      OutCode("DD02")
    йнмеж
  йнмеж PushFlt;

опнжедспю farith*(op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("DE");
    бшанп op хг
    |ЛйНМЯР.НОоКЧЯ:  n := 0C1H
    |ЛйНМЯР.НОлХМСЯ: n := 0E9H
    |ЛйНМЯР.НОсЛМНФ:  n := 0C9H
    |ЛйНМЯР.НОдЕКЕМ: n := 0F9H
    хмюве
    йнмеж;
    OutByte(n);
    бшв(fpu)
  йнмеж farith;

опнжедспю fcmp*(Op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("33C9DED9DFE09E0F");
    бшанп Op хг
    |ЛйНМЯР.НОпЮБМН: n := 94H
    |ЛйНМЯР.НОмЕпЮБМН: n := 95H
    |ЛйНМЯР.НОлЕМЭЬЕ: n := 97H
    |ЛйНМЯР.НОаНКЭЬЕ: n := 92H
    |lxLE: n := 93H
    |lxGE: n := 96H
    хмюве
    йнмеж;
    бшв(fpu, 2);
    OutByte(n);
    OutByte(0C1H);
    PushECX
  йнмеж fcmp;

опнжедспю fneg*;
  мювюкн
    OutCode("D9E0")
  йнмеж fneg;

опнжедспю OnError*(n: жекне);
  мювюкн
    OutByte(68H);
    OutInt(ЛсРХКЭ.ЯРПНЙЮ_МНЛ * 16 + n);
    jmplong(JMP, ЛсРХКЭ.ЛНДСКЭ_МНЛ + 3)
  йнмеж OnError;

опнжедспю idivmod*(opmod: аскебн);
  мювюкн
    PopECX;
    еякх opmod рнцдю
      OutCode("58E32E538BD833D9C1FB1F8BD0C1FA1F83F9FF750C3D0000008075055B6A00EB1AF7F985DB740685D2740203D15B52EB0A")
    хмюве
      OutCode("58E32C538BD833D9C1FB1F8BD0C1FA1F83F9FF750B3D0000008075045B50EB19F7F985DB740585D27401485B50EB0A")
    йнмеж;
    OnError(8)
  йнмеж idivmod;

опнжедспю rset*;
  мювюкн
    CallRTL(_rset);
    PushEAX
  йнмеж rset;

опнжедспю inset*;
  мювюкн
    CallRTL(_inset);
    PushEAX
  йнмеж inset;

опнжедспю Dup*;
  мювюкн
    PopEDX;
    PushEDX;
    PushEDX
  йнмеж Dup;

опнжедспю Inclusion*(Op: жекне);
  мювюкн
    PopEDX;
    PopEAX;
    еякх Op = lxLE рнцдю
      PushEDX
    хмюве
      PushEAX
    йнмеж;
    OutCode("0BC25933C8E3046A00EB026A01")
  йнмеж Inclusion;

опнжедспю NegInt*;
  мювюкн
    OutCode("F71C24")
  йнмеж NegInt;

опнжедспю CmpInt*(Op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("33C95A583BC20F"); current.tcmd := ICMP1;
    бшанп Op хг
    |ЛйНМЯР.НОпЮБМН: n := 94H
    |ЛйНМЯР.НОмЕпЮБМН: n := 95H
    |ЛйНМЯР.НОлЕМЭЬЕ: n := 9CH
    |ЛйНМЯР.НОаНКЭЬЕ: n := 9FH
    |lxLE: n := 9EH
    |lxGE: n := 9DH
    хмюве
    йнмеж;
    OutByte(n);
    OutCode("C1"); current.tcmd := ICMP2;
    PushECX;
  йнмеж CmpInt;

опнжедспю CallVar*(func, float: аскебн; callconv, parsize, local: жекне);
  мювюкн
    PopEDX;
    OutCode("8B1285D2750A");
    OnError(2);
    FpuSave(local);
    OutCode("FFD2");
    AfterRet(func, float, callconv, parsize);
    FpuLoad(local, func & float)
  йнмеж CallVar;

опнжедспю LocalAdr*(offset, bases: жекне);
  мювюкн
    еякх bases = 0 рнцдю
      Empty(offset);
      OutCode("8BD5")
    хмюве
      IntByte("8B55", "8B95", 4 * bases + 4)
    йнмеж;
    IntByte("83C2", "81C2", offset);
    PushEDX;
    еякх bases = 0 рнцдю
      Empty(offset)
    йнмеж
  йнмеж LocalAdr;

опнжедспю Field*(offset: жекне);
  мювюкн
    еякх offset # 0 рнцдю
      IntByte("830424", "810424", offset)
    йнмеж
  йнмеж Field;

опнжедспю DerefType*(n: жекне);
  мювюкн
    IntByte("8B5424", "8B9424", n);
    OutCode("FF72FC")
  йнмеж DerefType;

опнжедспю Guard*(T: жекне; Check: аскебн);
  мювюкн
    еякх Check рнцдю
      PopEAX;
      OutCode("85C074");
      еякх T <= 127 рнцдю
        OutByte(9)
      хмюве
        OutByte(12)
      йнмеж;
      PushEAX
    йнмеж;
    PushConst(T);
    PushEAX;
    CallRTL(_checktype);
    еякх Check рнцдю
      PushEAX
    хмюве
      OutCode("85C0750A");
      OnError(3)
    йнмеж
  йнмеж Guard;

опнжедспю StProc*(proc: жекне);
  мювюкн
    бшанп proc хг
    |ЛйНМЯР.ОПНЖдна:   PopEDX; OutCode("590111")
    |ЛйНМЯР.ОПНЖбшв:   PopEDX; OutCode("592911")
    |ЛйНМЯР.ОПНЖднонкм:  PopEDX; OutCode("FF02")
    |ЛйНМЯР.ОПНЖгмякнф:  PopEDX; OutCode("FF0A")
    |ЛйНМЯР.ОПНЖднаб:  PopEDX; OutCode("580910")
    |ЛйНМЯР.ОПНЖбшвб:  PopEDX; OutCode("582110")
    |ЛйНМЯР.sysBIT:  PopECX; OutCode("5A585333DB8A18E3050FABD3EB030FB3D388185B")
    |ЛйНМЯР.ОПНЖсоюй:  OutCode("DB04245A5ADD02D9FDDD1A"); isfpu := хярхмю
    |ЛйНМЯР.ОПНЖсоюйяоеж: OutCode("DB04245A5AD902D9FDD91A"); isfpu := хярхмю
    |ЛйНМЯР.ОПНЖпюяо:  PopEDX; OutCode("59DD01D9F4DD19DB1A"); isfpu := хярхмю
    |ЛйНМЯР.ОПНЖпюяояоеж: PopEDX; OutCode("59D901D9F4D919DB1A"); isfpu := хярхмю
    |ЛйНМЯР.ОПНЖйнохъ:  CallRTL(_strcopy)
    |ЛйНМЯР.sysMOVE: CallRTL(_savearr)
    хмюве
    йнмеж
  йнмеж StProc;

опнжедспю Assert*(proc, assrt: жекне);
  мювюкн
    PopEDX;
    OutCode("85D2751368");
    OutInt(ЛсРХКЭ.ЯРПНЙЮ_МНЛ * 16 + 1);
    PushInt(ЛсРХКЭ.ЛНДСКЭ_МНЛ + 2);
    еякх proc = ЛйНМЯР.ОПНЖйнмрпнкэ рнцдю
      OutCode("6A026A")
    хмюве
      OutCode("6A016A")
    йнмеж;
    OutByte(assrt);
    jmplong(JMP, ASSRT)
  йнмеж Assert;

опнжедспю StFunc*(func: жекне);
  мювюкн
    бшанп func хг
    |ЛйНМЯР.ОПНЖюая:    PopEDX; OutCode("85D27D02F7DA"); PushEDX
    |ЛйНМЯР.ОПНЖюаяб:   OutCode("D9E1")
    |ЛйНМЯР.ОПНЖйбеы:    OutCode("DB0424"); PopEAX; Incfpu;
    |ЛйНМЯР.ОПНЖйжек:  OutCode("83EC06D93C2466812424FFF366810C24FFF7D92C2483C402D9FCDB1C24"); бшв(fpu)
    |ЛйНМЯР.ОПНЖв╗р:    OutCode("83242401")
    |ЛйНМЯР.ОПНЖжяо:    PopECX; OutCode("58D3C8"); PushEAX
    |ЛйНМЯР.ОПНЖгяо:    PopECX; OutCode("58D3F8"); PushEAX
    |ЛйНМЯР.ОПНЖкяк:    PopECX; OutCode("58D3E0"); PushEAX
    |ЛйНМЯР.ОПНЖкяо:    PopECX; OutCode("58D3E8"); PushEAX
    |ЛйНМЯР.ОПНЖмкхр:    PopEDX; OutCode("85D274036A015A"); PushEDX
    |ЛйНМЯР.ОПНЖдкхмярп: CallRTL(_length); PushEAX
    |ЛйНМЯР.sysBIT:   PopEDX; OutCode("5933C08A010FA3D072046A00EB026A01")
    хмюве
    йнмеж
  йнмеж StFunc;

опнжедспю Load*(T: жекне);
   оепел
      lastcmd: РСгБЕМНюЯЛ;
      offset: жекне;

   опнжедспю del;
      мювюкн
         lastcmd.tcmd := 0;
         offset := lastcmd.ОЕПЕЛ.ЮДПЕЯ;
         lastcmd := lastcmd.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
         онйю lastcmd.tcmd # ECMD декюрэ
            lastcmd.clen := 0;
            lastcmd.tcmd := 0;
            lastcmd := lastcmd.ОПЕДШДСЫ(РСгБЕМНюЯЛ)
         йнмеж;
         lastcmd.tcmd := 0
      йнмеж del;

  мювюкн
    lastcmd := current;
    бшанп T хг
    |ЛйНМЯР.РХОжекне, ЛйНМЯР.РХОмюанп, ЛйНМЯР.РХОсйюгюрекэ, ЛйНМЯР.РХОопнжедспю:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("8B55", "8B95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("FF32")
      йнмеж
    |ЛйНМЯР.РХОкхрепю, ЛйНМЯР.РХОаскебн:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        OutCode("33D28A");
        IntByte("55", "95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("33C98A0A");
        PushECX
      йнмеж
    |ЛйНМЯР.РХОдкхмбеы:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("DD45", "DD85", offset)
      хмюве
        PopEDX;
        OutCode("DD02")
      йнмеж;
      Incfpu
    |ЛйНМЯР.РХОбеы:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("D945", "D985", offset)
      хмюве
        PopEDX;
        OutCode("D902")
      йнмеж;
      Incfpu
    |ЛйНМЯР.TCARD16:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        OutCode("33D2668B");
        IntByte("55", "95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("33C9668B0A");
        PushECX
      йнмеж
    хмюве
    йнмеж
  йнмеж Load;

опнжедспю Save*(T: жекне);
  мювюкн
    бшанп T хг
    |ЛйНМЯР.РХОжекне, ЛйНМЯР.РХОмюанп, ЛйНМЯР.РХОсйюгюрекэ, ЛйНМЯР.РХОопнжедспю:
      PopEDX;
      OutCode("588910")
    |ЛйНМЯР.РХОкхрепю, ЛйНМЯР.РХОярпнйю, ЛйНМЯР.РХОаскебн:
      PopEDX;
      OutCode("588810")
    |ЛйНМЯР.TCARD16:
      PopEDX;
      OutCode("58668910")
    |ЛйНМЯР.РХОдкхмбеы:
      PopEDX;
      OutCode("DD1A");
      бшв(fpu)
    |ЛйНМЯР.РХОбеы:
      PopEDX;
      OutCode("D91A");
      бшв(fpu)
    |ЛйНМЯР.РХОгюохяэ:
      CallRTL(_saverec);
      OutCode("83F800750A");
      OnError(4)
    |ЛйНМЯР.РХОлюяяхб:
      CallRTL(_savearr)
    хмюве
    йнмеж
  йнмеж Save;

опнжедспю OpenArray*(A: TIDX; n: жекне);
  оепел i: жекне;
  мювюкн
    PopEDX;
    дкъ i := n - 1 дн 0 он -1 декюрэ
      PushConst(A[i])
    йнмеж;
    PushEDX
  йнмеж OpenArray;

опнжедспю OpenIdx*(n: жекне);
  мювюкн
    OutByte(54H);
    еякх n > 1 рнцдю
      PushConst(n);
      CallRTL(_arrayidx)
    хмюве
      CallRTL(_arrayidx1)
    йнмеж;
    PopEDX;
    OutCode("85D2750A");
    OnError(5);
    PushEDX;
  йнмеж OpenIdx;

опнжедспю FixIdx*(len, size: жекне);
  мювюкн
    PopEDX;
    IntByte("5983FA", "5981FA", len);
    OutCode("720A");
    OnError(5);
    еякх size > 1 рнцдю
      IntByte("6BD2", "69D2", size)
    йнмеж;
    OutCode("03D1");
    PushEDX
  йнмеж FixIdx;

опнжедспю Idx*;
  мювюкн
    PopEDX;
    PopECX;
    OutCode("03D1");
    PushEDX
  йнмеж Idx;

опнжедспю DupLoadCheck*;
  мювюкн
    PopEDX;
    OutCode("528B125285D2750A");
    OnError(6)
  йнмеж DupLoadCheck;

опнжедспю DupLoad*;
  мювюкн
    PopEDX;
    OutCode("528B12");
    PushEDX;
  йнмеж DupLoad;

опнжедспю CheckNIL*;
  мювюкн
    PopEDX;
    OutCode("85D2750A");
    OnError(6);
    PushEDX;
  йнмеж CheckNIL;

опнжедспю ExtArray*(A: TIDX; n, m: жекне);
  оепел i: жекне;
  мювюкн
    дкъ i := n - 1 дн 0 он -1 декюрэ
      PushConst(A[i])
    йнмеж;
    OutByte(54H);
    PushConst(n);
    PushConst(m);
    CallRTL(_arrayrot)
  йнмеж ExtArray;

опнжедспю ADR*(dim: жекне);
  мювюкн
    еякх dim > 0 рнцдю
      PopEDX;
      OutCode("83C4");
      OutByte(dim * 4);
      PushEDX
    йнмеж
  йнмеж ADR;

опнжедспю Len*(dim: жекне);
  мювюкн
    PopEDX;
    еякх dim < 0 рнцдю
      PushConst(-dim)
    юеякх dim > 1 рнцдю
      PopEDX;
      OutCode("83C4");
      OutByte((dim - 1) * 4);
      PushEDX
    йнмеж
  йнмеж Len;

опнжедспю For*(inc: аскебн; оеп LBeg, LEnd: жекне);
  мювюкн
    LEnd := NewLabel();
    LBeg := NewLabel();
    Label(LBeg);
    OutCode("8B14248B4424043910");
    еякх inc рнцдю
      jmp(JG, LEnd)
    хмюве
      jmp(JL, LEnd)
    йнмеж
  йнмеж For;

опнжедспю NextFor*(step, LBeg, LEnd: жекне);
  мювюкн
    OutCode("8B542404");
    еякх step = 1 рнцдю
      OutCode("FF02")
    юеякх step = -1 рнцдю
      OutCode("FF0A")
    хмюве
      IntByte("8302", "8102", step)
    йнмеж;
    jmp(JMP, LBeg);
    Label(LEnd);
    OutCode("83C408")
  йнмеж NextFor;

опнжедспю CaseLabel*(a, b, LBeg: жекне);
  оепел L: жекне;
  мювюкн
    L := NewLabel();
    IntByte("83FA", "81FA", a);
    еякх a = b рнцдю
      jmp(JNE, L)
    хмюве
      jmp(JL, L);
      IntByte("83FA", "81FA", b);
      jmp(JG, L)
    йнмеж;
    jmp(JMP, LBeg);
    Label(L)
  йнмеж CaseLabel;

опнжедспю Drop*;
  мювюкн
    PopEDX
  йнмеж Drop;

опнжедспю strcmp*(Op, LR: жекне);
  мювюкн
    бшанп Op хг
    |ЛйНМЯР.НОпЮБМН: PushConst(0)
    |ЛйНМЯР.НОмЕпЮБМН: PushConst(1)
    |ЛйНМЯР.НОлЕМЭЬЕ: PushConst(2)
    |ЛйНМЯР.НОаНКЭЬЕ: PushConst(3)
    |lxLE: PushConst(4)
    |lxGE: PushConst(5)
    хмюве
    йнмеж;
    бшанп LR хг
    |-1: CallRTL(_lstrcmp)
    | 0: CallRTL(_strcmp)
    | 1: CallRTL(_rstrcmp)
    хмюве
    йнмеж;
    PushEAX
  йнмеж strcmp;

опнжедспю Optimization;
  оепел
    cur: РСгБЕМНюЯЛ;
    flag: аскебн;
  мювюкн
    cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
    онйю cur # осярн декюрэ
      flag := кнфэ;
      бшанп cur.tcmd хг
      |PUSHEAX:
        flag := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ).tcmd = POPEAX
      |PUSHECX:
        flag := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ).tcmd = POPECX
      |PUSHEDX:
        flag := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ).tcmd = POPEDX
      хмюве
      йнмеж;
      еякх flag рнцдю
        cur.clen := 0;
        cur.tcmd := 0;
        cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ);
        cur.clen := 0;
        cur.tcmd := 0
      йнмеж;
      cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
    йнмеж
  йнмеж Optimization;

опнжедспю WriteKOS(FName: люяяхб хг кхр; stk, size, datasize, gsize: жекне; obj: аскебн);
   йнмяр
      strsize = 2048;
   оепел
      Header: РгЮЦНКНБНЙKol;
      F, i, filesize, filebuf, a, sec, adr, size2: жекне;
      cur: РСгБЕМНюЯЛ;
      Coff: РгЮЦНКНБНЙCoff;
      sym: люяяхб 18 * 4 хг кхр;
      FileName: ЛяРП.РяРПНЙЮ;
   мювюкн
      F := ЛтЮИК.яНГДЮРЭ(FName);
      еякх F <= 0 рнцдю
         Err(1)
      йнмеж;
      OutFilePos := ЛоЮЛ.оНКСВ(Align(size, 4) + datasize + 1000H);
      filebuf := OutFilePos;
      ЛоЮЛ.лЮКН(OutFilePos = 0);

      еякх ~obj рнцдю
         Header.menuet01 := "MENUET01";
         Header.ver := 1;
         Header.start := mSys.SIZE(РгЮЦНКНБНЙKol);
         Header.size := Align(size, 4) + datasize;
         Header.mem := Header.size + stk + gsize + strsize * 2 + 1000H;
         Header.sp := Header.size + gsize + stk;
         Header.param := Header.sp;
         Header.path := Header.param + strsize;

         Write(mSys.ADR(Header), mSys.SIZE(РгЮЦНКНБНЙKol));

         cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
         онйю cur # осярн декюрэ
            Write(mSys.ADR(Code[cur.ЙЛД]), cur.clen);
            cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
         йнмеж;
         Fill(Align(size, 4) - size, 0X);
         Write(mSys.ADR(Data), datasize);
         WriteF(F, filebuf, OutFilePos - filebuf)
      хмюве
         size2 := size;
         size := Align(size, 4) - mSys.SIZE(РгЮЦНКНБНЙKol);
         Coff.Machine := IntToCard16(014CH);
         Coff.NumberOfSections := IntToCard16(3);
         Coff.TimeDateStamp := ЛйНМЯР.ДЮРЮ;
         Coff.SizeOfOptionalHeader := IntToCard16(0);
         Coff.Characteristics := IntToCard16(0184H);

         Coff.text.ХЛЪ := ".flat";
         Coff.text.size := 0;
         Coff.text.adr := 0;
         Coff.text.sizealign := size;
         Coff.text.OAPfile := 8CH;
         Coff.text.reserved6 := size + datasize + 8CH;
         Coff.text.reserved7 := 0;
         Coff.text.attrflags := 40300020H;

         Coff.data.ХЛЪ := ".data";
         Coff.data.size := 0;
         Coff.data.adr := 0;
         Coff.data.sizealign := datasize;
         Coff.data.OAPfile := size + 8CH;
         Coff.data.reserved6 := 0;
         Coff.data.reserved7 := 0;
         Coff.data.reserved8 := 0;
         Coff.data.attrflags := 0C0300040H;

         Coff.bss.ХЛЪ := ".bss";
         Coff.bss.size := 0;
         Coff.bss.adr := 0;
         Coff.bss.sizealign := gsize;
         Coff.bss.OAPfile := 0;
         Coff.bss.reserved6 := 0;
         Coff.bss.reserved7 := 0;
         Coff.bss.reserved8 := 0;
         Coff.bss.attrflags := 0C03000C0H;

         size := Align(size2, 4);
         rcount := 0;
         cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
         онйю cur # осярн декюрэ
            еякх cur.tcmd IN {OCMD, GCMD} рнцдю
               mSys.GET(mSys.ADR(Code[cur.ЙЛД]), a);
               еякх a < size рнцдю
                  a := a - mSys.SIZE(РгЮЦНКНБНЙKol);
                  sec := 1
               юеякх a < size + datasize рнцдю
                  a := a - size;
                  sec := 2
               хмюве
                  a := a - size - datasize;
                  sec := 3
               йнмеж;
               mSys.PUT(mSys.ADR(Code[cur.ЙЛД]), a);
               mSys.PUT(mSys.ADR(Reloc[rcount]), cur.ЮДП.ЮДПЕЯ - mSys.SIZE(РгЮЦНКНБНЙKol));
               дна(rcount, 4);
               mSys.PUT(mSys.ADR(Reloc[rcount]), sec);
               дна(rcount, 4);
               mSys.PUT(mSys.ADR(Reloc[rcount]), 06X); дна(rcount);
               mSys.PUT(mSys.ADR(Reloc[rcount]), 00X); дна(rcount);
            йнмеж;
            Write(mSys.ADR(Code[cur.ЙЛД]), cur.clen);
            cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
         йнмеж;
         size := size2;
         Fill(Align(size, 4) - size2, 0X);
         Write(mSys.ADR(Data), datasize);
         Coff.text.reserved8 := rcount дек 10;
         Coff.PointerToSymbolTable := Coff.text.reserved6 + rcount;
         Coff.NumberOfSymbols := 4;

         WriteF(F, mSys.ADR(Coff), mSys.SIZE(РгЮЦНКНБНЙCoff));
         WriteF(F, filebuf, OutFilePos - filebuf);
         WriteF(F, mSys.ADR(Reloc), rcount);

         adr := mSys.ADR(sym);
         InitArray(adr, "4558504F52545300000000000100000002002E666C617400000000000000010000000300");
         InitArray(adr, "2E64617461000000000000000200000003002E6273730000000000000000030000000300");
         mSys.PUT(mSys.ADR(sym) + 8, Labels[Exports] - mSys.SIZE(РгЮЦНКНБНЙKol));

         WriteF(F, mSys.ADR(sym), LEN(sym));
         i := 4;
         WriteF(F, mSys.ADR(i), 4)
      йнмеж;
      ЛтЮИК.гЮЙПШРЭ(F)
   йнмеж WriteKOS;

опнжедспю WriteELF(FName: люяяхб хг кхр; code, data, glob: жекне);
  оепел
    F, res, delta, filebuf: жекне;
    cur: РСгБЕМНюЯЛ;
    bytes: люяяхб 817H + 55FH + 4900 хг кхр;
    опнжедспю Add(offset: жекне);
    оепел m: жекне;
    мювюкн
      mSys.GET(mSys.ADR(bytes[offset]), m);
      mSys.PUT(mSys.ADR(bytes[offset]), m + delta)
    йнмеж Add;

    опнжедспю Sub(offset: жекне);
    оепел m: жекне;
    мювюкн
      mSys.GET(mSys.ADR(bytes[offset]), m);
      mSys.PUT(mSys.ADR(bytes[offset]), m - delta)
    йнмеж Sub;

  мювюкн
    F := ЛтЮИК.нРЙПШРЭ(felf, 0);
    еякх F = 0 рнцдю
      Err(3)
    йнмеж;
    еякх ЛтЮИК.вХРЮРЭ(F, mSys.ADR(bytes), 817H + 55FH + 4900) # 817H + 55FH + 4900 рнцдю
      Err(4)
    йнмеж;
    ЛтЮИК.гЮЙПШРЭ(F);
    bytes[0] := 7FX;

    бшв(code, 13);

    delta := Align(data, 1000H) - 100000H;
    Add(0020H); Add(00A4H); Add(00A8H); Add(0258H); Add(02B8H); Add(0308H); Add(0494H); Add(049CH);
    Add(04A4H); Add(0679H); Add(0681H); Add(06A4H); Add(06B0H); Add(06BAH); Add(0703H); Add(0762H);
    Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(17C5H); Add(17E5H); Add(17E9H); Add(1811H);
    Add(1839H); Add(1861H); Add(1889H); Add(1A25H); Add(1A95H); Add(1AA5H); Add(1C05H); Add(1C55H);
    Add(1CE5H); Add(1D09H); Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H);

    delta := Align(glob, 1000H) - 3200000H;
    Add(00A8H); Add(17EDH); Add(1C09H); Add(1D25H);

    delta := Align(code, 1000H) - 100000H;
    Add(0020H); Add(0084H); Add(0088H); Add(0098H); Add(009CH); Add(00A0H); Add(00B8H); Add(00BCH);
    Add(00C0H); Add(0118H); Add(011CH); Add(0120H); Add(0258H); Add(0278H); Add(02B8H); Add(0308H);
    Add(048CH); Add(0494H); Add(049CH); Add(04A4H); Add(04ACH); Add(04B4H); Add(04BCH); Add(04C4H);
    Add(04CCH); Add(04D4H); Add(04DCH); Add(04E4H); Add(04ECH); Add(04F4H); Add(04FCH); Add(0504H);
    Add(050CH); Add(0514H); Add(052BH); Add(0544H); Add(054EH); Add(0554H); Add(055EH); Add(056EH);
    Add(057EH); Add(058EH); Add(059EH); Add(05AEH); Add(05BEH); Add(05CEH); Add(05DEH); Add(05EEH);
    Add(05FEH); Add(060EH); Add(061EH); Add(062EH); Add(064CH); Add(0651H); Add(0679H); Add(0681H);
    Add(0686H); Add(068CH); Add(06A4H); Add(06ABH); Add(06B0H); Add(06BAH); Add(06D7H); Add(06EBH);
    Add(0703H); Add(0762H); Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(0828H); Add(082DH);
    Sub(0845H); Sub(087BH); Add(08DEH); Add(08E8H); Sub(0916H); Add(0C52H); Add(0C8AH); Add(0D0AH);
    Add(1635H); Add(1655H); Add(1659H); Add(167DH); Add(1681H); Add(16A5H); Add(16A9H); Add(16CDH);
    Add(16D1H); Add(16F5H); Add(16F9H); Add(171DH); Add(1721H); Add(1745H); Add(1749H); Add(176DH);
    Add(1771H); Add(1795H); Add(1799H); Add(17BDH); Add(17C1H); Add(17E5H); Add(17E9H); Add(1811H);
    Add(1839H); Add(1861H); Add(1889H); Add(1985H); Add(1995H); Add(19A5H); Add(19B5H); Add(19C5H);
    Add(19D5H); Add(19E5H); Add(19F5H); Add(1A05H); Add(1A15H); Add(1A25H); Add(1A55H); Add(1A65H);
    Add(1A75H); Add(1A95H); Add(1AA5H); Add(1AD5H); Add(1AE5H); Add(1AF5H); Add(1B05H); Add(1B25H);
    Add(1B35H); Add(1B45H); Add(1B55H); Add(1B65H); Add(1B75H); Add(1BB5H); Add(1BC5H); Add(1BE5H);
    Add(1C05H); Add(1C15H); Add(1C55H); Add(1C75H); Add(1CA5H); Add(1CB5H); Add(1CE5H); Add(1D05H);
    Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H); Add(1D75H); Add(1D89H);

    OutFilePos := ЛоЮЛ.оНКСВ(code + data + 8000H);
    filebuf := OutFilePos;
    ЛоЮЛ.лЮКН(OutFilePos = 0);

    Write(mSys.ADR(bytes), 817H);
    Fill(2DDH, 90X);
    cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
    онйю cur # осярн декюрэ
      Write(mSys.ADR(Code[cur.ЙЛД]), cur.clen);
      cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
    йнмеж;
    Fill(Align(code, 1000H) - code, 90X);
    Write(mSys.ADR(bytes[817H]), 55FH);
    Write(mSys.ADR(Data), data);
    Fill(Align(data, 1000H) - data, 0X);
    Write(mSys.ADR(bytes[817H + 55FH + 55FH]), 0DC5H);

    F := ЛтЮИК.яНГДЮРЭ(FName);
    еякх F <= 0 рнцдю
      Err(1)
    йнмеж;
    WriteF(F, filebuf, OutFilePos - filebuf);
    ЛтЮИК.гЮЙПШРЭ(F)
  йнмеж WriteELF;

опнжедспю FixLabels(FName: люяяхб хг кхр; stk, gsize, glob: жекне);
   оепел
      size, asize, i, rdatasize, RCount, n, temp, temp2, temp3: жекне;
      cur: РСгБЕМНюЯЛ;
      R: РпЕКНЙ;
      c: кхр;
   мювюкн
      dcount := Align(dcount, 4);
      еякх dll рнцдю
         LoadAdr := 10000000H;
         PackExport(ExecName)
      юеякх con хкх gui рнцдю
         LoadAdr := 400000H
      юеякх kos хкх obj рнцдю
         LoadAdr := mSys.SIZE(РгЮЦНКНБНЙKol)
      юеякх elf рнцдю
         LoadAdr := 134514420 + 1024;
         дна(gsize, 1024)
      йнмеж;

      еякх dll хкх con хкх gui рнцдю
         rdatasize := 0DAH + etable.size;
         size := 1000H + LoadAdr;
      юеякх kos хкх elf хкх obj рнцдю
         rdatasize := 0;
         size := LoadAdr
      йнмеж;

      Optimization;
      temp2 := size;
      cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
      онйю cur # осярн декюрэ
         cur.ЮДП.ЮДПЕЯ := size;
         еякх cur.tcmd = LCMD рнцдю
            mSys.PUT(cur.ОЕПЕЛ.ЮДПЕЯ, size)
         йнмеж;
         size := size + cur.clen;
         cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
      йнмеж;

      size := temp2;
      cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);
      онйю cur # осярн декюрэ
         cur.ЮДП.ЮДПЕЯ := size;
         еякх cur.tcmd = LCMD рнцдю
            mSys.PUT(cur.ОЕПЕЛ.ЮДПЕЯ, size)
         юеякх (cur.tcmd = JCMD) & cur.АйНПНРЙНЕ рнцдю
            mSys.GET(cur.ОЕПЕЛ.ЮДПЕЯ, i);
            temp3 := i - cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ).ЮДП.ЮДПЕЯ;
            еякх (-131 <= temp3) & (temp3 <= 123) рнцдю
               mSys.GET(cur(РСгБЕМНюЯЛ).ЙНД.ЮДПЕЯ - 1, c);
               еякх c = JMP рнцдю
                  mSys.PUT(cur(РСгБЕМНюЯЛ).ЙНД.ЮДПЕЯ - 1, 0EBX)
               хмюве (*JE, JNE, JLE, JGE, JG, JL*)
                  mSys.PUT(cur(РСгБЕМНюЯЛ).ЙНД.ЮДПЕЯ - 2, мкхр(c) - 16);
                  mSys.PUT(cur(РСгБЕМНюЯЛ).ЙНД.ЮДПЕЯ - 1, temp3);
                  бшв(cur(РСгБЕМНюЯЛ).ЙНД.ЮДПЕЯ)
               йнмеж;
               cur.clen := 2
            йнмеж
         йнмеж;
         size := size + cur.clen;
         cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
      йнмеж;

      еякх dll хкх con хкх gui рнцдю
         asize := Align(size, 1000H)
      юеякх kos хкх obj рнцдю
         asize := Align(size, 4)
      юеякх elf рнцдю
         asize := 134514420 + 6508 + Align(size - 13 - LoadAdr, 1000H)
      йнмеж;

      дкъ i := 0 дн Lcount декюрэ
         еякх Labels[i] < 0 рнцдю
            Labels[i] := -Labels[i] + asize + Align(rdatasize, 1000H)
         йнмеж
      йнмеж;

      temp := dcount;
      еякх elf рнцдю
         asize := asize + Align(dcount, 1000H) + 64 + 1024;
         mSys.PUT(mSys.ADR(Code[glob + 1]), asize - 1024);
         dcount := 0
      йнмеж;

      еякх dll рнцдю
         asize := asize - LoadAdr + 0DAH;
         дкъ i := 0 дн etable.namecount - 1 декюрэ
            etable.arradr[i] := Labels[etable.arradr[i]] - LoadAdr;
            etable.arrnameptr[i] := etable.arrnameptr[i] + asize
         йнмеж;
         etable.arradroffset := etable.arradroffset + asize;
         etable.arrnameptroffset := etable.arrnameptroffset + asize;
         etable.arrnumoffset := etable.arrnumoffset + asize;
         etable.dllnameoffset := etable.dllnameoffset + asize;
         asize := asize + LoadAdr - 0DAH
      йнмеж;
      еякх dll хкх con хкх gui рнцдю
         Labels[LoadLibrary] := asize + 4;
         Labels[GetProcAddress] := asize;
         R.ЯРПЮМХЖЮ := 0;
         R.Size := 0;
         RCount := 0;
      йнмеж;
      cur := asmlist.ОПЕДШДСЫ(РСгБЕМНюЯЛ);

      дкъ i := 0 дн LEN(RtlProc) - 1 декюрэ
         RtlProc[i] := Labels[RtlProc[i]]
      йнмеж;

      temp3 := asize + Align(rdatasize, 1000H) + dcount;
      онйю cur # осярн декюрэ
         бшанп cur.tcmd хг
            |JCMD:
               mSys.GET(cur.ОЕПЕЛ.ЮДПЕЯ, i);
               mSys.PUT(cur.ЙНД.ЮДПЕЯ, i - cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ).ЮДП.ЮДПЕЯ)
            |GCMD:
               mSys.GET(cur.ЙНД.ЮДПЕЯ, i);
               mSys.PUT(cur.ЙНД.ЮДПЕЯ, i + temp3)
            |OCMD:
               mSys.MOVE(cur.ОЕПЕЛ.ЮДПЕЯ, cur.ЙНД.ЮДПЕЯ, 4)
         хмюве
         йнмеж;
         еякх dll & (cur.tcmd IN {GCMD, OCMD}) рнцдю
            n := cur.ЮДП.ЮДПЕЯ - LoadAdr;
            еякх гяо(n, 12) = гяо(R.ЯРПЮМХЖЮ, 12) рнцдю
               R.reloc[RCount] := IntToCard16(n няр 1000H + 3000H);
               дна(RCount);
               дна(R.Size, 2)
            хмюве
               еякх R.Size # 0 рнцдю
                  PutReloc(R)
               йнмеж;
               R.ЯРПЮМХЖЮ := гяо(n, 12) * 1000H;
               R.Size := 10;
               R.reloc[0] := IntToCard16(n няр 1000H + 3000H);
               RCount := 1
            йнмеж
         йнмеж;
         cur := cur.ЯКЕДСЧЫ(РСгБЕМНюЯЛ)
      йнмеж;
      еякх R.Size # 0 рнцдю
         PutReloc(R)
      йнмеж;
      еякх dll хкх con хкх gui рнцдю
         WritePE(FName, stk, size - 1000H - LoadAdr, dcount, rdatasize, gsize)
      юеякх kos хкх obj рнцдю
         WriteKOS(FName, Align(stk, 4), size, dcount, gsize, obj)
      юеякх elf рнцдю
         WriteELF(FName, size - LoadAdr, temp, gsize)
      йнмеж
   йнмеж FixLabels;

опнжедспю OutStringZ(str: люяяхб хг кхр);
   оепел
      i: жекне;
   мювюкн
      New;
      current.clen := LENGTH(str);
      дкъ i := 0 дн current.clen - 1 декюрэ
         Code[ccount] := str[i];
         дна(ccount)
      йнмеж;
      Code[ccount] := 0X;
      дна(ccount);
      дна(current.clen)
   йнмеж OutStringZ;

опнжедспю щОХКНЦ*(gsize: жекне; FName: люяяхб хг кхр; stk: жекне);
   оепел
      i, glob: жекне;
   мювюкн
      glob := 0;
      gsize := Align(gsize, 4) + 4;
      йнохъ(FName, OutFile);
      Labels[RTABLE] := -dcount;
      dataint(recarray[0]);
      дкъ i := 1 дн reccount декюрэ
         dataint(recarray[i])
      йнмеж;
      current := start;
      еякх con хкх gui хкх dll рнцдю
         PushInt(LoadLibrary);
         PushInt(GetProcAddress);
         OutCode("5859FF31FF3054")
      юеякх elf рнцдю
         OutCode("6800000000");
         glob := current.ЙЛД;
      юеякх kos хкх obj рнцдю
         OutByte(54H)
      йнмеж;
      GlobalAdr(0);
      PushConst(гяо(gsize, 2));
      PushInt(RTABLE);
      PushInt(SELFNAME);
      CallRTL(_init);
      current := asmlist.ЯКЕДСЧЫ(РСгБЕМНюЯЛ);
      еякх dll рнцдю
         OutCode("B801000000C9C20C00")
      йнмеж;
      еякх obj рнцдю
         OutCode("B801000000C9C20400")
      йнмеж;
      OutCode("EB05");
      Label(ASSRT);
      CallRTL(_assrt);
      OutCode("EB09");
      Label(HALT);
      OutCode("6A006A00");
      CallRTL(_assrt);
      OutCode("6A00");
      CallRTL(_halt);
      OutByte(90H);
      еякх obj рнцдю
         Label(Exports);
         CmdN(szSTART); CmdN(START);
         CmdN(szversion); OutInt(stk);
         дкъ i := 0 дн kosexpcount - 1 декюрэ
            CmdN(kosexp[i].NameLabel); CmdN(kosexp[i].Adr)
         йнмеж;
         OutInt(0);
         Label(szSTART); OutStringZ("START");
         Label(szversion); OutStringZ("version");
         дкъ i := 0 дн kosexpcount - 1 декюрэ
            Label(kosexp[i].NameLabel);
            OutStringZ(kosexp[i].СгБЕМНяСЫ.ЯРПхЛЪ)
         йнмеж
      йнмеж;
      FixLabels(FName, stk, gsize, glob)
   йнмеж щОХКНЦ;

йнмеж ЛНДюЯЛ86_32.
