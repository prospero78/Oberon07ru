(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
  *)

лндскэ ЛНДюЯЛ86_32;

хлонпр ЛсРХКЭ := ЛНДсРХКЭ,
    mSys := SYSTEM,
    ЛяЙЮМ := ЛНДяЙЮМЕП,
    ЛрХОШ := ЛНДрХОШ,
    ЛтЮИК := ЛНДтЮИК,
    ЛйНМЯР := ЛНДйНМЯРЮМРШ,
    ЛйНМЯ := ЛНДйНМЯНКЭ,
    ЛнЬ := ЛНДнЬХАЙХ,
    ЛоПНЖ := ЛНДоПНЖЕЯЯ,
    ЛоЮЛ := ЛНДоЮЛЪРЭ,
    ЛяОХЯ := ЛНДяОХЯНЙ,
    ЛяРП := ЛНДяРПНЙХ;

йнмяр

  ADIM* = 5;

  lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54;
  lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7;
  TNIL = 8; TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  stABS* = 1; stODD* = 2; stLEN* = 3; stLSL* = 4; stASR* = 5; stROR* = 6; stFLOOR* = 7;
  stFLT* = 8; stORD* = 9; stCHR* = 10; stLONG* = 11; stSHORT* = 12; stINC* = 13;
  stDEC* = 14; stINCL* = 15; stEXCL* = 16; stCOPY* = 17; stNEW* = 18; stASSERT* = 19;
  stPACK* = 20; stUNPK* = 21; stDISPOSE* = 22; stFABS* = 23; stINC1* = 24;
  stDEC1* = 25; stASSERT1* = 26; stUNPK1* = 27; stPACK1* = 28; stLSR* = 29;
  stLENGTH* = 30;

  sysBIT* = 103; sysMOVE* = 108;

  JMP* = 0E9X; CALL = 0E8X;
  JE = 84X; JNE = 85X; JLE = 8EX; JGE = 8DX; JG = 8FX; JL = 8CX;

  JCMD = 1; LCMD = 2; GCMD = 3; OCMD = 4; ECMD = 5;
  PUSHEAX = 6; PUSHECX = 7; PUSHEDX = 8; POPEAX = 9; POPECX = 10; POPEDX = 11;
  ICMP1 = 13; ICMP2 = 14;

  defcall = 0; stdcall = 1; cdecl = 2; winapi = 3;

  _rset* = 0; _inset* = 1; _saverec* = 2; _length* = 3; _checktype* = 4; _strcmp* = 5;
  _lstrcmp* = 6; _rstrcmp* = 7; _savearr* = 8; _newrec* = 9; _disprec* = 10; _arrayidx* = 11;
  _arrayrot* = 12; _assrt* = 13; _strcopy* = 14; _arrayidx1* = 15; _init* = 16; _close* = 17; _halt* = 18;
  ASSRT = 19; hInstance = 20; SELFNAME = 21; RTABLE = 22;LoadLibrary = 23; GetProcAddress = 24;
  Exports = 25; szSTART = 26; START = 27; szversion = 28; HALT = 29;

  FREGS = 8;

рхош

  РоПНЖЕДСПЮ = опнжедспю (err: аскебн);

  РСоСМЙРюЯЛ* = сйюгюрекэ мю гюохяэ (ЛрХОШ.РоСМЙР)
      cmd, clen, varadr, adr, tcmd, codeadr: жекне; short: аскебн
    йнмеж;

  TFLT = люяяхб 2 хг жекне;

  TIDX* = люяяхб ADIM хг жекне;

  РяЕЙЖХЪхЛЪ = люяяхб 8 хг яхлб;

  РяЕЙЖХЪ = гюохяэ
      name: РяЕЙЖХЪхЛЪ;
      size, adr, sizealign, OAPfile, reserved6, reserved7, reserved8, attrflags: жекне
    йнмеж;

  РгЮЦНКНБНЙ = гюохяэ
      msdos: люяяхб 180 хг яхлб;
      typecomp, seccount: mSys.CARD16;
      time, reserved1, reserved2: жекне;
      PEoptsize, infflags, PEfile, compver: mSys.CARD16;
      codesize, datasize, initdatasize, startadr,
      codeadr, rdataadr, loadadr, secalign, filealign,
      oldestver, version, oldestverNT, reserved3,
      filesize, headersize, dllcrc: жекне;
      UI, reserved4: mSys.CARD16;
      stksize, stkalloc, heapsize, heapalloc, reserved5, structcount: жекне;
      structs: люяяхб 16 хг гюохяэ adr, size: жекне йнмеж;
      sections: люяяхб 3 хг РяЕЙЖХЪ
    йнмеж;

  РгЮЦНКНБНЙCoff = гюохяэ
      Machine: mSys.CARD16;
      NumberOfSections: mSys.CARD16;
      TimeDateStamp,
      PointerToSymbolTable,
      NumberOfSymbols: жекне;
      SizeOfOptionalHeader,
      Characteristics: mSys.CARD16;
      text, data, bss: РяЕЙЖХЪ
    йнмеж;

  РгЮЦНКНБНЙKol = гюохяэ
      menuet01: люяяхб 8 хг яхлб;
      ver, start, size, mem, sp, param, path: жекне
    йнмеж;

  ETABLE = гюохяэ
      reserved1, time, reserved2, dllnameoffset, firstnum, adrcount,
      namecount, arradroffset, arrnameptroffset, arrnumoffset: жекне;
      arradr, arrnameptr: люяяхб 10000H хг жекне;
      arrnum: люяяхб 10000H хг mSys.CARD16;
      text: люяяхб 1000000 хг яхлб;
      textlen, size: жекне
    йнмеж;

  РпЕКНЙ = гюохяэ
      Page, Size: жекне;
      reloc: люяяхб 1024 хг mSys.CARD16
    йнмеж;

оепел
  asmlist: ЛрХОШ.РСяОХЯНЙ;
  start: РСоСМЙРюЯЛ;
  MemErr: РоПНЖЕДСПЮ;
  dll, con, gui, kos, elf, obj: аскебн;
  Lcount, reccount, topstk: жекне;
  recarray: люяяхб 2048 хг жекне;
  current*: РСоСМЙРюЯЛ;
  callstk: люяяхб 1024, 2 хг РСоСМЙРюЯЛ;
  OutFile: ЛяРП.РяРПНЙЮ;
  Code: люяяхб 4000000 хг яхлб; ccount: жекне; Data: люяяхб 1000000 хг яхлб; dcount: жекне;
  Labels: люяяхб 200000 хг жекне;
  rdata: люяяхб 400H хг жекне;
  Header: РгЮЦНКНБНЙ;
  etable: ETABLE;
  ExecName: ЛяРП.РяРПНЙЮ;
  LoadAdr: жекне; Reloc: люяяхб 200000 хг яхлб; rcount: жекне;
  RtlProc: люяяхб 20 хг жекне; OutFilePos: жекне;
  RelocSection: РяЕЙЖХЪ;
  felf: ЛяРП.РяРПНЙЮ;
  fpu*: жекне;
  isfpu: аскебн;
  maxfpu: жекне;
  fpucmd: РСоСМЙРюЯЛ;
  kosexp: люяяхб 65536 хг гюохяэ
    Name: ЛрХОШ.РСсГЕК;
    Adr, NameLabel: жекне
  йнмеж;
  kosexpcount: жекне;

опнжедспю setfelf*(name: ЛяРП.РяРПНЙЮ);
  мювюкн
    felf := name
  йнмеж setfelf;

опнжедспю AddRtlProc*(idx, proc: жекне);
  мювюкн
    RtlProc[idx] := proc
  йнмеж AddRtlProc;

опнжедспю IntToCard16(i: жекне): mSys.CARD16;
  оепел w: mSys.CARD16;
  мювюкн
    mSys.GET(mSys.ADR(i), w)
    бепмсрэ w
  йнмеж IntToCard16;

опнжедспю CopyStr(оеп Dest: люяяхб хг яхлб; Source: люяяхб хг яхлб; оеп di: жекне; si: жекне);
  мювюкн
    бшв(di);
    онбрнпърэ
      дна(di);
      Dest[di] := Source[si];
      дна(si)
    онйюме Dest[di] = 0X
  йнмеж CopyStr;

опнжедспю exch(оеп a, b: жекне);
  оепел c: жекне;
  мювюкн
    c := a;
    a := b;
    b := c
  йнмеж exch;

опнжедспю Sort(оеп NamePtr, Adr: люяяхб хг жекне; Text: люяяхб хг яхлб; LB, RB: жекне);
  оепел L, R: жекне;

      опнжедспю strle(s1, s2: жекне): аскебн;
      оепел S1, S2: люяяхб 256 хг яхлб; i: жекне;
      мювюкн
        i := 0;
        CopyStr(S1, Text, i, s1);
        i := 0;
        CopyStr(S2, Text, i, s2)
        бепмсрэ S1 <= S2
      йнмеж strle;

  мювюкн
    еякх LB < RB рнцдю
      L := LB;
      R := RB;
      онбрнпърэ
        онйю (L < RB) & strle(NamePtr[L], NamePtr[LB]) декюрэ
          дна(L)
        йнмеж;
        онйю (R > LB) & strle(NamePtr[LB], NamePtr[R]) декюрэ
          бшв(R)
        йнмеж;
        еякх L < R рнцдю
          exch(NamePtr[L], NamePtr[R]);
          exch(Adr[L], Adr[R])
        йнмеж
      онйюме L >= R;
      еякх R > LB рнцдю
        exch(NamePtr[LB], NamePtr[R]);
        exch(Adr[LB], Adr[R]);
        Sort(NamePtr, Adr, Text, LB, R - 1)
      йнмеж;
      Sort(NamePtr, Adr, Text, R + 1, RB)
    йнмеж
  йнмеж Sort;

опнжедспю PackExport(Name: люяяхб хг яхлб);
  оепел i: жекне;
  мювюкн
    Sort(etable.arrnameptr, etable.arradr, etable.text, 0, etable.namecount - 1);
    дкъ i := 0 дн etable.namecount - 1 декюрэ
      etable.arrnum[i] := IntToCard16(i)
    йнмеж;
    etable.size := 40 + etable.adrcount * 4 + etable.namecount * 6;
    etable.arradroffset := 40;
    etable.arrnameptroffset := 40 + etable.adrcount * 4;
    etable.arrnumoffset := etable.arrnameptroffset + etable.namecount * 4;
    etable.dllnameoffset := etable.size + etable.textlen;
    CopyStr(etable.text, Name, etable.textlen, 0);
    дна(etable.textlen);
    дкъ i := 0 дн etable.namecount - 1 декюрэ
      etable.arrnameptr[i] := etable.arrnameptr[i] + etable.size
    йнмеж;
    etable.size := etable.size + etable.textlen
  йнмеж PackExport;

опнжедспю ProcExport*(Number: жекне; Name: ЛрХОШ.РСсГЕК; NameLabel: жекне);
  мювюкн
    еякх dll рнцдю
      etable.arradr[etable.adrcount] := Number;
      дна(etable.adrcount);
      etable.arrnameptr[etable.namecount] := etable.textlen;
      дна(etable.namecount);
      CopyStr(etable.text, Name.ХЛЪ, etable.textlen, 0);
      дна(etable.textlen)
    юеякх obj рнцдю
      kosexp[kosexpcount].Name := Name;
      kosexp[kosexpcount].Adr := Number;
      kosexp[kosexpcount].NameLabel := NameLabel;
      дна(kosexpcount)
    йнмеж
  йнмеж ProcExport;

опнжедспю Err(code: жекне);
  мювюкн
    бшанп code хг
    |1: ЛнЬ.яННАЫ(67); ЛйНМЯ.яРПНЙЮ_оЕВЮРЭ(OutFile)
    |2: ЛнЬ.яННАЫ(69); ЛйНМЯ.яРПНЙЮ_оЕВЮРЭ(OutFile)
    |3: ЛнЬ.яННАЫ(58)
    |4: ЛнЬ.яННАЫ(88)
    хмюве
    йнмеж;
    ЛйНМЯ.мНБяРП;
    ЛоПНЖ.гЮЙНМВХРЭ(1)
  йнмеж Err;

опнжедспю Align*(n, m: жекне): жекне;
    бепмсрэ n + (m - n MOD m) MOD m
  йнмеж Align;

опнжедспю PutReloc(R: РпЕКНЙ);
  оепел i: жекне;
  мювюкн
    mSys.PUT(mSys.ADR(Reloc[rcount]), R.Page);
    дна(rcount, 4);
    mSys.PUT(mSys.ADR(Reloc[rcount]), R.Size);
    дна(rcount, 4);
    дкъ i := 0 дн ASR(R.Size - 8, 1) - 1 декюрэ
      mSys.PUT(mSys.ADR(Reloc[rcount]), R.reloc[i]);
      дна(rcount, 2)
    йнмеж
  йнмеж PutReloc;

опнжедспю InitArray(оеп adr: жекне; chars: ЛяРП.РяРПНЙЮ);
  оепел i, x, n: жекне;
  мювюкн
    n := LEN(chars) - 1;
    i := 0;
    онйю (i < n) & (chars[i] # 0X) декюрэ
      x := ЛяЙЮМ.вХЯКН16_Б_жЕКНЕ(chars[i]) * 16 + ЛяЙЮМ.вХЯКН16_Б_жЕКНЕ(chars[i + 1]);
      mSys.PUT(adr, CHR(x));
      дна(adr);
      дна(i, 2)
    йнмеж
  йнмеж InitArray;

опнжедспю WriteF(F, A, N: жекне);
  мювюкн
    еякх ЛтЮИК.гЮОХЯЮРЭ(F, A, N) # N рнцдю
      Err(2)
    йнмеж
  йнмеж WriteF;

опнжедспю Write(A, N: жекне);
  мювюкн
    mSys.MOVE(A, OutFilePos, N);
    OutFilePos := OutFilePos + N
  йнмеж Write;

опнжедспю Fill(n: жекне; c: яхлб);
  оепел i: жекне;
  мювюкн
    дкъ i := 1 дн n декюрэ
      Write(mSys.ADR(c), 1)
    йнмеж
  йнмеж Fill;

опнжедспю SetSection(оеп Section: РяЕЙЖХЪ; name: РяЕЙЖХЪхЛЪ; size, adr, sizealign, OAPfile, attrflags: жекне);
  мювюкн
    Section.name := name;
    Section.size := size;
    Section.adr := adr;
    Section.sizealign := sizealign;
    Section.OAPfile := OAPfile;
    Section.attrflags := attrflags;
  йнмеж SetSection;

опнжедспю WritePE(FName: люяяхб хг яхлб; stksize, codesize, datasize, rdatasize, gsize: жекне);
  CONST textattr = 60000020H; rdataattr = 40000040H; dataattr = 0C0000040H; relocattr = 42000040H;
  оепел i, F, adr, acodesize, compver, version, stkalloc, heapsize, heapalloc, filesize, filebuf: жекне;
      cur: РСоСМЙРюЯЛ;
  мювюкн

    compver := 0;
    version := 0;
    stkalloc := stksize;
    heapsize := 100000H;
    heapalloc := 100000H;
    acodesize := Align(codesize, 1000H) + 1000H;
    adr := mSys.ADR(rdata);
    filesize := acodesize + Align(rdatasize, 1000H) + Align(datasize, 1000H) + Align(rcount, 1000H);

    InitArray(adr, "5000000040000000000000003400000000000000000000006200000000000000");
    InitArray(adr, "0000000000000000000000000000000000000000500000004000000000000000");
    InitArray(adr, "A4014C6F61644C6962726172794100001F0147657450726F6341646472657373");
    InitArray(adr, "00006B65726E656C33322E646C6C0000");

    rdata[ 0] := acodesize + 50H;
    rdata[ 1] := acodesize + 40H;
    rdata[ 3] := acodesize + 34H;
    rdata[ 6] := acodesize + 62H;
    rdata[ 7] := acodesize;
    rdata[13] := acodesize + 50H;
    rdata[14] := acodesize + 40H;

    adr := mSys.ADR(Header.msdos);
    InitArray(adr, "4D5A90000300000004000000FFFF0000B8000000000000004000000000000000");
    InitArray(adr, "00000000000000000000000000000000000000000000000000000000B0000000");
    InitArray(adr, "0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F");
    InitArray(adr, "742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000");
    InitArray(adr, "5DCF9F8719AEF1D419AEF1D419AEF1D497B1E2D413AEF1D4E58EE3D418AEF1D4");
    InitArray(adr, "5269636819AEF1D4000000000000000050450000");
    Header.typecomp := IntToCard16(014CH);
    еякх dll рнцдю
      Header.seccount := IntToCard16(0004H);
      Header.infflags := IntToCard16(210EH)
    хмюве
      Header.seccount := IntToCard16(0003H);
      Header.infflags := IntToCard16(010FH)
    йнмеж;
    Header.time := ЛйНМЯР.ДЮРЮ;
    Header.PEoptsize := IntToCard16(00E0H);
    Header.PEfile := IntToCard16(010BH);
    Header.compver := IntToCard16(compver);
    Header.codesize := Align(codesize, 200H);
    Header.datasize := Align(datasize + gsize, 200H) + Align(rdatasize, 200H) + Align(rcount, 200H);
    Header.startadr := 1000H;
    Header.codeadr := 1000H;
    Header.rdataadr := Header.codeadr + Align(codesize, 1000H);
    Header.loadadr := LoadAdr;
    Header.secalign := 1000H;
    Header.filealign := 0200H;
    Header.oldestver := 0004H;
    Header.version := version;
    Header.oldestverNT := 0004H;
    Header.filesize := Align(codesize, 1000H) + Align(datasize + gsize, 1000H) + Align(rdatasize, 1000H) + Align(rcount, 1000H) + 1000H;
    Header.headersize := 0400H;
    Header.UI := IntToCard16(ORD(con) + 2);
    Header.stksize := stksize;
    Header.stkalloc := stkalloc;
    Header.heapsize := heapsize;
    Header.heapalloc := heapalloc;
    Header.structcount := 10H;
    еякх dll рнцдю
      Header.structs[0].adr := Header.rdataadr + 0DAH;
      Header.structs[0].size := etable.size
    йнмеж;

    Header.structs[1].adr := Header.rdataadr + 0CH;
    Header.structs[1].size := 28H;
    Header.structs[12].adr := Header.rdataadr;
    Header.structs[12].size := 0CH;

    SetSection(Header.sections[0], ".text", codesize, 1000H, Align(codesize, 200H), 400H, textattr);
    SetSection(Header.sections[1], ".rdata", rdatasize, Align(codesize, 1000H) + 1000H, Align(rdatasize, 200H),
      Align(codesize, 200H) + 400H, rdataattr);
    SetSection(Header.sections[2], ".data", datasize + gsize, Align(codesize, 1000H) + Align(rdatasize, 1000H) + 1000H,
      Align(datasize, 200H), Align(codesize, 200H) + Align(rdatasize, 200H) + 400H, dataattr);

    еякх dll рнцдю
      SetSection(RelocSection, ".reloc", rcount, Header.sections[2].adr + Align(datasize + gsize, 1000H), Align(rcount, 200H),
        Header.sections[2].OAPfile + Align(datasize, 200H), relocattr);
      Header.structs[5].adr := RelocSection.adr;
      Header.structs[5].size := rcount
    йнмеж;

    F := ЛтЮИК.яНГДЮРЭ(FName);
    еякх F = 0 рнцдю
      Err(1)
    йнмеж;
    OutFilePos := ЛоЮЛ.оНКСВ(filesize);
    filebuf := OutFilePos;
    ЛоЮЛ.нЬХАЙЮ(OutFilePos = 0);

    Write(mSys.ADR(Header), mSys.SIZE(РгЮЦНКНБНЙ));
    еякх dll рнцдю
      Write(mSys.ADR(RelocSection), mSys.SIZE(РяЕЙЖХЪ));
      Fill(Align(mSys.SIZE(РгЮЦНКНБНЙ) + mSys.SIZE(РяЕЙЖХЪ), 200H) - (mSys.SIZE(РгЮЦНКНБНЙ) + mSys.SIZE(РяЕЙЖХЪ)), 0X)
    хмюве
      Fill(Align(mSys.SIZE(РгЮЦНКНБНЙ), 200H) - mSys.SIZE(РгЮЦНКНБНЙ), 0X)
    йнмеж;

    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
    онйю cur # осярн декюрэ
      Write(mSys.ADR(Code[cur.cmd]), cur.clen);
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж;
    Fill(Align(codesize, 200H) - codesize, 0X);
    Write(mSys.ADR(rdata), 0DAH);
    еякх dll рнцдю
      etable.time := Header.time;
      Write(mSys.ADR(etable), 40);
      Write(mSys.ADR(etable.arradr), etable.adrcount * 4);
      Write(mSys.ADR(etable.arrnameptr), etable.namecount * 4);
      Write(mSys.ADR(etable.arrnum), etable.namecount * 2);
      Write(mSys.ADR(etable.text), etable.textlen)
    йнмеж;
    Fill(Align(rdatasize, 200H) - rdatasize, 0X);
    Write(mSys.ADR(Data), datasize);
    Fill(Align(datasize, 200H) - datasize, 0X);
    еякх dll рнцдю
      Write(mSys.ADR(Reloc), rcount);
      Fill(Align(rcount, 200H) - rcount, 0X)
    йнмеж;
    WriteF(F, filebuf, OutFilePos - filebuf);
    ЛтЮИК.гЮЙПШРЭ(F)
  йнмеж WritePE;

опнжедспю New;
  оепел nov: РСоСМЙРюЯЛ;
  мювюкн
    мнб(nov);
    MemErr(nov = осярн);
    nov.cmd := ccount;
    ЛяОХЯ.бЯРЮБХРЭ(asmlist, nov, current);
    current := current.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
  йнмеж New;

опнжедспю Empty(varadr: жекне);
  мювюкн
    New;
    current.clen := 0;
    current.tcmd := ECMD;
    current.varadr := varadr
  йнмеж Empty;

опнжедспю OutByte(byte: жекне);
  мювюкн
    New;
    current.clen := 1;
    Code[ccount] := CHR(byte);
    дна(ccount)
  йнмеж OutByte;

опнжедспю OutInt(int: жекне);
  мювюкн
    New;
    current.clen := 4;
    mSys.PUT(mSys.ADR(Code[ccount]), int);
    дна(ccount, 4)
  йнмеж OutInt;

опнжедспю PushEAX;
  мювюкн
    OutByte(50H);
    current.tcmd := PUSHEAX
  йнмеж PushEAX;

опнжедспю PushECX;
  мювюкн
    OutByte(51H);
    current.tcmd := PUSHECX
  йнмеж PushECX;

опнжедспю PushEDX;
  мювюкн
    OutByte(52H);
    current.tcmd := PUSHEDX
  йнмеж PushEDX;

опнжедспю PopEAX;
  мювюкн
    OutByte(58H);
    current.tcmd := POPEAX
  йнмеж PopEAX;

опнжедспю PopECX;
  мювюкн
    OutByte(59H);
    current.tcmd := POPECX
  йнмеж PopECX;

опнжедспю PopEDX;
  мювюкн
    OutByte(5AH);
    current.tcmd := POPEDX
  йнмеж PopEDX;

опнжедспю OutCode(cmd: ЛяРП.РяРПНЙЮ);
  оепел a, b: жекне;
  мювюкн
    New;
    a := mSys.ADR(Code[ccount]);
    b := a;
    InitArray(a, cmd);
    ccount := a - b + ccount;
    current.clen := a - b
  йнмеж OutCode;

опнжедспю Del*(last: РСоСМЙРюЯЛ);
  мювюкн
    last.ЯКЕДСЧЫ := current.ЯКЕДСЧЫ;
    еякх current = asmlist.ЯКЕДСЧЫ рнцдю
      asmlist.ЯКЕДСЧЫ := last
    йнмеж;
    current := last
  йнмеж Del;

опнжедспю NewLabel*(): жекне;
  мювюкн
    дна(Lcount)
    бепмсрэ Lcount
  йнмеж NewLabel;

опнжедспю PushCall*(asmline: РСоСМЙРюЯЛ);
  мювюкн
    New;
    callstk[topstk][0] := asmline;
    callstk[topstk][1] := current;
    дна(topstk)
  йнмеж PushCall;

опнжедспю Param*;
  мювюкн
    current := callstk[topstk - 1][0]
  йнмеж Param;

опнжедспю бШГНБ_гЮЙНМВХРЭ*;
  мювюкн
    current := callstk[topstk - 1][1];
    бшв(topstk)
  йнмеж бШГНБ_гЮЙНМВХРЭ;

опнжедспю мЮЯРПНХРЭ*(mem: РоПНЖЕДСПЮ; UI: жекне);
  оепел
    nov: РСоСМЙРюЯЛ;
  мювюкн
    dcount := 4;
    dll := UI = 1;
    gui := UI = 2;
    con := UI = 3;
    kos := UI = 4;
    elf := UI = 5;
    obj := UI = 6;
    MemErr := mem;
    Lcount := HALT;
    asmlist := ЛяОХЯ.яНГДЮРЭ();
    MemErr(asmlist = осярн);
    мнб(nov);
    MemErr(nov = осярн);
    ЛяОХЯ.дНАЮБХРЭ(asmlist, nov);
    current := nov;
  йнмеж мЮЯРПНХРЭ;

опнжедспю datastr(str: ЛяРП.РяРПНЙЮ);
  оепел i, n: жекне;
  мювюкн
    i := 0;
    n := LEN(str);
    онйю (i < n) & (str[i] # 0X) декюрэ
      Data[dcount] := str[i];
      дна(dcount);
      дна(i)
    йнмеж;
    Data[dcount] := 0X;
    дна(dcount)
  йнмеж datastr;

опнжедспю dataint(n: жекне);
  мювюкн
    mSys.PUT(mSys.ADR(Data[dcount]), n);
    дна(dcount, 4)
  йнмеж dataint;

опнжедспю jmp*(jamp: яхлб; label: жекне);
  оепел n: жекне;
  мювюкн
    New;
    бшанп jamp хг
    |JMP, CALL:
      n := 5
    |JE, JLE, JGE, JG, JL, JNE:
      Code[ccount] := 0FX;
      дна(ccount);
      n := 6
    хмюве
    йнмеж;
    current.clen := n;
    Code[ccount] := jamp;
    дна(ccount);
    current.codeadr := mSys.ADR(Code[ccount]);
    current.varadr := mSys.ADR(Labels[label]);
    current.tcmd := JCMD;
    current.short := хярхмю;
    дна(ccount, 4)
  йнмеж jmp;

опнжедспю jmplong(jamp: яхлб; label: жекне);
  мювюкн
    jmp(jamp, label);
    current.short := кнфэ
  йнмеж jmplong;

опнжедспю Label*(label: жекне);
  мювюкн
    New;
    current.varadr := mSys.ADR(Labels[label]);
    current.tcmd := LCMD
  йнмеж Label;

опнжедспю CmdN(Number: жекне);
  мювюкн
    New;
    current.clen := 4;
    current.codeadr := mSys.ADR(Code[ccount]);
    current.varadr := mSys.ADR(Labels[Number]);
    current.tcmd := OCMD;
    дна(ccount, 4)
  йнмеж CmdN;

опнжедспю IntByte(bytecode, intcode: ЛяРП.РяРПНЙЮ; n: жекне);
  мювюкн
    еякх (n <= 127) & (n >= -128) рнцдю
      OutCode(bytecode);
      OutByte(n)
    хмюве
      OutCode(intcode);
      OutInt(n)
    йнмеж
  йнмеж IntByte;

опнжедспю DropFpu*(long: аскебн);
  мювюкн
    еякх long рнцдю
      OutCode("83EC08DD1C24")
    хмюве
      OutCode("83EC04D91C24")
    йнмеж;
    бшв(fpu)
  йнмеж DropFpu;

опнжедспю AfterRet(func, float: аскебн; callconv, parsize: жекне);
  мювюкн
    еякх callconv = cdecl рнцдю
      OutCode("81C4");
      OutInt(parsize)
    йнмеж;
    еякх func рнцдю
      еякх float рнцдю
        OutCode("83EC08DD1C24")
      хмюве
        PushEAX
      йнмеж
    йнмеж
  йнмеж AfterRet;

опнжедспю FpuSave(local: жекне);
  оепел i: жекне;
  мювюкн
    еякх fpu > maxfpu рнцдю
      maxfpu := fpu
    йнмеж;
    дкъ i := 1 дн fpu декюрэ
      IntByte("DD5D", "DD9D", -local - i * 8)
    йнмеж
  йнмеж FpuSave;

опнжедспю Incfpu;
  мювюкн
    еякх fpu >= FREGS рнцдю
      ЛнЬ.яННАЫйННПД(ЛяЙЮМ.line, ЛяЙЮМ.col, 97, ЛтЮИК.ТЮИК.ХЛЪ);
      ЛоПНЖ.гЮЙНМВХРЭ(1)
    йнмеж;
    дна(fpu);
    isfpu := хярхмю
  йнмеж Incfpu;

опнжедспю FpuLoad(local: жекне; float: аскебн);
  оепел i: жекне;
  мювюкн
    дкъ i := fpu дн 1 он -1 декюрэ
      IntByte("DD45", "DD85", -local - i * 8)
    йнмеж;
    еякх float рнцдю
      Incfpu;
      OutCode("DD042483C408")
    йнмеж
  йнмеж FpuLoad;

опнжедспю Call*(proc: жекне; func, float: аскебн; callconv, ccall, bases, level, parsize, local: жекне);
  оепел i: жекне;
  мювюкн
    еякх ccall # 0 рнцдю
      дкъ i := level дн level - bases + ORD(ccall = 1) + 1 он -1 декюрэ
        IntByte("FF75", "FFB5", 4 * i + 4)
      йнмеж;
      еякх ccall = 1 рнцдю
        OutByte(55H)
      йнмеж
    йнмеж;
    FpuSave(local);
    jmplong(CALL, proc);
    AfterRet(func, float, callconv, parsize);
    FpuLoad(local, func & float)
  йнмеж Call;

опнжедспю CallRTL(Proc: жекне);
  мювюкн
    New;
    current.clen := 5;
    Code[ccount] := CALL;
    дна(ccount);
    current.codeadr := mSys.ADR(Code[ccount]);
    current.varadr := mSys.ADR(RtlProc[Proc]);
    current.tcmd := JCMD;
    дна(ccount, 4)
  йнмеж CallRTL;

опнжедспю PushInt*(n: жекне);
  мювюкн
    OutByte(68H);
    CmdN(n)
  йнмеж PushInt;

опнжедспю Prolog*(exename: ЛяРП.РяРПНЙЮ);
  мювюкн
    ExecName := exename;
    Labels[hInstance] := -dcount;
    dataint(0);
    Labels[SELFNAME] := -dcount;
    datastr(exename);
    Label(START);
    еякх dll рнцдю
      OutCode("558BEC837D0C007507");
      CallRTL(_close);
      OutCode("EB06837D0C017409B801000000C9C20C00")
    юеякх obj рнцдю
      OutCode("558BEC")
    йнмеж;
    start := asmlist.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
  йнмеж Prolog;

опнжедспю AddRec*(base: жекне);
  мювюкн
    дна(reccount);
    recarray[reccount] := base
  йнмеж AddRec;

опнжедспю CmpOpt(inv: аскебн): жекне;
  оепел cur: РСоСМЙРюЯЛ; c: жекне;
  мювюкн
    c := ORD(Code[current.ОПЕДШДСЫ.ОПЕДШДСЫ(РСоСМЙРюЯЛ).cmd]);
    еякх inv рнцдю
      еякх ODD(c) рнцдю
        бшв(c)
      хмюве
        дна(c)
      йнмеж
    йнмеж;
    cur := current;
    онбрнпърэ
      cur.tcmd := 0;
      cur.clen := 0;
      cur := cur.ОПЕДШДСЫ(РСоСМЙРюЯЛ)
    онйюме cur.tcmd = ICMP1;
    cur.tcmd := 0;
    cur.clen := 0
    бепмсрэ c - 16
  йнмеж CmpOpt;

опнжедспю ifwh*(L: жекне);
  оепел c: жекне;
  мювюкн
    еякх current.ОПЕДШДСЫ(РСоСМЙРюЯЛ).tcmd = ICMP2 рнцдю
      c := CmpOpt(хярхмю);
      OutCode("5A583BC2");
      jmp(CHR(c), L)
    хмюве
      PopECX;
      OutCode("85C9");
      jmp(JE, L)
    йнмеж
  йнмеж ifwh;

опнжедспю PushConst*(Number: жекне);
  мювюкн
    IntByte("6A", "68", Number);
    current.ОПЕДШДСЫ(РСоСМЙРюЯЛ).varadr := Number
  йнмеж PushConst;

опнжедспю IfWhile*(L: жекне; orop: аскебн);
  оепел c, L1: жекне;
  мювюкн
    L1 := NewLabel();
    еякх current.ОПЕДШДСЫ(РСоСМЙРюЯЛ).tcmd = ICMP2 рнцдю
      c := CmpOpt(orop);
      OutCode("5A583BC2");
      jmp(CHR(c), L1);
      PushConst(ORD(orop))
    хмюве
      PopECX;
      OutCode("85C9");
      еякх orop рнцдю
        jmp(JE, L1)
      хмюве
        jmp(JNE, L1)
      йнмеж;
      PushECX
    йнмеж;
    jmp(JMP, L);
    Label(L1)
  йнмеж IfWhile;

опнжедспю newrec*;
  мювюкн
    CallRTL(_newrec)
  йнмеж newrec;

  опнжедспю disprec*;
  мювюкн
    CallRTL(_disprec)
  йнмеж disprec;

опнжедспю String*(Number, Len: жекне; str: ЛяРП.РяРПНЙЮ);
  мювюкн
    Labels[Number] := -dcount;
    еякх Len > 1 рнцдю
      datastr(str)
    юеякх Len = 1 рнцдю
      dataint(ORD(str[0]))
    хмюве
      dataint(0)
    йнмеж
  йнмеж String;

опнжедспю InsertFpuInit;
  оепел t: РСоСМЙРюЯЛ;
  мювюкн
    еякх isfpu рнцдю
      t := current;
      current := fpucmd;
      еякх maxfpu > 0 рнцдю
        OutCode("83EC");
        OutByte(maxfpu * 8)
      йнмеж;
      OutCode("DBE3");
      current := t
    йнмеж
  йнмеж InsertFpuInit;

опнжедспю ProcBeg*(Number, Local: жекне; Module: аскебн);
  оепел i: жекне;
  мювюкн
    еякх Module рнцдю
      OutCode("EB0C");
      Label(Number + 3);
      PushInt(Number + 2);
      jmplong(JMP, HALT);
      Label(Number + 1)
    хмюве
      Label(Number)
    йнмеж;
    OutCode("558BEC");
    еякх Local > 12 рнцдю
      IntByte("83EC", "81EC", Local);
      OutCode("8BD733C08BFCB9");
      OutInt(ASR(Local, 2));
      OutCode("9CFCF3AB8BFA9D")
    хмюве
      дкъ i := 4 дн Local он 4 декюрэ
        OutCode("6A00")
      йнмеж
    йнмеж;
    fpucmd := current;
    fpu := 0;
    maxfpu := 0;
    isfpu := кнфэ
  йнмеж ProcBeg;

опнжедспю Leave*;
  мювюкн
    OutByte(0C9H);
    InsertFpuInit
  йнмеж Leave;

опнжедспю ProcEnd*(Number, Param: жекне; func, float: аскебн);
  мювюкн
    еякх func & ~float рнцдю
      PopEAX
    йнмеж;
    OutByte(0C9H);
    еякх Param = 0 рнцдю
      OutByte(0C3H)
    хмюве
      OutByte(0C2H);
      OutByte(Param MOD 256);
      OutByte(ASR(Param, 8))
    йнмеж;
    InsertFpuInit
  йнмеж ProcEnd;

опнжедспю Module*(Name: ЛяРП.РяРПНЙЮ; Number: жекне);
  мювюкн
    String(Number + 2, LENGTH(Name), Name);
    jmplong(JMP, Number + 1)
  йнмеж Module;

опнжедспю Asm*(s: ЛяРП.РяРПНЙЮ);
  мювюкн
    OutCode(s)
  йнмеж Asm;

опнжедспю GlobalAdr*(offset: жекне);
  мювюкн
    OutByte(0BAH);
    OutInt(offset);
    current.codeadr := mSys.ADR(Code[ccount - 4]);
    current.tcmd := GCMD;
    PushEDX
  йнмеж GlobalAdr;

опнжедспю Mono*(Number: жекне);
  мювюкн
    PopEDX;
    PushInt(Number)
  йнмеж Mono;

опнжедспю StrMono*;
  мювюкн
    PopEDX;
    OutCode("6A02");
    PushEDX
  йнмеж StrMono;

опнжедспю Not*;
  мювюкн
    PopECX;
    OutCode("85C90F94C1");
    PushECX
  йнмеж Not;

опнжедспю NegSet*;
  мювюкн
    OutCode("F71424")
  йнмеж NegSet;

опнжедспю Int*(Op: жекне);
  мювюкн
    PopEDX;
    бшанп Op хг
    |lxPlus:  OutCode("011424")
    |lxMinus: OutCode("291424")
    |lxMult:  OutCode("58F7EA"); PushEAX
    хмюве
    йнмеж
  йнмеж Int;

опнжедспю Set*(Op: жекне);
  мювюкн
    PopEDX;
    OutCode("58");
    бшанп Op хг
    |lxPlus:  OutCode("0B")
    |lxMinus: OutCode("F7D223")
    |lxMult:  OutCode("23")
    |lxSlash: OutCode("33")
    хмюве
    йнмеж;
    OutCode("C2");
    PushEAX
  йнмеж Set;

опнжедспю Setfpu*(newfpu: жекне);
  мювюкн
    fpu := newfpu
  йнмеж Setfpu;

опнжедспю PushFlt*(x: дкхмбеы);
  оепел f: TFLT; L: жекне;
  мювюкн
    mSys.PUT(mSys.ADR(f), x);
    Incfpu;
    еякх x = 0.0D0 рнцдю
      OutCode("D9EE")
    юеякх x = 1.0D0 рнцдю
      OutCode("D9E8")
    хмюве
      L := NewLabel();
      Labels[L] := -dcount;
      dataint(f[0]);
      dataint(f[1]);
      OutByte(0BAH);
      CmdN(L);
      OutCode("DD02")
    йнмеж
  йнмеж PushFlt;

опнжедспю farith*(op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("DE");
    бшанп op хг
    |lxPlus:  n := 0C1H
    |lxMinus: n := 0E9H
    |lxMult:  n := 0C9H
    |lxSlash: n := 0F9H
    хмюве
    йнмеж;
    OutByte(n);
    бшв(fpu)
  йнмеж farith;

опнжедспю fcmp*(Op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("33C9DED9DFE09E0F");
    бшанп Op хг
    |lxEQ: n := 94H
    |lxNE: n := 95H
    |lxLT: n := 97H
    |lxGT: n := 92H
    |lxLE: n := 93H
    |lxGE: n := 96H
    хмюве
    йнмеж;
    бшв(fpu, 2);
    OutByte(n);
    OutByte(0C1H);
    PushECX
  йнмеж fcmp;

опнжедспю fneg*;
  мювюкн
    OutCode("D9E0")
  йнмеж fneg;

опнжедспю OnError*(n: жекне);
  мювюкн
    OutByte(68H);
    OutInt(ЛсРХКЭ.ЯРПНЙЮ_МНЛ * 16 + n);
    jmplong(JMP, ЛсРХКЭ.ЛНДСКЭ_МНЛ + 3)
  йнмеж OnError;

опнжедспю idivmod*(opmod: аскебн);
  мювюкн
    PopECX;
    еякх opmod рнцдю
      OutCode("58E32E538BD833D9C1FB1F8BD0C1FA1F83F9FF750C3D0000008075055B6A00EB1AF7F985DB740685D2740203D15B52EB0A")
    хмюве
      OutCode("58E32C538BD833D9C1FB1F8BD0C1FA1F83F9FF750B3D0000008075045B50EB19F7F985DB740585D27401485B50EB0A")
    йнмеж;
    OnError(8)
  йнмеж idivmod;

опнжедспю rset*;
  мювюкн
    CallRTL(_rset);
    PushEAX
  йнмеж rset;

опнжедспю inset*;
  мювюкн
    CallRTL(_inset);
    PushEAX
  йнмеж inset;

опнжедспю Dup*;
  мювюкн
    PopEDX;
    PushEDX;
    PushEDX
  йнмеж Dup;

опнжедспю Inclusion*(Op: жекне);
  мювюкн
    PopEDX;
    PopEAX;
    еякх Op = lxLE рнцдю
      PushEDX
    хмюве
      PushEAX
    йнмеж;
    OutCode("0BC25933C8E3046A00EB026A01")
  йнмеж Inclusion;

опнжедспю NegInt*;
  мювюкн
    OutCode("F71C24")
  йнмеж NegInt;

опнжедспю CmpInt*(Op: жекне);
  оепел n: жекне;
  мювюкн
    OutCode("33C95A583BC20F"); current.tcmd := ICMP1;
    бшанп Op хг
    |lxEQ: n := 94H
    |lxNE: n := 95H
    |lxLT: n := 9CH
    |lxGT: n := 9FH
    |lxLE: n := 9EH
    |lxGE: n := 9DH
    хмюве
    йнмеж;
    OutByte(n);
    OutCode("C1"); current.tcmd := ICMP2;
    PushECX;
  йнмеж CmpInt;

опнжедспю CallVar*(func, float: аскебн; callconv, parsize, local: жекне);
  мювюкн
    PopEDX;
    OutCode("8B1285D2750A");
    OnError(2);
    FpuSave(local);
    OutCode("FFD2");
    AfterRet(func, float, callconv, parsize);
    FpuLoad(local, func & float)
  йнмеж CallVar;

опнжедспю LocalAdr*(offset, bases: жекне);
  мювюкн
    еякх bases = 0 рнцдю
      Empty(offset);
      OutCode("8BD5")
    хмюве
      IntByte("8B55", "8B95", 4 * bases + 4)
    йнмеж;
    IntByte("83C2", "81C2", offset);
    PushEDX;
    еякх bases = 0 рнцдю
      Empty(offset)
    йнмеж
  йнмеж LocalAdr;

опнжедспю Field*(offset: жекне);
  мювюкн
    еякх offset # 0 рнцдю
      IntByte("830424", "810424", offset)
    йнмеж
  йнмеж Field;

опнжедспю DerefType*(n: жекне);
  мювюкн
    IntByte("8B5424", "8B9424", n);
    OutCode("FF72FC")
  йнмеж DerefType;

опнжедспю Guard*(T: жекне; Check: аскебн);
  мювюкн
    еякх Check рнцдю
      PopEAX;
      OutCode("85C074");
      еякх T <= 127 рнцдю
        OutByte(9)
      хмюве
        OutByte(12)
      йнмеж;
      PushEAX
    йнмеж;
    PushConst(T);
    PushEAX;
    CallRTL(_checktype);
    еякх Check рнцдю
      PushEAX
    хмюве
      OutCode("85C0750A");
      OnError(3)
    йнмеж
  йнмеж Guard;

опнжедспю StProc*(proc: жекне);
  мювюкн
    бшанп proc хг
    |stINC:   PopEDX; OutCode("590111")
    |stDEC:   PopEDX; OutCode("592911")
    |stINC1:  PopEDX; OutCode("FF02")
    |stDEC1:  PopEDX; OutCode("FF0A")
    |stINCL:  PopEDX; OutCode("580910")
    |stEXCL:  PopEDX; OutCode("582110")
    |sysBIT:  PopECX; OutCode("5A585333DB8A18E3050FABD3EB030FB3D388185B")
    |stPACK:  OutCode("DB04245A5ADD02D9FDDD1A"); isfpu := хярхмю
    |stPACK1: OutCode("DB04245A5AD902D9FDD91A"); isfpu := хярхмю
    |stUNPK:  PopEDX; OutCode("59DD01D9F4DD19DB1A"); isfpu := хярхмю
    |stUNPK1: PopEDX; OutCode("59D901D9F4D919DB1A"); isfpu := хярхмю
    |stCOPY:  CallRTL(_strcopy)
    |sysMOVE: CallRTL(_savearr)
    хмюве
    йнмеж
  йнмеж StProc;

опнжедспю Assert*(proc, assrt: жекне);
  мювюкн
    PopEDX;
    OutCode("85D2751368");
    OutInt(ЛсРХКЭ.ЯРПНЙЮ_МНЛ * 16 + 1);
    PushInt(ЛсРХКЭ.ЛНДСКЭ_МНЛ + 2);
    еякх proc = stASSERT рнцдю
      OutCode("6A026A")
    хмюве
      OutCode("6A016A")
    йнмеж;
    OutByte(assrt);
    jmplong(JMP, ASSRT)
  йнмеж Assert;

опнжедспю StFunc*(func: жекне);
  мювюкн
    бшанп func хг
    |stABS:    PopEDX; OutCode("85D27D02F7DA"); PushEDX
    |stFABS:   OutCode("D9E1")
    |stFLT:    OutCode("DB0424"); PopEAX; Incfpu;
    |stFLOOR:  OutCode("83EC06D93C2466812424FFF366810C24FFF7D92C2483C402D9FCDB1C24"); бшв(fpu)
    |stODD:    OutCode("83242401")
    |stROR:    PopECX; OutCode("58D3C8"); PushEAX
    |stASR:    PopECX; OutCode("58D3F8"); PushEAX
    |stLSL:    PopECX; OutCode("58D3E0"); PushEAX
    |stLSR:    PopECX; OutCode("58D3E8"); PushEAX
    |stORD:    PopEDX; OutCode("85D274036A015A"); PushEDX
    |stLENGTH: CallRTL(_length); PushEAX
    |sysBIT:   PopEDX; OutCode("5933C08A010FA3D072046A00EB026A01")
    хмюве
    йнмеж
  йнмеж StFunc;

опнжедспю Load*(T: жекне);
  оепел
    lastcmd: РСоСМЙРюЯЛ;
    offset: жекне;

  опнжедспю del;
    мювюкн
      lastcmd.tcmd := 0;
      offset := lastcmd.varadr;
      lastcmd := lastcmd.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
      онйю lastcmd.tcmd # ECMD декюрэ
        lastcmd.clen := 0;
        lastcmd.tcmd := 0;
        lastcmd := lastcmd.ОПЕДШДСЫ(РСоСМЙРюЯЛ)
      йнмеж;
      lastcmd.tcmd := 0
    йнмеж del;

  мювюкн
    lastcmd := current;
    бшанп T хг
    |TINTEGER, TSET, TPOINTER, TPROC:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("8B55", "8B95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("FF32")
      йнмеж
    |TCHAR, TBOOLEAN:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        OutCode("33D28A");
        IntByte("55", "95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("33C98A0A");
        PushECX
      йнмеж
    |TLONGREAL:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("DD45", "DD85", offset)
      хмюве
        PopEDX;
        OutCode("DD02")
      йнмеж;
      Incfpu
    |TREAL:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        IntByte("D945", "D985", offset)
      хмюве
        PopEDX;
        OutCode("D902")
      йнмеж;
      Incfpu
    |TCARD16:
      еякх lastcmd.tcmd = ECMD рнцдю
        del;
        OutCode("33D2668B");
        IntByte("55", "95", offset);
        PushEDX
      хмюве
        PopEDX;
        OutCode("33C9668B0A");
        PushECX
      йнмеж
    хмюве
    йнмеж
  йнмеж Load;

опнжедспю Save*(T: жекне);
  мювюкн
    бшанп T хг
    |TINTEGER, TSET, TPOINTER, TPROC:
      PopEDX;
      OutCode("588910")
    |TCHAR, TSTRING, TBOOLEAN:
      PopEDX;
      OutCode("588810")
    |TCARD16:
      PopEDX;
      OutCode("58668910")
    |TLONGREAL:
      PopEDX;
      OutCode("DD1A");
      бшв(fpu)
    |TREAL:
      PopEDX;
      OutCode("D91A");
      бшв(fpu)
    |TRECORD:
      CallRTL(_saverec);
      OutCode("83F800750A");
      OnError(4)
    |TARRAY:
      CallRTL(_savearr)
    хмюве
    йнмеж
  йнмеж Save;

опнжедспю OpenArray*(A: TIDX; n: жекне);
  оепел i: жекне;
  мювюкн
    PopEDX;
    дкъ i := n - 1 дн 0 он -1 декюрэ
      PushConst(A[i])
    йнмеж;
    PushEDX
  йнмеж OpenArray;

опнжедспю OpenIdx*(n: жекне);
  мювюкн
    OutByte(54H);
    еякх n > 1 рнцдю
      PushConst(n);
      CallRTL(_arrayidx)
    хмюве
      CallRTL(_arrayidx1)
    йнмеж;
    PopEDX;
    OutCode("85D2750A");
    OnError(5);
    PushEDX;
  йнмеж OpenIdx;

опнжедспю FixIdx*(len, size: жекне);
  мювюкн
    PopEDX;
    IntByte("5983FA", "5981FA", len);
    OutCode("720A");
    OnError(5);
    еякх size > 1 рнцдю
      IntByte("6BD2", "69D2", size)
    йнмеж;
    OutCode("03D1");
    PushEDX
  йнмеж FixIdx;

опнжедспю Idx*;
  мювюкн
    PopEDX;
    PopECX;
    OutCode("03D1");
    PushEDX
  йнмеж Idx;

опнжедспю DupLoadCheck*;
  мювюкн
    PopEDX;
    OutCode("528B125285D2750A");
    OnError(6)
  йнмеж DupLoadCheck;

опнжедспю DupLoad*;
  мювюкн
    PopEDX;
    OutCode("528B12");
    PushEDX;
  йнмеж DupLoad;

опнжедспю CheckNIL*;
  мювюкн
    PopEDX;
    OutCode("85D2750A");
    OnError(6);
    PushEDX;
  йнмеж CheckNIL;

опнжедспю ExtArray*(A: TIDX; n, m: жекне);
  оепел i: жекне;
  мювюкн
    дкъ i := n - 1 дн 0 он -1 декюрэ
      PushConst(A[i])
    йнмеж;
    OutByte(54H);
    PushConst(n);
    PushConst(m);
    CallRTL(_arrayrot)
  йнмеж ExtArray;

опнжедспю ADR*(dim: жекне);
  мювюкн
    еякх dim > 0 рнцдю
      PopEDX;
      OutCode("83C4");
      OutByte(dim * 4);
      PushEDX
    йнмеж
  йнмеж ADR;

опнжедспю Len*(dim: жекне);
  мювюкн
    PopEDX;
    еякх dim < 0 рнцдю
      PushConst(-dim)
    юеякх dim > 1 рнцдю
      PopEDX;
      OutCode("83C4");
      OutByte((dim - 1) * 4);
      PushEDX
    йнмеж
  йнмеж Len;

опнжедспю For*(inc: аскебн; оеп LBeg, LEnd: жекне);
  мювюкн
    LEnd := NewLabel();
    LBeg := NewLabel();
    Label(LBeg);
    OutCode("8B14248B4424043910");
    еякх inc рнцдю
      jmp(JG, LEnd)
    хмюве
      jmp(JL, LEnd)
    йнмеж
  йнмеж For;

опнжедспю NextFor*(step, LBeg, LEnd: жекне);
  мювюкн
    OutCode("8B542404");
    еякх step = 1 рнцдю
      OutCode("FF02")
    юеякх step = -1 рнцдю
      OutCode("FF0A")
    хмюве
      IntByte("8302", "8102", step)
    йнмеж;
    jmp(JMP, LBeg);
    Label(LEnd);
    OutCode("83C408")
  йнмеж NextFor;

опнжедспю CaseLabel*(a, b, LBeg: жекне);
  оепел L: жекне;
  мювюкн
    L := NewLabel();
    IntByte("83FA", "81FA", a);
    еякх a = b рнцдю
      jmp(JNE, L)
    хмюве
      jmp(JL, L);
      IntByte("83FA", "81FA", b);
      jmp(JG, L)
    йнмеж;
    jmp(JMP, LBeg);
    Label(L)
  йнмеж CaseLabel;

опнжедспю Drop*;
  мювюкн
    PopEDX
  йнмеж Drop;

опнжедспю strcmp*(Op, LR: жекне);
  мювюкн
    бшанп Op хг
    |lxEQ: PushConst(0)
    |lxNE: PushConst(1)
    |lxLT: PushConst(2)
    |lxGT: PushConst(3)
    |lxLE: PushConst(4)
    |lxGE: PushConst(5)
    хмюве
    йнмеж;
    бшанп LR хг
    |-1: CallRTL(_lstrcmp)
    | 0: CallRTL(_strcmp)
    | 1: CallRTL(_rstrcmp)
    хмюве
    йнмеж;
    PushEAX
  йнмеж strcmp;

опнжедспю Optimization;
  оепел
    cur: РСоСМЙРюЯЛ;
    flag: аскебн;
  мювюкн
    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
    онйю cur # осярн декюрэ
      flag := кнфэ;
      бшанп cur.tcmd хг
      |PUSHEAX:
        flag := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ).tcmd = POPEAX
      |PUSHECX:
        flag := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ).tcmd = POPECX
      |PUSHEDX:
        flag := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ).tcmd = POPEDX
      хмюве
      йнмеж;
      еякх flag рнцдю
        cur.clen := 0;
        cur.tcmd := 0;
        cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ);
        cur.clen := 0;
        cur.tcmd := 0
      йнмеж;
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж
  йнмеж Optimization;

опнжедспю WriteKOS(FName: люяяхб хг яхлб; stk, size, datasize, gsize: жекне; obj: аскебн);
  CONST strsize = 2048;
  оепел
    Header: РгЮЦНКНБНЙKol;
    F, i, filesize, filebuf, a, sec, adr, size2: жекне;
    cur: РСоСМЙРюЯЛ;
    Coff: РгЮЦНКНБНЙCoff;
    sym: люяяхб 18 * 4 хг яхлб;
    FileName: ЛяРП.РяРПНЙЮ;
  мювюкн
    F := ЛтЮИК.яНГДЮРЭ(FName);
    еякх F <= 0 рнцдю
      Err(1)
    йнмеж;
    OutFilePos := ЛоЮЛ.оНКСВ(Align(size, 4) + datasize + 1000H);
    filebuf := OutFilePos;
    ЛоЮЛ.нЬХАЙЮ(OutFilePos = 0);

    еякх ~obj рнцдю
      Header.menuet01 := "MENUET01";
      Header.ver := 1;
      Header.start := mSys.SIZE(РгЮЦНКНБНЙKol);
      Header.size := Align(size, 4) + datasize;
      Header.mem := Header.size + stk + gsize + strsize * 2 + 1000H;
      Header.sp := Header.size + gsize + stk;
      Header.param := Header.sp;
      Header.path := Header.param + strsize;

      Write(mSys.ADR(Header), mSys.SIZE(РгЮЦНКНБНЙKol));

      cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
      онйю cur # осярн декюрэ
        Write(mSys.ADR(Code[cur.cmd]), cur.clen);
        cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
      йнмеж;
      Fill(Align(size, 4) - size, 0X);
      Write(mSys.ADR(Data), datasize);
      WriteF(F, filebuf, OutFilePos - filebuf)

    хмюве

      size2 := size;
      size := Align(size, 4) - mSys.SIZE(РгЮЦНКНБНЙKol);
      Coff.Machine := IntToCard16(014CH);
      Coff.NumberOfSections := IntToCard16(3);
      Coff.TimeDateStamp := ЛйНМЯР.ДЮРЮ;
      Coff.SizeOfOptionalHeader := IntToCard16(0);
      Coff.Characteristics := IntToCard16(0184H);

      Coff.text.name := ".flat";
      Coff.text.size := 0;
      Coff.text.adr := 0;
      Coff.text.sizealign := size;
      Coff.text.OAPfile := 8CH;
      Coff.text.reserved6 := size + datasize + 8CH;
      Coff.text.reserved7 := 0;
      Coff.text.attrflags := 40300020H;

      Coff.data.name := ".data";
      Coff.data.size := 0;
      Coff.data.adr := 0;
      Coff.data.sizealign := datasize;
      Coff.data.OAPfile := size + 8CH;
      Coff.data.reserved6 := 0;
      Coff.data.reserved7 := 0;
      Coff.data.reserved8 := 0;
      Coff.data.attrflags := 0C0300040H;

      Coff.bss.name := ".bss";
      Coff.bss.size := 0;
      Coff.bss.adr := 0;
      Coff.bss.sizealign := gsize;
      Coff.bss.OAPfile := 0;
      Coff.bss.reserved6 := 0;
      Coff.bss.reserved7 := 0;
      Coff.bss.reserved8 := 0;
      Coff.bss.attrflags := 0C03000C0H;

      size := Align(size2, 4);
      rcount := 0;
      cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
      онйю cur # осярн декюрэ
        еякх cur.tcmd IN {OCMD, GCMD} рнцдю
          mSys.GET(mSys.ADR(Code[cur.cmd]), a);
          еякх a < size рнцдю
            a := a - mSys.SIZE(РгЮЦНКНБНЙKol);
            sec := 1
          юеякх a < size + datasize рнцдю
            a := a - size;
            sec := 2
          хмюве
            a := a - size - datasize;
            sec := 3
          йнмеж;
          mSys.PUT(mSys.ADR(Code[cur.cmd]), a);
          mSys.PUT(mSys.ADR(Reloc[rcount]), cur.adr - mSys.SIZE(РгЮЦНКНБНЙKol));
          дна(rcount, 4);
          mSys.PUT(mSys.ADR(Reloc[rcount]), sec);
          дна(rcount, 4);
          mSys.PUT(mSys.ADR(Reloc[rcount]), 06X); дна(rcount);
          mSys.PUT(mSys.ADR(Reloc[rcount]), 00X); дна(rcount);
        йнмеж;
        Write(mSys.ADR(Code[cur.cmd]), cur.clen);
        cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
      йнмеж;
      size := size2;
      Fill(Align(size, 4) - size2, 0X);
      Write(mSys.ADR(Data), datasize);
      Coff.text.reserved8 := rcount DIV 10;
      Coff.PointerToSymbolTable := Coff.text.reserved6 + rcount;
      Coff.NumberOfSymbols := 4;

      WriteF(F, mSys.ADR(Coff), mSys.SIZE(РгЮЦНКНБНЙCoff));
      WriteF(F, filebuf, OutFilePos - filebuf);
      WriteF(F, mSys.ADR(Reloc), rcount);

      adr := mSys.ADR(sym);
      InitArray(adr, "4558504F52545300000000000100000002002E666C617400000000000000010000000300");
      InitArray(adr, "2E64617461000000000000000200000003002E6273730000000000000000030000000300");
      mSys.PUT(mSys.ADR(sym) + 8, Labels[Exports] - mSys.SIZE(РгЮЦНКНБНЙKol));

      WriteF(F, mSys.ADR(sym), LEN(sym));
      i := 4;
      WriteF(F, mSys.ADR(i), 4)
    йнмеж;
    ЛтЮИК.гЮЙПШРЭ(F)
  йнмеж WriteKOS;

опнжедспю WriteELF(FName: люяяхб хг яхлб; code, data, glob: жекне);
  оепел
    F, res, delta, filebuf: жекне;
    cur: РСоСМЙРюЯЛ;
    bytes: люяяхб 817H + 55FH + 4900 хг яхлб;
    опнжедспю Add(offset: жекне);
    оепел m: жекне;
    мювюкн
      mSys.GET(mSys.ADR(bytes[offset]), m);
      mSys.PUT(mSys.ADR(bytes[offset]), m + delta)
    йнмеж Add;

    опнжедспю Sub(offset: жекне);
    оепел m: жекне;
    мювюкн
      mSys.GET(mSys.ADR(bytes[offset]), m);
      mSys.PUT(mSys.ADR(bytes[offset]), m - delta)
    йнмеж Sub;

  мювюкн
    F := ЛтЮИК.нРЙПШРЭ(felf, 0);
    еякх F = 0 рнцдю
      Err(3)
    йнмеж;
    еякх ЛтЮИК.вХРЮРЭ(F, mSys.ADR(bytes), 817H + 55FH + 4900) # 817H + 55FH + 4900 рнцдю
      Err(4)
    йнмеж;
    ЛтЮИК.гЮЙПШРЭ(F);
    bytes[0] := 7FX;

    бшв(code, 13);

    delta := Align(data, 1000H) - 100000H;
    Add(0020H); Add(00A4H); Add(00A8H); Add(0258H); Add(02B8H); Add(0308H); Add(0494H); Add(049CH);
    Add(04A4H); Add(0679H); Add(0681H); Add(06A4H); Add(06B0H); Add(06BAH); Add(0703H); Add(0762H);
    Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(17C5H); Add(17E5H); Add(17E9H); Add(1811H);
    Add(1839H); Add(1861H); Add(1889H); Add(1A25H); Add(1A95H); Add(1AA5H); Add(1C05H); Add(1C55H);
    Add(1CE5H); Add(1D09H); Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H);

    delta := Align(glob, 1000H) - 3200000H;
    Add(00A8H); Add(17EDH); Add(1C09H); Add(1D25H);

    delta := Align(code, 1000H) - 100000H;
    Add(0020H); Add(0084H); Add(0088H); Add(0098H); Add(009CH); Add(00A0H); Add(00B8H); Add(00BCH);
    Add(00C0H); Add(0118H); Add(011CH); Add(0120H); Add(0258H); Add(0278H); Add(02B8H); Add(0308H);
    Add(048CH); Add(0494H); Add(049CH); Add(04A4H); Add(04ACH); Add(04B4H); Add(04BCH); Add(04C4H);
    Add(04CCH); Add(04D4H); Add(04DCH); Add(04E4H); Add(04ECH); Add(04F4H); Add(04FCH); Add(0504H);
    Add(050CH); Add(0514H); Add(052BH); Add(0544H); Add(054EH); Add(0554H); Add(055EH); Add(056EH);
    Add(057EH); Add(058EH); Add(059EH); Add(05AEH); Add(05BEH); Add(05CEH); Add(05DEH); Add(05EEH);
    Add(05FEH); Add(060EH); Add(061EH); Add(062EH); Add(064CH); Add(0651H); Add(0679H); Add(0681H);
    Add(0686H); Add(068CH); Add(06A4H); Add(06ABH); Add(06B0H); Add(06BAH); Add(06D7H); Add(06EBH);
    Add(0703H); Add(0762H); Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(0828H); Add(082DH);
    Sub(0845H); Sub(087BH); Add(08DEH); Add(08E8H); Sub(0916H); Add(0C52H); Add(0C8AH); Add(0D0AH);
    Add(1635H); Add(1655H); Add(1659H); Add(167DH); Add(1681H); Add(16A5H); Add(16A9H); Add(16CDH);
    Add(16D1H); Add(16F5H); Add(16F9H); Add(171DH); Add(1721H); Add(1745H); Add(1749H); Add(176DH);
    Add(1771H); Add(1795H); Add(1799H); Add(17BDH); Add(17C1H); Add(17E5H); Add(17E9H); Add(1811H);
    Add(1839H); Add(1861H); Add(1889H); Add(1985H); Add(1995H); Add(19A5H); Add(19B5H); Add(19C5H);
    Add(19D5H); Add(19E5H); Add(19F5H); Add(1A05H); Add(1A15H); Add(1A25H); Add(1A55H); Add(1A65H);
    Add(1A75H); Add(1A95H); Add(1AA5H); Add(1AD5H); Add(1AE5H); Add(1AF5H); Add(1B05H); Add(1B25H);
    Add(1B35H); Add(1B45H); Add(1B55H); Add(1B65H); Add(1B75H); Add(1BB5H); Add(1BC5H); Add(1BE5H);
    Add(1C05H); Add(1C15H); Add(1C55H); Add(1C75H); Add(1CA5H); Add(1CB5H); Add(1CE5H); Add(1D05H);
    Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H); Add(1D75H); Add(1D89H);

    OutFilePos := ЛоЮЛ.оНКСВ(code + data + 8000H);
    filebuf := OutFilePos;
    ЛоЮЛ.нЬХАЙЮ(OutFilePos = 0);

    Write(mSys.ADR(bytes), 817H);
    Fill(2DDH, 90X);
    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
    онйю cur # осярн декюрэ
      Write(mSys.ADR(Code[cur.cmd]), cur.clen);
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж;
    Fill(Align(code, 1000H) - code, 90X);
    Write(mSys.ADR(bytes[817H]), 55FH);
    Write(mSys.ADR(Data), data);
    Fill(Align(data, 1000H) - data, 0X);
    Write(mSys.ADR(bytes[817H + 55FH + 55FH]), 0DC5H);

    F := ЛтЮИК.яНГДЮРЭ(FName);
    еякх F <= 0 рнцдю
      Err(1)
    йнмеж;
    WriteF(F, filebuf, OutFilePos - filebuf);
    ЛтЮИК.гЮЙПШРЭ(F)
  йнмеж WriteELF;

опнжедспю FixLabels(FName: люяяхб хг яхлб; stk, gsize, glob: жекне);
  оепел
    size, asize, i, rdatasize, RCount, n, temp, temp2, temp3: жекне;
    cur: РСоСМЙРюЯЛ;
    R: РпЕКНЙ;
    c: яхлб;
  мювюкн
    dcount := Align(dcount, 4);
    еякх dll рнцдю
      LoadAdr := 10000000H;
      PackExport(ExecName)
    юеякх con хкх gui рнцдю
      LoadAdr := 400000H
    юеякх kos хкх obj рнцдю
      LoadAdr := mSys.SIZE(РгЮЦНКНБНЙKol)
    юеякх elf рнцдю
      LoadAdr := 134514420 + 1024;
      дна(gsize, 1024)
    йнмеж;

    еякх dll хкх con хкх gui рнцдю
      rdatasize := 0DAH + etable.size;
      size := 1000H + LoadAdr;
    юеякх kos хкх elf хкх obj рнцдю
      rdatasize := 0;
      size := LoadAdr
    йнмеж;

    Optimization;
    temp2 := size;
    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
    онйю cur # осярн декюрэ
      cur.adr := size;
      еякх cur.tcmd = LCMD рнцдю
        mSys.PUT(cur.varadr, size)
      йнмеж;
      size := size + cur.clen;
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж;

    size := temp2;
    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);
    онйю cur # осярн декюрэ
      cur.adr := size;
      еякх cur.tcmd = LCMD рнцдю
        mSys.PUT(cur.varadr, size)
      юеякх (cur.tcmd = JCMD) & cur.short рнцдю
        mSys.GET(cur.varadr, i);
        temp3 := i - cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ).adr;
        еякх (-131 <= temp3) & (temp3 <= 123) рнцдю
          mSys.GET(cur(РСоСМЙРюЯЛ).codeadr - 1, c);
          еякх c = JMP рнцдю
            mSys.PUT(cur(РСоСМЙРюЯЛ).codeadr - 1, 0EBX)
          хмюве (*JE, JNE, JLE, JGE, JG, JL*)
            mSys.PUT(cur(РСоСМЙРюЯЛ).codeadr - 2, ORD(c) - 16);
            mSys.PUT(cur(РСоСМЙРюЯЛ).codeadr - 1, temp3);
            бшв(cur(РСоСМЙРюЯЛ).codeadr)
          йнмеж;
          cur.clen := 2
        йнмеж
      йнмеж;
      size := size + cur.clen;
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж;

    еякх dll хкх con хкх gui рнцдю
      asize := Align(size, 1000H)
    юеякх kos хкх obj рнцдю
      asize := Align(size, 4)
    юеякх elf рнцдю
      asize := 134514420 + 6508 + Align(size - 13 - LoadAdr, 1000H)
    йнмеж;

    дкъ i := 0 дн Lcount декюрэ
      еякх Labels[i] < 0 рнцдю
        Labels[i] := -Labels[i] + asize + Align(rdatasize, 1000H)
      йнмеж
    йнмеж;

    temp := dcount;
    еякх elf рнцдю
      asize := asize + Align(dcount, 1000H) + 64 + 1024;
      mSys.PUT(mSys.ADR(Code[glob + 1]), asize - 1024);
      dcount := 0
    йнмеж;

    еякх dll рнцдю
      asize := asize - LoadAdr + 0DAH;
      дкъ i := 0 дн etable.namecount - 1 декюрэ
        etable.arradr[i] := Labels[etable.arradr[i]] - LoadAdr;
        etable.arrnameptr[i] := etable.arrnameptr[i] + asize
      йнмеж;
      etable.arradroffset := etable.arradroffset + asize;
      etable.arrnameptroffset := etable.arrnameptroffset + asize;
      etable.arrnumoffset := etable.arrnumoffset + asize;
      etable.dllnameoffset := etable.dllnameoffset + asize;
      asize := asize + LoadAdr - 0DAH
    йнмеж;
    еякх dll хкх con хкх gui рнцдю
      Labels[LoadLibrary] := asize + 4;
      Labels[GetProcAddress] := asize;
      R.Page := 0;
      R.Size := 0;
      RCount := 0;
    йнмеж;
    cur := asmlist.ОПЕДШДСЫ(РСоСМЙРюЯЛ);

    дкъ i := 0 дн LEN(RtlProc) - 1 декюрэ
      RtlProc[i] := Labels[RtlProc[i]]
    йнмеж;

    temp3 := asize + Align(rdatasize, 1000H) + dcount;
    онйю cur # осярн декюрэ
      бшанп cur.tcmd хг
      |JCMD:
        mSys.GET(cur.varadr, i);
        mSys.PUT(cur.codeadr, i - cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ).adr)
      |GCMD:
        mSys.GET(cur.codeadr, i);
        mSys.PUT(cur.codeadr, i + temp3)
      |OCMD:
        mSys.MOVE(cur.varadr, cur.codeadr, 4)
      хмюве
      йнмеж;
      еякх dll & (cur.tcmd IN {GCMD, OCMD}) рнцдю
        n := cur.adr - LoadAdr;
        еякх ASR(n, 12) = ASR(R.Page, 12) рнцдю
          R.reloc[RCount] := IntToCard16(n MOD 1000H + 3000H);
          дна(RCount);
          дна(R.Size, 2)
        хмюве
          еякх R.Size # 0 рнцдю
            PutReloc(R)
          йнмеж;
          R.Page := ASR(n, 12) * 1000H;
          R.Size := 10;
          R.reloc[0] := IntToCard16(n MOD 1000H + 3000H);
          RCount := 1
        йнмеж
      йнмеж;
      cur := cur.ЯКЕДСЧЫ(РСоСМЙРюЯЛ)
    йнмеж;
    еякх R.Size # 0 рнцдю
      PutReloc(R)
    йнмеж;
    еякх dll хкх con хкх gui рнцдю
      WritePE(FName, stk, size - 1000H - LoadAdr, dcount, rdatasize, gsize)
    юеякх kos хкх obj рнцдю
      WriteKOS(FName, Align(stk, 4), size, dcount, gsize, obj)
    юеякх elf рнцдю
      WriteELF(FName, size - LoadAdr, temp, gsize)
    йнмеж
  йнмеж FixLabels;

опнжедспю OutStringZ(str: люяяхб хг яхлб);
        оепел i: жекне;
        мювюкн
          New;
          current.clen := LENGTH(str);
          дкъ i := 0 дн current.clen - 1 декюрэ
                Code[ccount] := str[i];
                дна(ccount)
          йнмеж;
          Code[ccount] := 0X;
          дна(ccount);
          дна(current.clen)
        йнмеж OutStringZ;

опнжедспю Epilog*(gsize: жекне; FName: люяяхб хг яхлб; stk: жекне);
        оепел i, glob: жекне;
        мювюкн
          glob := 0;
          gsize := Align(gsize, 4) + 4;
          COPY(FName, OutFile);
          Labels[RTABLE] := -dcount;
          dataint(recarray[0]);
          дкъ i := 1 дн reccount декюрэ
                dataint(recarray[i])
          йнмеж;
          current := start;
          еякх con хкх gui хкх dll рнцдю
                PushInt(LoadLibrary);
                PushInt(GetProcAddress);
                OutCode("5859FF31FF3054")
          юеякх elf рнцдю
                OutCode("6800000000");
                glob := current.cmd;
          юеякх kos хкх obj рнцдю
                OutByte(54H)
          йнмеж;
          GlobalAdr(0);
          PushConst(ASR(gsize, 2));
          PushInt(RTABLE);
          PushInt(SELFNAME);
          CallRTL(_init);
          current := asmlist.ЯКЕДСЧЫ(РСоСМЙРюЯЛ);
          еякх dll рнцдю
                OutCode("B801000000C9C20C00")
          йнмеж;
          еякх obj рнцдю
                OutCode("B801000000C9C20400")
          йнмеж;
          OutCode("EB05");
          Label(ASSRT);
          CallRTL(_assrt);
          OutCode("EB09");
          Label(HALT);
          OutCode("6A006A00");
          CallRTL(_assrt);
          OutCode("6A00");
          CallRTL(_halt);
          OutByte(90H);
          еякх obj рнцдю
                Label(Exports);
                CmdN(szSTART); CmdN(START);
                CmdN(szversion); OutInt(stk);
                дкъ i := 0 дн kosexpcount - 1 декюрэ
                  CmdN(kosexp[i].NameLabel); CmdN(kosexp[i].Adr)
                йнмеж;
                OutInt(0);
                Label(szSTART); OutStringZ("START");
                Label(szversion); OutStringZ("version");
                дкъ i := 0 дн kosexpcount - 1 декюрэ
                  Label(kosexp[i].NameLabel);
                  OutStringZ(kosexp[i].Name.ХЛЪ)
                йнмеж
          йнмеж;
          FixLabels(FName, stk, gsize, glob)
        йнмеж Epilog;

йнмеж ЛНДюЯЛ86_32.
