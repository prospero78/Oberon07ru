(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
  *)

лндскэ ЛНДсРХКЭ;

хлонпр mSys := SYSTEM,
    API,
    ЛйНМЯР := ЛНДйНМЯРЮМРШ,
    ЛрХОШ := ЛНДрХОШ,
    ЛтЮИК := ЛНДтЮИК;

оепел

  Params: люяяхб ЛйНМЯР.ЛЮЙЯ_ОЮПЮЛ, 2 хг INTEGER;
  hConsoleOutput, hConsoleInput, ParamCount*, Line*, Unit*: INTEGER;
  win, kos, lnx: BOOLEAN;
  тЮИК_ХЛЪ:ЛрХОШ.РяРПНЙЮ;

опнжедспю яРПНЙЮ_оЕВЮРЭ*(str: люяяхб хг CHAR);
   оепел
    s: ЛрХОШ.РяРПНЙЮ; n: INTEGER;
  мювюкн
    еякх win хкх lnx рнцдю
      n := ЛтЮИК.тЮИК_гЮОХЯЮРЭ(hConsoleOutput, mSys.ADR(str), LENGTH(str))
    юеякх kos рнцдю
      API.DebugMsg(mSys.ADR(str), 0)
    йнмеж
  йнмеж яРПНЙЮ_оЕВЮРЭ;

опнжедспю CharC*(x: CHAR);
   оепел res: INTEGER;
  мювюкн
    еякх win хкх lnx рнцдю
      res := ЛтЮИК.тЮИК_гЮОХЯЮРЭ(hConsoleOutput, mSys.ADR(x), 1)
    юеякх kos рнцдю
      API.DebugMsg(mSys.ADR(x), 0)
    йнмеж
  йнмеж CharC;

опнжедспю Int*(x: INTEGER);
   оепел i: INTEGER; buf: люяяхб 11 хг INTEGER;
  мювюкн
    i := 0;
    онбрнпърэ
      buf[i] := x MOD 10;
      x := x DIV 10;
      INC(i)
    онйюме x = 0;
    онбрнпърэ
      DEC(i);
      CharC(CHR(buf[i] + ORD("0")))
    онйюме i = 0
  йнмеж Int;

опнжедспю Ln*;
  мювюкн
    CharC(0DX);
    CharC(0AX)
  йнмеж Ln;

опнжедспю бПЕЛЪ_гЮРПЮВЕМН*;
   оепел
      sec, dsec: INTEGER;
   мювюкн
      яРПНЙЮ_оЕВЮРЭ("гЮРПЮВЕМН БПЕЛЕМХ: ");
      API.Time(sec, dsec);
      sec := sec - API.sec;
      dsec := dsec - API.dsec;
      dsec := dsec + sec * 100;
      Int(dsec DIV 100); CharC(".");
      dsec := dsec MOD 100;
      еякх dsec < 10 рнцдю
         Int(0)
      йнмеж;
      Int(dsec);
      яРПНЙЮ_оЕВЮРЭ(" ЯЕЙ."); Ln
   йнмеж бПЕЛЪ_гЮРПЮВЕМН;

опнжедспю гЮЙНМВХРЭ*(n: INTEGER);
  мювюкн
    бПЕЛЪ_гЮРПЮВЕМН;
    API.ExitProcess(n)
  йнмеж гЮЙНМВХРЭ;

опнжедспю ErrMsg*(code: INTEGER);
   мювюкн
    яРПНЙЮ_оЕВЮРЭ("нЬХАЙЮ: "); Int(code); Ln;
    (* ЛнЬ.яННАЫ(code); *)
  йнмеж ErrMsg;

опнжедспю MemErr*(err: BOOLEAN);
  мювюкн
    еякх err рнцдю
      ErrMsg(72);
      гЮЙНМВХРЭ(1)
    йнмеж
  йнмеж MemErr;

опнжедспю тЮИКхЛЪ_сЯР*(ХЛЪ_: ЛрХОШ.РяРПНЙЮ);
   мювюкн
      тЮИК_ХЛЪ := ХЛЪ_
   йнмеж тЮИКхЛЪ_сЯР;

опнжедспю тЮИК_вХРЮРЭ*(F, Buffer, Count: INTEGER): INTEGER;
  оепел res: INTEGER;
  мювюкн
    API.ReadFile(F, Buffer, Count, mSys.ADR(res), 0)
    бепмсрэ res
  йнмеж тЮИК_вХРЮРЭ;

опнжедспю тЮИКпЮГЛЕП_оНКСВ*(F: INTEGER): INTEGER;
      бепмсрэ API.FileSize(F)
   йнмеж тЮИКпЮГЛЕП_оНКСВ;

опнжедспю тЮИК_нРЙПШРЭ*(FName: люяяхб хг CHAR; Mode: INTEGER): INTEGER;
  оепел ofstr: API.OFSTRUCT; res: INTEGER; memerr: BOOLEAN;
  мювюкн
    еякх win рнцдю
      res := API.OpenFile(mSys.ADR(FName), ofstr, Mode);
      еякх res = -1 рнцдю
        res := 0
      йнмеж
    юеякх kos рнцдю
      res := API.kos_OCFile(FName, 5, memerr);
      MemErr(memerr)
    юеякх lnx рнцдю
      res := API.lnx_OpenFile(FName)
    йнмеж
    бепмсрэ res
  йнмеж тЮИК_нРЙПШРЭ;

опнжедспю IsInf*(x_: LONGREAL): BOOLEAN;
  оепел
    h, l: SET;
  мювюкн
    mSys.GET(mSys.ADR(x_), l);
    mSys.GET(mSys.ADR(x_) + 4, h);
    бепмсрэ (h * {20..30} = {20..30}) & (h * {0..19} = {}) & (l * {0..31} = {})
  йнмеж IsInf;

опнжедспю яХБНК_оНКСВ(adr_: INTEGER): CHAR;
  оепел
   res: CHAR;
  мювюкн
    mSys.GET(adr_, res)
    бепмсрэ res
  йнмеж яХБНК_оНКСВ;

опнжедспю ParamParse(count: INTEGER);
   оепел c: CHAR; cond, p: INTEGER;

   опнжедспю ChangeCond(A, B, C: INTEGER);
      мювюкн
         cond := C;
         бшанп c хг
            |0X: cond := 6
            |1X..20X: cond := A
            |22X: cond := B
         хмюве
         йнмеж
      йнмеж ChangeCond;

   мювюкн
      p := API.GetCommandLine();
      cond := 0;
      онйю (count < ЛйНМЯР.ЛЮЙЯ_ОЮПЮЛ) & (cond # 6) декюрэ
         c := яХБНК_оНКСВ(p);
         бшанп cond хг
            |0: ChangeCond(0, 4, 1); еякх cond = 1 рнцдю Params[count, 0] := p йнмеж
            |4: ChangeCond(5, 0, 5); еякх cond = 5 рнцдю Params[count, 0] := p йнмеж
            |1: ChangeCond(0, 3, 1); еякх cond IN {0, 6} рнцдю Params[count, 1] := p - 1; INC(count) йнмеж
            |3, 5: ChangeCond(cond, 1, cond); еякх cond = 6 рнцдю Params[count, 1] := p - 1; INC(count) йнмеж
         хмюве
         йнмеж;
         INC(p)
      йнмеж;
      ParamCount := count - 1
   йнмеж ParamParse;

опнжедспю ParamStr*(оеп str: люяяхб хг CHAR; n: INTEGER);
  оепел
   i, j, len: INTEGER; c: CHAR;
  мювюкн
    j := 0;
    еякх n <= ParamCount рнцдю
      len := LEN(str) - 1;
      i := Params[n, 0];
      онйю (j < len) & (i <= Params[n, 1]) декюрэ
        c := яХБНК_оНКСВ(i);
        еякх c # 22X рнцдю
          str[j] := c;
          INC(j)
        йнмеж;
        INC(i)
      йнмеж
    йнмеж;
    str[j] := 0X
  йнмеж ParamStr;

опнжедспю оЮЛЪРЭ_оНКСВ*(n: INTEGER): INTEGER;
      бепмсрэ API.Alloc(64, n)
  йнмеж оЮЛЪРЭ_оНКСВ;

опнжедспю ErrMsgPos*(line, col, code: INTEGER);
  оепел
    s: ЛрХОШ.РяРПНЙЮ;
  мювюкн
    яРПНЙЮ_оЕВЮРЭ("НЬХАЙЮ: "); Int(code); Ln;
    яРПНЙЮ_оЕВЮРЭ("ТЮИК:   "); яРПНЙЮ_оЕВЮРЭ(тЮИК_ХЛЪ); Ln;
    яРПНЙЮ_оЕВЮРЭ("ЯРПНЙЮ: "); Int(line); Ln;
    яРПНЙЮ_оЕВЮРЭ("ОНГ:    "); Int(col); Ln;
  йнмеж ErrMsgPos;

опнжедспю UnitLine*(newUnit, newLine: INTEGER);
  мювюкн
    Unit := newUnit;
    Line := newLine
  йнмеж UnitLine;

опнжедспю min*(a, b: INTEGER): INTEGER;
  оепел Res: INTEGER;
  мювюкн
    еякх a < b рнцдю
      Res := a
    хмюве
      Res := b
    йнмеж
    бепмсрэ Res
  йнмеж min;

опнжедспю Align*(n: INTEGER): INTEGER;
    бепмсрэ (4 - n MOD 4) MOD 4
  йнмеж Align;

опнжедспю CAP(x: CHAR): CHAR;
  мювюкн
    еякх (x >= "a") & (x <= "z") рнцдю
      x := CHR(ORD(x) - 32)
    йнмеж
    бепмсрэ x
  йнмеж CAP;

опнжедспю streq*(a, b: люяяхб хг CHAR): BOOLEAN;
  оепел i: INTEGER;
  мювюкн
    i := -1;
    онбрнпърэ
      INC(i)
    онйюме (CAP(a[i]) # CAP(b[i])) хкх (a[i] = 0X) хкх (b[i] = 0X)
    бепмсрэ a[i] = b[i]
  йнмеж streq;

опнжедспю concat*(L, R: люяяхб хг CHAR; оеп Res: люяяхб хг CHAR);
  оепел i, j: INTEGER;
  мювюкн
    i := 0;
    онйю (L[i] # 0X) & (i - 1 < LEN(Res)) декюрэ
      Res[i] := L[i];
      INC(i)
    йнмеж;
    j := 0;
    онйю (R[j] # 0X) & (j + i - 1 < LEN(Res)) декюрэ
      Res[j + i] := R[j];
      INC(j)
    йнмеж;
    Res[j + i] := 0X
  йнмеж concat;

опнжедспю Push*(this: ЛрХОШ.РСяОХЯНЙ; item: ЛрХОШ.РСоСМЙР);
  мювюкн
    еякх this.ЯВЕРВХЙ = 0 рнцдю
      this.ОПЕДШДСЫ := item;
      item.ОПЕДШДСЫ := осярн
    хмюве
      this.ЯКЕДСЧЫ.ЯКЕДСЧЫ := item;
      item.ОПЕДШДСЫ := this.ЯКЕДСЧЫ
    йнмеж;
    INC(this.ЯВЕРВХЙ);
    this.ЯКЕДСЧЫ := item;
    item.ЯКЕДСЧЫ := осярн
  йнмеж Push;

опнжедспю Insert*(this: ЛрХОШ.РСяОХЯНЙ; item, prev: ЛрХОШ.РСоСМЙР);
  мювюкн
    еякх prev # this.ЯКЕДСЧЫ рнцдю
      item.ЯКЕДСЧЫ := prev.ЯКЕДСЧЫ;
      item.ОПЕДШДСЫ := prev;
      prev.ЯКЕДСЧЫ := item;
      item.ЯКЕДСЧЫ.ОПЕДШДСЫ := item;
      INC(this.ЯВЕРВХЙ)
    хмюве
      Push(this, item)
    йнмеж
  йнмеж Insert;

опнжедспю Clear*(this: ЛрХОШ.РСяОХЯНЙ);
  мювюкн
    this.ОПЕДШДСЫ := осярн;
    this.ЯКЕДСЧЫ := осярн;
    this.ЯВЕРВХЙ := 0
  йнмеж Clear;

опнжедспю яОХЯНЙ_яНГДЮРЭ*(): ЛрХОШ.РСяОХЯНЙ;
  оепел
    nov: ЛрХОШ.РСяОХЯНЙ;
  мювюкн
    NEW(nov)
    бепмсрэ nov
  йнмеж яОХЯНЙ_яНГДЮРЭ;

опнжедспю Revers(оеп str: ЛрХОШ.РяРПНЙЮ);
  оепел a, b: INTEGER; c: CHAR;
  мювюкн
    a := 0;
    b := LENGTH(str) - 1;
    онйю a < b декюрэ
      c := str[a];
      str[a] := str[b];
      str[b] := c;
      INC(a);
      DEC(b)
    йнмеж
  йнмеж Revers;

опнжедспю Split*(FName: ЛрХОШ.РяРПНЙЮ; оеп Path, Name, Ext: ЛрХОШ.РяРПНЙЮ);
   оепел
   i, j, k: INTEGER;
   мювюкн
      i := LENGTH(FName) - 1;
      j := 0;
      онйю (i >= 0) & (FName[i] # API.Slash) декюрэ
         Name[j] := FName[i];
         DEC(i);
         INC(j)
      йнмеж;
      Name[j] := 0X;
      Revers(Name);
      j := 0;
      k := LENGTH(Name) - 1;
      онйю (k >= 0) & (Name[k] # ".") декюрэ
         Ext[j] := Name[k];
         DEC(k);
         INC(j)
      йнмеж;
      еякх k >= 0 рнцдю
         Name[k] := 0X;
         Ext[j] := ".";
         INC(j)
      хмюве
         j := 0
      йнмеж;
      Ext[j] := 0X;
      Revers(Ext);
      j := i;
      дкъ i := 0 дн j декюрэ
         Path[i] := FName[i]
      йнмеж;
      Path[j + 1] := 0X
   йнмеж Split;

опнжедспю PChar*(s: люяяхб хг CHAR): INTEGER;
    бепмсрэ mSys.ADR(s)
  йнмеж PChar;

опнжедспю LinuxParam;
  оепел p, i, str: INTEGER; c: CHAR;
  мювюкн
    p := API.GetCommandLine();
    mSys.GET(p, ParamCount);
    mSys.GET(p + 4, p);
    дкъ i := 0 дн ParamCount - 1 декюрэ
      mSys.GET(p + i * 4, str);
      Params[i, 0] := str;
      онбрнпърэ
        mSys.GET(str, c);
        INC(str)
      онйюме c = 0X;
      Params[i, 1] := str - 1
    йнмеж;
    DEC(ParamCount)
  йнмеж LinuxParam;

опнжедспю CreateF*(FName: люяяхб хг CHAR): INTEGER;
  оепел res: INTEGER; memerr: BOOLEAN;
  мювюкн
    еякх win рнцдю
      res := API.CreateFile(mSys.ADR(FName), 0C0000000H, 0, 0, 2, 80H, 0);
      еякх res = -1 рнцдю
        res := 0
      йнмеж
    юеякх kos рнцдю
      res := API.kos_OCFile(FName, 2, memerr);
      MemErr(memerr)
    юеякх lnx рнцдю
      res := API.lnx_CreateFile(FName)
    йнмеж
    бепмсрэ res
  йнмеж CreateF;

опнжедспю Init;
  оепел
   p, count: INTEGER;

    опнжедспю last(оеп p: INTEGER);
    мювюкн
      онйю яХБНК_оНКСВ(p) # 0X декюрэ
         INC(p)
      йнмеж;
      DEC(p)
    йнмеж last;

  мювюкн
    еякх win рнцдю
      hConsoleOutput := API.GetStdHandle(-11);
      ParamParse(0)
    юеякх kos рнцдю
      ParamParse(1);
      Params[0, 0] := API.GetName();
      Params[0, 1] := Params[0, 0];
      last(Params[0, 1])
    юеякх lnx рнцдю
      hConsoleOutput := API.GetStdHandle(-11);
      LinuxParam
    йнмеж
  йнмеж Init;

мювюкн
  win := API.OS = "WIN";
  kos := API.OS = "KOS";
  lnx := API.OS = "LNX";
  Init
йнмеж ЛНДсРХКЭ.
