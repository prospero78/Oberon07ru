(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
  *)

МОДУЛЬ модУтиль;

ИМПОРТ mSys := SYSTEM,
    API,
    мКонст := модКонстанты,
    мТипы := модТипы,
    мФайл := модФайл;

ПЕРЕМ

  Params: МАССИВ мКонст.макс_парам, 2 ИЗ INTEGER;
  цКонсольВывод, hConsoleInput, ParamCount*, Line*, Unit*: INTEGER;
  win, kos, lnx: BOOLEAN;
  Файл_имя:мТипы.тСтрока;

ПРОЦЕДУРА Строка_Печать*(str: МАССИВ ИЗ CHAR);
   ПЕРЕМ
    s: мТипы.тСтрока; n: INTEGER;
  НАЧАЛО
    ЕСЛИ win ИЛИ lnx ТОГДА
      n := мФайл.Файл_Записать(цКонсольВывод, mSys.ADR(str), LENGTH(str))
    АЕСЛИ kos ТОГДА
      API.DebugMsg(mSys.ADR(str), 0)
    КОНЕЦ
  КОНЕЦ Строка_Печать;

ПРОЦЕДУРА CharC*(x: CHAR);
   ПЕРЕМ res: INTEGER;
  НАЧАЛО
    ЕСЛИ win ИЛИ lnx ТОГДА
      res := мФайл.Файл_Записать(цКонсольВывод, mSys.ADR(x), 1)
    АЕСЛИ kos ТОГДА
      API.DebugMsg(mSys.ADR(x), 0)
    КОНЕЦ
  КОНЕЦ CharC;

ПРОЦЕДУРА Int*(x: INTEGER);
   ПЕРЕМ i: INTEGER; buf: МАССИВ 11 ИЗ INTEGER;
  НАЧАЛО
    i := 0;
    ПОВТОРЯТЬ
      buf[i] := x MOD 10;
      x := x DIV 10;
      INC(i)
    ПОКАНЕ x = 0;
    ПОВТОРЯТЬ
      DEC(i);
      CharC(CHR(buf[i] + ORD("0")))
    ПОКАНЕ i = 0
  КОНЕЦ Int;

ПРОЦЕДУРА Ln*;
  НАЧАЛО
    CharC(0DX);
    CharC(0AX)
  КОНЕЦ Ln;

ПРОЦЕДУРА Время_Затрачено*;
   ПЕРЕМ
      sec, dsec: INTEGER;
   НАЧАЛО
      Строка_Печать("Затрачено времени: ");
      API.Time(sec, dsec);
      sec := sec - API.sec;
      dsec := dsec - API.dsec;
      dsec := dsec + sec * 100;
      Int(dsec DIV 100); CharC(".");
      dsec := dsec MOD 100;
      ЕСЛИ dsec < 10 ТОГДА
         Int(0)
      КОНЕЦ;
      Int(dsec);
      Строка_Печать(" сек."); Ln
   КОНЕЦ Время_Затрачено;

ПРОЦЕДУРА Закончить*(n: INTEGER);
  НАЧАЛО
    Время_Затрачено;
    API.ExitProcess(n)
  КОНЕЦ Закончить;

ПРОЦЕДУРА ErrMsg*(code: INTEGER);
   НАЧАЛО
    Строка_Печать("Ошибка: "); Int(code); Ln;
    (* мОш.Сообщ(code); *)
  КОНЕЦ ErrMsg;

ПРОЦЕДУРА MemErr*(err: BOOLEAN);
  НАЧАЛО
    ЕСЛИ err ТОГДА
      ErrMsg(72);
      Закончить(1)
    КОНЕЦ
  КОНЕЦ MemErr;

ПРОЦЕДУРА ФайлИмя_Уст*(имя_: мТипы.тСтрока);
   НАЧАЛО
      Файл_имя := имя_
   КОНЕЦ ФайлИмя_Уст;

ПРОЦЕДУРА Файл_Читать*(F, Buffer, Count: INTEGER): INTEGER;
  ПЕРЕМ res: INTEGER;
  НАЧАЛО
    API.ReadFile(F, Buffer, Count, mSys.ADR(res), 0)
    ВЕРНУТЬ res
  КОНЕЦ Файл_Читать;

ПРОЦЕДУРА ФайлРазмер_Получ*(F: INTEGER): INTEGER;
      ВЕРНУТЬ API.FileSize(F)
   КОНЕЦ ФайлРазмер_Получ;

ПРОЦЕДУРА Файл_Открыть*(FName: МАССИВ ИЗ CHAR; Mode: INTEGER): INTEGER;
  ПЕРЕМ ofstr: API.OFSTRUCT; res: INTEGER; memerr: BOOLEAN;
  НАЧАЛО
    ЕСЛИ win ТОГДА
      res := API.OpenFile(mSys.ADR(FName), ofstr, Mode);
      ЕСЛИ res = -1 ТОГДА
        res := 0
      КОНЕЦ
    АЕСЛИ kos ТОГДА
      res := API.kos_OCFile(FName, 5, memerr);
      MemErr(memerr)
    АЕСЛИ lnx ТОГДА
      res := API.lnx_OpenFile(FName)
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА IsInf*(x_: LONGREAL): BOOLEAN;
  ПЕРЕМ
    h, l: SET;
  НАЧАЛО
    mSys.GET(mSys.ADR(x_), l);
    mSys.GET(mSys.ADR(x_) + 4, h);
    ВЕРНУТЬ (h * {20..30} = {20..30}) & (h * {0..19} = {}) & (l * {0..31} = {})
  КОНЕЦ IsInf;

ПРОЦЕДУРА Сивол_Получ(adr_: INTEGER): CHAR;
  ПЕРЕМ
   res: CHAR;
  НАЧАЛО
    mSys.GET(adr_, res)
    ВЕРНУТЬ res
  КОНЕЦ Сивол_Получ;

ПРОЦЕДУРА ParamParse(count: INTEGER);
   ПЕРЕМ c: CHAR; cond, p: INTEGER;

   ПРОЦЕДУРА ChangeCond(A, B, C: INTEGER);
      НАЧАЛО
         cond := C;
         ВЫБОР c ИЗ
            |0X: cond := 6
            |1X..20X: cond := A
            |22X: cond := B
         ИНАЧЕ
         КОНЕЦ
      КОНЕЦ ChangeCond;

   НАЧАЛО
      p := API.GetCommandLine();
      cond := 0;
      ПОКА (count < мКонст.макс_парам) & (cond # 6) ДЕЛАТЬ
         c := Сивол_Получ(p);
         ВЫБОР cond ИЗ
            |0: ChangeCond(0, 4, 1); ЕСЛИ cond = 1 ТОГДА Params[count, 0] := p КОНЕЦ
            |4: ChangeCond(5, 0, 5); ЕСЛИ cond = 5 ТОГДА Params[count, 0] := p КОНЕЦ
            |1: ChangeCond(0, 3, 1); ЕСЛИ cond IN {0, 6} ТОГДА Params[count, 1] := p - 1; INC(count) КОНЕЦ
            |3, 5: ChangeCond(cond, 1, cond); ЕСЛИ cond = 6 ТОГДА Params[count, 1] := p - 1; INC(count) КОНЕЦ
         ИНАЧЕ
         КОНЕЦ;
         INC(p)
      КОНЕЦ;
      ParamCount := count - 1
   КОНЕЦ ParamParse;

ПРОЦЕДУРА ParamStr*(ПЕР str: МАССИВ ИЗ CHAR; n: INTEGER);
  ПЕРЕМ
   i, j, len: INTEGER; c: CHAR;
  НАЧАЛО
    j := 0;
    ЕСЛИ n <= ParamCount ТОГДА
      len := LEN(str) - 1;
      i := Params[n, 0];
      ПОКА (j < len) & (i <= Params[n, 1]) ДЕЛАТЬ
        c := Сивол_Получ(i);
        ЕСЛИ c # 22X ТОГДА
          str[j] := c;
          INC(j)
        КОНЕЦ;
        INC(i)
      КОНЕЦ
    КОНЕЦ;
    str[j] := 0X
  КОНЕЦ ParamStr;

ПРОЦЕДУРА Память_Получ*(n: INTEGER): INTEGER;
      ВЕРНУТЬ API.Alloc(64, n)
  КОНЕЦ Память_Получ;

ПРОЦЕДУРА ErrMsgPos*(line, col, code: INTEGER);
  ПЕРЕМ
    s: мТипы.тСтрока;
  НАЧАЛО
    Строка_Печать("ошибка: "); Int(code); Ln;
    Строка_Печать("файл:   "); Строка_Печать(Файл_имя); Ln;
    Строка_Печать("строка: "); Int(line); Ln;
    Строка_Печать("поз:    "); Int(col); Ln;
  КОНЕЦ ErrMsgPos;

ПРОЦЕДУРА UnitLine*(newUnit, newLine: INTEGER);
  НАЧАЛО
    Unit := newUnit;
    Line := newLine
  КОНЕЦ UnitLine;

ПРОЦЕДУРА min*(a, b: INTEGER): INTEGER;
  ПЕРЕМ Res: INTEGER;
  НАЧАЛО
    ЕСЛИ a < b ТОГДА
      Res := a
    ИНАЧЕ
      Res := b
    КОНЕЦ
    ВЕРНУТЬ Res
  КОНЕЦ min;

ПРОЦЕДУРА Align*(n: INTEGER): INTEGER;
    ВЕРНУТЬ (4 - n MOD 4) MOD 4
  КОНЕЦ Align;

ПРОЦЕДУРА CAP(x: CHAR): CHAR;
  НАЧАЛО
    ЕСЛИ (x >= "a") & (x <= "z") ТОГДА
      x := CHR(ORD(x) - 32)
    КОНЕЦ
    ВЕРНУТЬ x
  КОНЕЦ CAP;

ПРОЦЕДУРА streq*(a, b: МАССИВ ИЗ CHAR): BOOLEAN;
  ПЕРЕМ i: INTEGER;
  НАЧАЛО
    i := -1;
    ПОВТОРЯТЬ
      INC(i)
    ПОКАНЕ (CAP(a[i]) # CAP(b[i])) ИЛИ (a[i] = 0X) ИЛИ (b[i] = 0X)
    ВЕРНУТЬ a[i] = b[i]
  КОНЕЦ streq;

ПРОЦЕДУРА concat*(L, R: МАССИВ ИЗ CHAR; ПЕР Res: МАССИВ ИЗ CHAR);
  ПЕРЕМ i, j: INTEGER;
  НАЧАЛО
    i := 0;
    ПОКА (L[i] # 0X) & (i - 1 < LEN(Res)) ДЕЛАТЬ
      Res[i] := L[i];
      INC(i)
    КОНЕЦ;
    j := 0;
    ПОКА (R[j] # 0X) & (j + i - 1 < LEN(Res)) ДЕЛАТЬ
      Res[j + i] := R[j];
      INC(j)
    КОНЕЦ;
    Res[j + i] := 0X
  КОНЕЦ concat;

ПРОЦЕДУРА Push*(this: мТипы.туСписок; item: мТипы.туПункт);
  НАЧАЛО
    ЕСЛИ this.счетчик = 0 ТОГДА
      this.предыдущ := item;
      item.предыдущ := ПУСТО
    ИНАЧЕ
      this.следующ.следующ := item;
      item.предыдущ := this.следующ
    КОНЕЦ;
    INC(this.счетчик);
    this.следующ := item;
    item.следующ := ПУСТО
  КОНЕЦ Push;

ПРОЦЕДУРА Insert*(this: мТипы.туСписок; item, prev: мТипы.туПункт);
  НАЧАЛО
    ЕСЛИ prev # this.следующ ТОГДА
      item.следующ := prev.следующ;
      item.предыдущ := prev;
      prev.следующ := item;
      item.следующ.предыдущ := item;
      INC(this.счетчик)
    ИНАЧЕ
      Push(this, item)
    КОНЕЦ
  КОНЕЦ Insert;

ПРОЦЕДУРА Clear*(this: мТипы.туСписок);
  НАЧАЛО
    this.предыдущ := ПУСТО;
    this.следующ := ПУСТО;
    this.счетчик := 0
  КОНЕЦ Clear;

ПРОЦЕДУРА Список_Создать*(): мТипы.туСписок;
  ПЕРЕМ
    nov: мТипы.туСписок;
  НАЧАЛО
    NEW(nov)
    ВЕРНУТЬ nov
  КОНЕЦ Список_Создать;

ПРОЦЕДУРА Revers(ПЕР str: мТипы.тСтрока);
  ПЕРЕМ a, b: INTEGER; c: CHAR;
  НАЧАЛО
    a := 0;
    b := LENGTH(str) - 1;
    ПОКА a < b ДЕЛАТЬ
      c := str[a];
      str[a] := str[b];
      str[b] := c;
      INC(a);
      DEC(b)
    КОНЕЦ
  КОНЕЦ Revers;

ПРОЦЕДУРА Split*(FName: мТипы.тСтрока; ПЕР Path, Name, Ext: мТипы.тСтрока);
   ПЕРЕМ
   i, j, k: INTEGER;
   НАЧАЛО
      i := LENGTH(FName) - 1;
      j := 0;
      ПОКА (i >= 0) & (FName[i] # API.Slash) ДЕЛАТЬ
         Name[j] := FName[i];
         DEC(i);
         INC(j)
      КОНЕЦ;
      Name[j] := 0X;
      Revers(Name);
      j := 0;
      k := LENGTH(Name) - 1;
      ПОКА (k >= 0) & (Name[k] # ".") ДЕЛАТЬ
         Ext[j] := Name[k];
         DEC(k);
         INC(j)
      КОНЕЦ;
      ЕСЛИ k >= 0 ТОГДА
         Name[k] := 0X;
         Ext[j] := ".";
         INC(j)
      ИНАЧЕ
         j := 0
      КОНЕЦ;
      Ext[j] := 0X;
      Revers(Ext);
      j := i;
      ДЛЯ i := 0 ДО j ДЕЛАТЬ
         Path[i] := FName[i]
      КОНЕЦ;
      Path[j + 1] := 0X
   КОНЕЦ Split;

ПРОЦЕДУРА PChar*(s: МАССИВ ИЗ CHAR): INTEGER;
    ВЕРНУТЬ mSys.ADR(s)
  КОНЕЦ PChar;

ПРОЦЕДУРА LinuxParam;
  ПЕРЕМ p, i, str: INTEGER; c: CHAR;
  НАЧАЛО
    p := API.GetCommandLine();
    mSys.GET(p, ParamCount);
    mSys.GET(p + 4, p);
    ДЛЯ i := 0 ДО ParamCount - 1 ДЕЛАТЬ
      mSys.GET(p + i * 4, str);
      Params[i, 0] := str;
      ПОВТОРЯТЬ
        mSys.GET(str, c);
        INC(str)
      ПОКАНЕ c = 0X;
      Params[i, 1] := str - 1
    КОНЕЦ;
    DEC(ParamCount)
  КОНЕЦ LinuxParam;

ПРОЦЕДУРА Файл_Создать*(FName: МАССИВ ИЗ CHAR): INTEGER;
  ПЕРЕМ
     res: INTEGER; memerr: BOOLEAN;
  НАЧАЛО
    ЕСЛИ win ТОГДА
      res := API.CreateFile(mSys.ADR(FName), 0C0000000H, 0, 0, 2, 80H, 0);
      ЕСЛИ res = -1 ТОГДА
        res := 0
      КОНЕЦ
    АЕСЛИ kos ТОГДА
      res := API.kos_OCFile(FName, 2, memerr);
      MemErr(memerr)
    АЕСЛИ lnx ТОГДА
      res := API.lnx_CreateFile(FName)
    КОНЕЦ
    ВЕРНУТЬ res
  КОНЕЦ Файл_Создать;

ПРОЦЕДУРА Настроить;
   ПЕРЕМ
      p, count: INTEGER;

    ПРОЦЕДУРА last(ПЕР p: INTEGER);
      НАЧАЛО
         ПОКА Сивол_Получ(p) # 0X ДЕЛАТЬ
            INC(p)
         КОНЕЦ;
           DEC(p)
      КОНЕЦ last;

  НАЧАЛО
    ЕСЛИ win ТОГДА
      цКонсольВывод := API.GetStdHandle(-11);
      ParamParse(0)
    АЕСЛИ kos ТОГДА
      ParamParse(1);
      Params[0, 0] := API.GetName();
      Params[0, 1] := Params[0, 0];
      last(Params[0, 1])
    АЕСЛИ lnx ТОГДА
      цКонсольВывод := API.GetStdHandle(-11);
      LinuxParam
    КОНЕЦ
  КОНЕЦ Настроить;

НАЧАЛО
  win := API.OS = "WIN";
  kos := API.OS = "KOS";
  lnx := API.OS = "LNX";
  Настроить
КОНЕЦ модУтиль.
