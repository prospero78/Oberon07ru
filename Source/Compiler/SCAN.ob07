МОДУЛЬ SCAN;

(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
    *)

ИМПОРТ мУтиль := UTILS,
    sys := SYSTEM,
    мКонст := modConstante,
    мСтр := modString,
    мОш := modError,
    мФайл := modFile;

ТИПЫ
  туУзел* = УКАЗАТЕЛЬ НА ЗАПИСЬ
    узел_лев, узел_прав: туУзел;
    лекс_тип: ЦЕЛОЕ;
    имя_узла*: мСтр.тСтрока
  КОНЕЦ;

  туСканер* = УКАЗАТЕЛЬ НА ЗАПИСЬ
    File, ccol, cline, счетчик, col, строка, лекс_тип, цЗнач: ЦЕЛОЕ;
    ch, симв: СИМВ;
    лексема_стр: мСтр.тСтрока;
    двЗнач: ДЛИНВЕЩ;
    узел: туУзел;
    buf, буфер_поз: ЦЕЛОЕ;
    CR, UTF8: БУЛЕВО
  КОНЕЦ;

ПЕРЕМ
  лекс_глоб: мСтр.тСтрока;
  File, ccol, cline, count*, позиц_глоб*, строка_ном*, лекс_тип*, vINT*: ЦЕЛОЕ;
  vFLT*: ДЛИНВЕЩ;
  id*: туУзел;
  ch, vCHX*: СИМВ;
  buf, bufpos: ЦЕЛОЕ;
  CR, UTF8: БУЛЕВО;
  Nodes: МАССИВ 256 ИЗ туУзел;
  _START*, _version*: туУзел;

ПРОЦЕДУРА Узел_Добавить*(Name: мСтр.тСтрока): туУзел;
    ПЕРЕМ cur, res: туУзел;

      ПРОЦЕДУРА NewNode(Right: БУЛЕВО);
      НАЧАЛО
        НОВ(res);
        мОш.MemErr(res = ПУСТО);
        res.имя_узла := Name;
        res.лекс_тип := мКонст._лекИмя;
        res.узел_лев := ПУСТО;
        res.узел_прав := ПУСТО;
        ЕСЛИ Right ТОГДА
          cur.узел_прав := res
        ИНАЧЕ
          cur.узел_лев := res
        КОНЕЦ
      КОНЕЦ NewNode;

    НАЧАЛО
      res := ПУСТО;
      cur := Nodes[ORD(Name[0])];
      ПОВТОРЯТЬ
        ЕСЛИ Name > cur.имя_узла ТОГДА
          ЕСЛИ cur.узел_прав # ПУСТО ТОГДА
            cur := cur.узел_прав
          ИНАЧЕ
            NewNode(ИСТИНА)
          КОНЕЦ
        ИНЕСЛ Name < cur.имя_узла ТОГДА
          ЕСЛИ cur.узел_лев # ПУСТО ТОГДА
            cur := cur.узел_лев
          ИНАЧЕ
            NewNode(ЛОЖЬ)
          КОНЕЦ
        ИНАЧЕ
          res := cur
        КОНЕЦ
      СНОВА res # ПУСТО
      ВЕРНУТЬ res
    КОНЕЦ Узел_Добавить;

ПРОЦЕДУРА GetLexStr*(ПЕРЕМ L: мСтр.тСтрока);
    НАЧАЛО
      L := лекс_глоб
    КОНЕЦ GetLexStr;

ПРОЦЕДУРА Резерв_Сделать*(scanner: туСканер);
    НАЧАЛО
      scanner.File := File;
      scanner.ccol := ccol;
      scanner.cline := cline;
      scanner.ch := ch;
      scanner.лексема_стр := лекс_глоб;
      scanner.счетчик := count;
      scanner.col := позиц_глоб;
      scanner.строка := строка_ном;
      scanner.лекс_тип := лекс_тип;
      scanner.цЗнач := vINT;
      scanner.двЗнач := vFLT;
      scanner.симв := vCHX;
      scanner.buf := buf;
      scanner.буфер_поз := bufpos;
      scanner.CR := CR;
      scanner.UTF8 := UTF8
    КОНЕЦ Резерв_Сделать;

ПРОЦЕДУРА Резерв_Воостановить*(scanner: туСканер);
    НАЧАЛО
      File := scanner.File;
      ccol := scanner.ccol;
      cline := scanner.cline;
      ch := scanner.ch;
      лекс_глоб := scanner.лексема_стр;
      count := scanner.счетчик;
      позиц_глоб := scanner.col;
      строка_ном := scanner.строка;
      лекс_тип := scanner.лекс_тип;
      vINT := scanner.цЗнач;
      vFLT := scanner.двЗнач;
      vCHX := scanner.симв;
      buf := scanner.buf;
      bufpos := scanner.буфер_поз;
      CR := scanner.CR;
      UTF8 := scanner.UTF8
    КОНЕЦ Резерв_Воостановить;

ПРОЦЕДУРА Next;
    ПЕРЕМ
        cr: БУЛЕВО;
    НАЧАЛО
      cr := ЛОЖЬ;
      sys.GET(bufpos, ch);
      ДОБ(ccol);
      ВЫБРАТЬ ch ИЗ
      |0AX: ЕСЛИ ~CR ТОГДА ДОБ(cline) КОНЕЦ; ccol := 0
      |0DX: ДОБ(cline); ccol := 0; cr := ИСТИНА
      |09X: ВЫЧ(ccol); ccol := ccol + мКонст._Tab - (ccol - 1) MOD мКонст._Tab - 1
      |80X..0BFX: ЕСЛИ UTF8 ТОГДА ВЫЧ(ccol) КОНЕЦ
      ИНАЧЕ
      КОНЕЦ;
      CR := cr;
      ДОБ(bufpos)
    КОНЕЦ Next;

ПРОЦЕДУРА Файл_Прочитать*(FName: МАССИВ ИЗ СИМВ; ПЕРЕМ FHandle: ЦЕЛОЕ): БУЛЕВО;
    ПЕРЕМ n, size: ЦЕЛОЕ; c: СИМВ;
    НАЧАЛО
      File := мФайл.Открыть(FName, 0);
      FHandle := File;
      ЕСЛИ File # 0 ТОГДА
        CR := ЛОЖЬ;
        UTF8 := ЛОЖЬ;
        ccol := 0;
        cline := 1;
        ch := 0X;
        size := мФайл.Размер_Получ(File);
        buf := мУтиль.ПамятьНов_Получ(size + 1024);
        sys.PUT(buf + size, 0X);
        мОш.MemErr(buf = 0);
        n := мФайл.Читать(File, buf, size);
        мФайл.Закрыть(File);
        bufpos := buf;
        sys.GET(buf, c);
        ЕСЛИ c = 0EFX ТОГДА
          sys.GET(buf + 1, c);
          ЕСЛИ c = 0BBX ТОГДА
            sys.GET(buf + 2, c);
            ЕСЛИ c = 0BFX ТОГДА
              ДОБ(bufpos, 3);
              UTF8 := ИСТИНА
            КОНЕЦ
          КОНЕЦ
        КОНЕЦ;
        Next
      КОНЕЦ
      ВЕРНУТЬ (File # 0) & (n = size)
    КОНЕЦ Файл_Прочитать;

ПРОЦЕДУРА ЕслиПробел(ch: СИМВ): БУЛЕВО;
      ВЕРНУТЬ (ch <= 20X) & (ch > 0X)
    КОНЕЦ ЕслиПробел;

ПРОЦЕДУРА ЕслиСимвол(ch: СИМВ): БУЛЕВО;
    ПЕРЕМ
        en, ru: БУЛЕВО;
    НАЧАЛО
        en :=(ch >= "A") & (ch <= "Z") ИЛИ (ch >= "a") & (ch <= "z");
        ru :=(ch >= "А") & (ch <= "Я") ИЛИ (ch >= "а") & (ch <= "я");
      ВЕРНУТЬ  en ИЛИ ru ИЛИ (ch = "_")
    КОНЕЦ ЕслиСимвол;

ПРОЦЕДУРА ЕслиЦифра*(ch: СИМВ): БУЛЕВО;
      ВЕРНУТЬ (ch >= "0") & (ch <= "9")
    КОНЕЦ ЕслиЦифра;

ПРОЦЕДУРА Если16число*(ch: СИМВ): БУЛЕВО;
      ВЕРНУТЬ (ch >= "A") & (ch <= "F") ИЛИ (ch >= "0") & (ch <= "9")
    КОНЕЦ Если16число;

ПРОЦЕДУРА PutChar(ch: СИМВ);
    НАЧАЛО
      лекс_глоб[count] := ch;
      ЕСЛИ ch # 0X ТОГДА
        ДОБ(count)
      КОНЕЦ
    КОНЕЦ PutChar;

ПРОЦЕДУРА PutNext(ch: СИМВ);
    НАЧАЛО
      PutChar(ch);
      Next
    КОНЕЦ PutNext;

ПРОЦЕДУРА Ident;
    НАЧАЛО
      лекс_тип := мКонст._лекИмя;
      ПОКА ЕслиСимвол(ch) ИЛИ ЕслиЦифра(ch) ДЕЛАТЬ
        PutNext(ch)
      КОНЕЦ;
      PutChar(0X);
      ЕСЛИ count > мКонст._IDLENGTH ТОГДА
        лекс_тип := мКонст._lexERR10
      КОНЕЦ
    КОНЕЦ Ident;

ПРОЦЕДУРА Симв2hex*(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ Res: ЦЕЛОЕ;
    НАЧАЛО
      Res := ORD(ch);
      ВЫБРАТЬ ch ИЗ
      |"0".."9": ВЫЧ(Res, ORD("0"))
      |"A".."F": ВЫЧ(Res, ORD("A") - 10)
      ИНАЧЕ
      КОНЕЦ
      ВЕРНУТЬ Res
    КОНЕЦ Симв2hex;

ПРОЦЕДУРА Стр2цел16(str: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ i, res, n: ЦЕЛОЕ; flag: БУЛЕВО;
    НАЧАЛО
      res := 0;
      i := 0;
      n := 0;
      ПОКА str[i] = "0" ДЕЛАТЬ
        ДОБ(i)
      КОНЕЦ;
      flag := ИСТИНА;
      ПОКА flag & (str[i] # "X") & (str[i] # "H") ДЕЛАТЬ
        ДОБ(n);
        ЕСЛИ n > 8 ТОГДА
          лекс_тип := мКонст._lexERR5;
          flag := ЛОЖЬ
        ИНАЧЕ
          res := LSL(res, 4) + Симв2hex(str[i]);
          ДОБ(i)
        КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ Стр2цел16;

ПРОЦЕДУРА Стр2симв(str: мСтр.тСтрока): СИМВ;
    ПЕРЕМ res: ЦЕЛОЕ;
    НАЧАЛО
      res := Стр2цел16(str);
      ЕСЛИ (res < 0) ИЛИ (res > 0FFH) ТОГДА
        лекс_тип := мКонст._lexERR6;
        res := 0
      КОНЕЦ
      ВЕРНУТЬ CHR(res)
    КОНЕЦ Стр2симв;

ПРОЦЕДУРА Стр2цел*(str: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ i, res: ЦЕЛОЕ; flag: БУЛЕВО;
    НАЧАЛО
      res := 0;
      i := 0;
      flag := ИСТИНА;
      ПОКА flag & (str[i] # 0X) ДЕЛАТЬ
        ЕСЛИ res > мКонст._maxINT DIV 10 ТОГДА
          лекс_тип := мКонст._lexERR5;
          flag := ЛОЖЬ;
          res := 0
        ИНАЧЕ
          res := res * 10;
          ЕСЛИ res > мКонст._maxINT - (ORD(str[i]) - ORD("0")) ТОГДА
            лекс_тип := мКонст._lexERR5;
            flag := ЛОЖЬ;
            res := 0
          ИНАЧЕ
            res := res + (ORD(str[i]) - ORD("0"));
            ДОБ(i)
          КОНЕЦ
        КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ Стр2цел;

ПРОЦЕДУРА Стр2длин_вещ(str: мСтр.тСтрока): ДЛИНВЕЩ;
    ПЕРЕМ i, scale: ЦЕЛОЕ; res, m, d: ДЛИНВЕЩ; minus, nez: БУЛЕВО;

      ПРОЦЕДУРА Error(e: ЦЕЛОЕ; ПЕРЕМ cont: БУЛЕВО);
          НАЧАЛО
            лекс_тип := e;
            res := 0.0D0;
            cont := ЛОЖЬ
          КОНЕЦ Error;

      ПРОЦЕДУРА Inf(ПЕРЕМ cont: БУЛЕВО; ПЕРЕМ i: ЦЕЛОЕ);
          НАЧАЛО
            ЕСЛИ мУтиль.ЕслиБесконеч(res) ТОГДА
              Error(мКонст._lexERR7, cont)
            КОНЕЦ;
            ДОБ(i)
          КОНЕЦ Inf;

      ПРОЦЕДУРА part1(): БУЛЕВО;
          ПЕРЕМ cont: БУЛЕВО;
          НАЧАЛО
            res := 0.0D0;
            i := 0;
            d := 1.0D0;
            nez := ЛОЖЬ;
            cont := ИСТИНА;
            ПОКА cont & ЕслиЦифра(str[i]) ДЕЛАТЬ
              nez := nez ИЛИ (str[i] # "0");
              res := res * 10.0D0 + ДЛИН(FLT(ORD(str[i]) - ORD("0")));
              Inf(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part1;

      ПРОЦЕДУРА part2(): БУЛЕВО;
          ПЕРЕМ cont: БУЛЕВО;
          НАЧАЛО
            ДОБ(i);
            cont := ИСТИНА;
            ПОКА cont & ЕслиЦифра(str[i]) ДЕЛАТЬ
              nez := nez ИЛИ (str[i] # "0");
              d := d / 10.0D0;
              res := res + ДЛИН(FLT(ORD(str[i]) - ORD("0"))) * d;
              Inf(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part2;

      ПРОЦЕДУРА part3(): БУЛЕВО;
          ПЕРЕМ cont: БУЛЕВО;
          НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ str[i] = 0X ТОГДА
              ЕСЛИ res > ДЛИН(мКонст._maxREAL) ТОГДА
                Error(мКонст._lexERR7, cont)
              ИНЕСЛ nez & ((res = 0.0D0) ИЛИ (res < ДЛИН(мКонст._minREAL)) & (лекс_тип = мКонст._лекВеществ)) ТОГДА
                Error(мКонст._lexERR9, cont)
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part3;

      ПРОЦЕДУРА part4(): БУЛЕВО;
          ПЕРЕМ cont: БУЛЕВО;
          НАЧАЛО
            ЕСЛИ str[i] = "D" ТОГДА
              лекс_тип := мКонст._лекДлинВещ
            КОНЕЦ;
            ДОБ(i);
            m := 10.0D0;
            minus := ЛОЖЬ;
            ЕСЛИ str[i] = "+" ТОГДА
                ДОБ(i)
            ИНЕСЛ str[i] = "-" ТОГДА
              minus := ИСТИНА;
              ДОБ(i);
              m := 0.1D0
            КОНЕЦ;
            scale := 0;
            cont := ИСТИНА;
            ПОКА cont & ЕслиЦифра(str[i]) ДЕЛАТЬ
              ЕСЛИ scale > мКонст._maxINT DIV 10 ТОГДА
                Error(мКонст._lexERR8, cont)
              ИНАЧЕ
                scale := scale * 10;
                ЕСЛИ scale > мКонст._maxINT - (ORD(str[i]) - ORD("0")) ТОГДА
                  Error(мКонст._lexERR8, cont)
                ИНАЧЕ
                  scale := scale + (ORD(str[i]) - ORD("0"));
                  ДОБ(i)
                КОНЕЦ
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part4;

      ПРОЦЕДУРА part5(): БУЛЕВО;
          ПЕРЕМ cont: БУЛЕВО; i: ЦЕЛОЕ;
          НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ scale = мКонст._maxINT ТОГДА
              Error(мКонст._lexERR8, cont)
            КОНЕЦ;
            i := 1;
            ПОКА cont & (i <= scale) ДЕЛАТЬ
              res := res * m;
              Inf(cont, i)
            КОНЕЦ;
            ЕСЛИ cont & (nez & (res = 0.0D0) ИЛИ (res > 0.0D0) & (res < ДЛИН(мКонст._minREAL)) & (лекс_тип = мКонст._лекВеществ)) ТОГДА
              Error(мКонст._lexERR9, cont)
            ИНЕСЛ cont & (лекс_тип = мКонст._лекВеществ) & (res > ДЛИН(мКонст._maxREAL)) ТОГДА
              Error(мКонст._lexERR7, cont)
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part5;

    НАЧАЛО
      ЕСЛИ part1() & part2() & part3() & part4() & part5() ТОГДА КОНЕЦ
      ВЕРНУТЬ res
    КОНЕЦ Стр2длин_вещ;

ПРОЦЕДУРА Number;
    ПЕРЕМ nextchr: СИМВ;
    НАЧАЛО
      лекс_тип := мКонст._лекЦел;
      ПОКА ЕслиЦифра(ch) ДЕЛАТЬ
        PutNext(ch)
      КОНЕЦ;
      ЕСЛИ ch = "H" ТОГДА
        лекс_тип := мКонст._lexHEX
      ИНЕСЛ ch = "X" ТОГДА
        лекс_тип := мКонст._lexCHX
      КОНЕЦ;
      ЕСЛИ лекс_тип # мКонст._лекЦел ТОГДА
        PutNext(ch)
      ИНАЧЕ
        ПОКА Если16число(ch) ДЕЛАТЬ
          лекс_тип := мКонст._lexHEX;
          PutNext(ch)
        КОНЕЦ;
        ЕСЛИ лекс_тип = мКонст._lexHEX ТОГДА
          ЕСЛИ ch = "H" ТОГДА
            PutNext(ch)
          ИНЕСЛ ch = "X" ТОГДА
            лекс_тип := мКонст._lexCHX;
            PutNext(ch)
          ИНАЧЕ
            лекс_тип := мКонст._lexERR1
          КОНЕЦ
        ИНЕСЛ ch = "." ТОГДА
          sys.GET(bufpos, nextchr);
          ЕСЛИ nextchr # "." ТОГДА
            лекс_тип := мКонст._лекВеществ;
            PutNext(ch);
            ПОКА ЕслиЦифра(ch) ДЕЛАТЬ
              PutNext(ch)
            КОНЕЦ;
            ЕСЛИ (ch = "E") ИЛИ (ch = "D") ТОГДА
              PutNext(ch);
              ЕСЛИ (ch = "+") ИЛИ (ch = "-") ТОГДА
                PutNext(ch)
              КОНЕЦ;
              ЕСЛИ ~ЕслиЦифра(ch) ТОГДА
                лекс_тип := мКонст._lexERR2
              ИНАЧЕ
                ПОКА ЕслиЦифра(ch) ДЕЛАТЬ
                  PutNext(ch)
                КОНЕЦ
              КОНЕЦ
            КОНЕЦ
          КОНЕЦ
        КОНЕЦ
      КОНЕЦ;
      PutChar(0X)
    КОНЕЦ Number;

ПРОЦЕДУРА Оператор_Получ(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        Res: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБРАТЬ ch ИЗ
            |"+": Res := мКонст._опПлюс
            |"-": Res := мКонст._опМинус
            |"*": Res := мКонст._опУмнож
            |"/": Res := мКонст._опДел
            |"~": Res := мКонст._опИнверс
            |"&": Res := мКонст._опКомерцИ
            |",": Res := мКонст._опЗпт
            |";": Res := мКонст._опТчкЗпт
            |"|": Res := мКонст._опВерт
            |"[": Res := мКонст._опСкобЛевКв
            |"]": Res := мКонст._опСкобПравКв
            |"{": Res := мКонст._опСкобФигурЛев
            |"}": Res := мКонст._опСкобФигурПрав
            |"^": Res := мКонст._опСтепень
            |"=": Res := мКонст._опРавно
            |"#": Res := мКонст._опНеРавно
            |")": Res := мКонст._опСкобПравКруг
            |">": Res := мКонст._опБольше
            |"<": Res := мКонст._опМеньше
            |":": Res := мКонст._опДвеТчк
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Оператор_Получ;

ПРОЦЕДУРА Comment;
    ПЕРЕМ c, level: ЦЕЛОЕ; cont: БУЛЕВО;
    НАЧАЛО
      c := 1;
      level := 1;
      cont := ИСТИНА;
      ПОКА cont & (level > 0) ДЕЛАТЬ
        Next;
        ВЫБРАТЬ ch ИЗ
        |"(": c := 2
        |")": ЕСЛИ c = 3 ТОГДА ВЫЧ(level) КОНЕЦ; c := 1
        |"*": ЕСЛИ c = 2 ТОГДА ДОБ(level); c := 1 ИНАЧЕ c := 3 КОНЕЦ
        |0X : cont := ЛОЖЬ
        ИНАЧЕ
              c := 1
        КОНЕЦ;
      КОНЕЦ;
      ЕСЛИ cont ТОГДА
        Next
      КОНЕЦ
    КОНЕЦ Comment;

ПРОЦЕДУРА Лексем_Получ*;
    НАЧАЛО
      ПОКА ЕслиПробел(ch) ДЕЛАТЬ
        Next
      КОНЕЦ;
      позиц_глоб := ccol;
      строка_ном := cline;
      count := 0;
      ВЫБРАТЬ ch ИЗ
      |"A".."Z", "a".."z", "_", "А".."Я", "а".."я":
        Ident;
        id := Узел_Добавить(лекс_глоб);
        лекс_тип := id.лекс_тип;
      |"0".."9":
        Number;
        ВЫБРАТЬ лекс_тип ИЗ
        |мКонст._лекЦел:  vINT := Стр2цел(лекс_глоб)
        |мКонст._lexHEX:  vINT := Стр2цел16(лекс_глоб)
        |мКонст._lexCHX:  vCHX := Стр2симв(лекс_глоб)
        |мКонст._лекВеществ: vFLT := Стр2длин_вещ(лекс_глоб)
        ИНАЧЕ
        КОНЕЦ
      |22X:
        лекс_тип := мКонст._лекСтрока;
        Next;
        ПОКА (ch # 22X) & (ch >= 20X) ДЕЛАТЬ
          PutNext(ch)
        КОНЕЦ;
        ЕСЛИ ch = 22X ТОГДА
          Next
        ИНАЧЕ
          лекс_тип := мКонст._lexERR3
        КОНЕЦ;
        PutChar(0X);
        ДОБ(count);
        ЕСЛИ count > мКонст._STRLENGTH ТОГДА
          лекс_тип := мКонст._lexERR11
        КОНЕЦ
      |"/":
        лекс_тип := Оператор_Получ(ch);
        PutNext(ch);
        ЕСЛИ ch = "/" ТОГДА
          ПОКА (ch >= 20X) ИЛИ (ch = 9X) ДЕЛАТЬ
            PutNext(ch)
          КОНЕЦ;
          Лексем_Получ
        КОНЕЦ;
        PutChar(0X)
      |">", "<", ":":
        лекс_тип := Оператор_Получ(ch);
        PutNext(ch);
        ЕСЛИ ch = "=" ТОГДА
          ВЫБРАТЬ лекс_тип ИЗ
          |мКонст._опМеньше:    лекс_тип := мКонст._lexLE
          |мКонст._опБольше:    лекс_тип := мКонст._lexGE
          |мКонст._опДвеТчк: лекс_тип := мКонст._lexAssign
          ИНАЧЕ
          КОНЕЦ;
          PutNext(ch)
        КОНЕЦ;
        PutChar(0X)
      |".":
        лекс_тип := мКонст._лекТочка;
        PutNext(ch);
        ЕСЛИ ch = "." ТОГДА
          лекс_тип := мКонст._lexDbl;
          PutNext(ch)
        КОНЕЦ;
        PutChar(0X)
      |"(":
        лекс_тип := мКонст._lexLRound;
        PutNext(ch);
        ЕСЛИ ch = "*" ТОГДА
          Comment;
          Лексем_Получ
        КОНЕЦ;
        PutChar(0X)
      |"+", "-", "*", "~", "&", ",", ";", "|",
       "[", "{", "^", "=", "#", ")", "]", "}":
        лекс_тип := Оператор_Получ(ch);
        PutChar(ch);
        PutNext(0X)
      |0X:
        лекс_тип := мКонст._лекКонФл;
        PutChar(0X)
      ИНАЧЕ
        лекс_тип := мКонст._lexERR4
      КОНЕЦ
    КОНЕЦ Лексем_Получ;

ПРОЦЕДУРА КлючСлово_Добавить(Name: мСтр.тСтрока; key: ЦЕЛОЕ);
    ПЕРЕМ node: туУзел;
    НАЧАЛО
      node := Узел_Добавить(Name);
      node.лекс_тип := key
    КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
    ПЕРЕМ
        i: ЦЕЛОЕ; node: туУзел;
    НАЧАЛО
      ДЛЯ i := 0 ДО LEN(Nodes) - 1 ДЕЛАТЬ
        НОВ(node);
        мОш.MemErr(node = ПУСТО);
        sys.PUT(sys.ADR(node.имя_узла), i);
        node.узел_лев := ПУСТО;
        node.узел_прав := ПУСТО;
        node.лекс_тип := мКонст._лекИмя;
        Nodes[i] := node
      КОНЕЦ;
      _START := Узел_Добавить("START");
      _version := Узел_Добавить("version");
      КлючСлово_Добавить("MOD", мКонст._lexMOD);
      КлючСлово_Добавить(мКонст._ангИначе, мКонст._лекИначе);
      КлючСлово_Добавить(мКонст._русИначе, мКонст._лекИначе);
      КлючСлово_Добавить(мКонст._ангВернуть, мКонст._лекВернуть);
      КлючСлово_Добавить(мКонст._русВернуть, мКонст._лекВернуть);
      КлючСлово_Добавить(мКонст._ангВыбрать, мКонст._лекВыбрать);
      КлючСлово_Добавить(мКонст._русВыбрать, мКонст._лекВыбрать);
      КлючСлово_Добавить(мКонст._ангЕсли, мКонст._лекЕсли);
      КлючСлово_Добавить(мКонст._русЕсли, мКонст._лекЕсли);
      КлючСлово_Добавить(мКонст._ангУказатель, мКонст._лекУказат);
      КлючСлово_Добавить(мКонст._русУказатель, мКонст._лекУказат);
      КлючСлово_Добавить(мКонст._ангТипы, мКонст._лекТипы);
      КлючСлово_Добавить(мКонст._русТипы, мКонст._лекТипы);
      КлючСлово_Добавить(мКонст._ангНачало, мКонст._лекНачать);
      КлючСлово_Добавить(мКонст._русНачало, мКонст._лекНачать);
      КлючСлово_Добавить("DIV", мКонст._lexDIV);
      КлючСлово_Добавить(мКонст._ангЛожь, мКонст._лекЛожь);
      КлючСлово_Добавить(мКонст._русЛожь, мКонст._лекЛожь);
      КлючСлово_Добавить(мКонст._ангВходит, мКонст._лекВходит);
      КлючСлово_Добавить(мКонст._русВходит, мКонст._лекВходит);
      КлючСлово_Добавить(мКонст._ангПусто, мКонст._лекПусто);
      КлючСлово_Добавить(мКонст._русПусто, мКонст._лекПусто);
      КлючСлово_Добавить(мКонст._ангЗапись, мКонст._лекЗапись);
      КлючСлово_Добавить(мКонст._русЗапись, мКонст._лекЗапись);
      КлючСлово_Добавить(мКонст._ангНа, мКонст._lexTO);
      КлючСлово_Добавить(мКонст._русНа, мКонст._lexTO);
      КлючСлово_Добавить(мКонст._русДо, мКонст._lexTO);
      КлючСлово_Добавить(мКонст._ангПерем, мКонст._лекПерем);
      КлючСлово_Добавить(мКонст._русПерем, мКонст._лекПерем);
      КлючСлово_Добавить(мКонст._ангМассив, мКонст._лекМассив);
      КлючСлово_Добавить(мКонст._русМассив, мКонст._лекМассив);
      КлючСлово_Добавить(мКонст._ангДелать, мКонст._lexDO);
      КлючСлово_Добавить(мКонст._русДелать, мКонст._lexDO);
      КлючСлово_Добавить(мКонст._ангКонец, мКонст._лекКонец);
      КлючСлово_Добавить(мКонст._русКонец, мКонст._лекКонец);
      КлючСлово_Добавить(мКонст._ангЕсть, мКонст._лекЕсть);
      КлючСлово_Добавить(мКонст._русЕсть, мКонст._лекЕсть);
      КлючСлово_Добавить(мКонст._ангИз, мКонст._lexOF);
      КлючСлово_Добавить(мКонст._русИз, мКонст._lexOF);
      КлючСлово_Добавить(мКонст._ангПроцедура, мКонст._лекПроцедура);
      КлючСлово_Добавить(мКонст._русПроцедура, мКонст._лекПроцедура);
      КлючСлово_Добавить(мКонст._ангТогда, мКонст._лекТогда);
      КлючСлово_Добавить(мКонст._русТогда, мКонст._лекТогда);
      КлючСлово_Добавить(мКонст._ангПока, мКонст._лекПока);
      КлючСлово_Добавить(мКонст._русПока, мКонст._лекПока);
      КлючСлово_Добавить(мКонст._ангПо, мКонст._лекПо);
      КлючСлово_Добавить(мКонст._русПо, мКонст._лекПо);
      КлючСлово_Добавить(мКонст._ангКонст, мКонст._лекКонст);
      КлючСлово_Добавить(мКонст._русКонст, мКонст._лекКонст);
      КлючСлово_Добавить(мКонст._ангИлесл, мКонст._лекИлЕсли);
      КлючСлово_Добавить(мКонст._русИлесл, мКонст._лекИлЕсли);
      КлючСлово_Добавить(мКонст._ангИмпорт, мКонст._лекИмпорт);
      КлючСлово_Добавить(мКонст._русИмпорт, мКонст._лекИмпорт);
      КлючСлово_Добавить(мКонст._ангМодуль, мКонст._лекМодуль);
      КлючСлово_Добавить(мКонст._русМодуль, мКонст._лекМодуль);
      КлючСлово_Добавить(мКонст._ангИли, мКонст._лекИли);
      КлючСлово_Добавить(мКонст._русИли, мКонст._лекИли);
      КлючСлово_Добавить(мКонст._ангПовторять, мКонст._лекПовторять);
      КлючСлово_Добавить(мКонст._русПовторять, мКонст._лекПовторять);
      КлючСлово_Добавить(мКонст._ангИстина, мКонст._лекИстина);
      КлючСлово_Добавить(мКонст._русИстина, мКонст._лекИстина);
      КлючСлово_Добавить(мКонст._ангСнова, мКонст._лекСнова);
      КлючСлово_Добавить(мКонст._русСнова, мКонст._лекСнова);
      КлючСлово_Добавить(мКонст._ангДля, мКонст._лекДля);
      КлючСлово_Добавить(мКонст._русДля, мКонст._лекДля)
    КОНЕЦ Настроить;

НАЧАЛО
  Настроить
КОНЕЦ SCAN.
