(*

   Author:  prospero78su
      email:   prospero.78.su@@goooogle.com
      Company: Prospero Soft Ltd.

      Version: 000
      Date:    10.07.2017 13:21:26 Египетское время (зима)

      License: BSD-2

   Copyright (c) 2017, prospero78su

      Разрешается повторное распространение и использование как в виде исходного кода, так и в
      двоичной форме, с изменениями или без, при соблюдении следующих условий:

      1. При повторном распространении исходного кода должно оставаться указанное выше уведомление
      об авторском праве, этот список условий и последующий отказ от гарантий.
      2. При повторном распространении двоичного кода должна сохраняться указанная выше информация
      об авторском праве, этот список условий и последующий отказ от гарантий в документации и/или
      в других материалах, поставляемых при распространении.

      ЭТА ПРОГРАММА ПРЕДОСТАВЛЕНА ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ «КАК ОНА ЕСТЬ»
      БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ
      ИМИ, ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. НИ В КОЕМ
      СЛУЧАЕ НИ ОДИН ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО
      РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО СКАЗАНО ВЫШЕ, НЕ НЕСЁТ ОТВЕТСТВЕННОСТИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ,
      СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ ПОСЛЕДОВАВШИЕ УБЫТКИ, ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ
      ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ
      НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ ИЗ-ЗА ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ
      СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ТАКОЙ ВЛАДЕЛЕЦ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О
      ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.

   Модуль является прокладкой между рулём и сиденьем для разных типов ассемблеров.
   *)

МОДУЛЬ модАсм;

ИМПОРТ мАсмИ32 := модАсмИнтел32,
   мСтр := модСтроки,
   мКонст := модКонстанты,
   mSys := SYSTEM,
   мКс := модКлючСлово,
   мАт := модАсмТипы,
   мТип := модТип;

ТИПЫ
   (* глобальная переменная, хранит в себе целевой ЦПУ и ОС *)
   туАсм = УКАЗАТЕЛЬ НА ЗАПИСЬ
         цЦПУ: ЦЕЛОЕ; (* тип процессора *)
         цОС : ЦЕЛОЕ; (* тип операционной системы *)
         цМасРазм: ЦЕЛОЕ (* предельная размерность массива *)
      КОНЕЦ;

ПЕРЕМ
   уАсм*: туАсм;

ПРОЦЕДУРА ФайлЛин_Уст*(name: мСтр.тСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ФайлЛин_Уст(name)
      КОНЕЦ;
   КОНЕЦ ФайлЛин_Уст;

ПРОЦЕДУРА ПроцРтл_Добавить*(idx, proc: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ПроцРтл_Добавить(idx, proc)
      КОНЕЦ;
   КОНЕЦ ПроцРтл_Добавить;

ПРОЦЕДУРА Проц_Экспортировать*(Number: ЦЕЛОЕ; уЗвеноСущ_: мКс.туЗвКс; NameLabel: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Проц_Экспортировать(Number, уЗвеноСущ_, NameLabel)
      КОНЕЦ;
   КОНЕЦ Проц_Экспортировать;

ПРОЦЕДУРА АдрВырав_Получ*(пцРазмер, пцВыравнив: ЦЕЛОЕ): ЦЕЛОЕ;
   ПЕРЕМ
      цСмещВых : ЦЕЛОЕ;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         цСмещВых := мАсмИ32.АдрВырав_Получ(пцРазмер, пцВыравнив)
      КОНЕЦ;
      ВЕРНУТЬ цСмещВых
   КОНЕЦ АдрВырав_Получ;

ПРОЦЕДУРА Стек_Ограничить*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Стек_Ограничить
      КОНЕЦ;
   КОНЕЦ Стек_Ограничить;

ПРОЦЕДУРА Вызов_Закончить*;
  НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Вызов_Закончить
      КОНЕЦ;
  КОНЕЦ Вызов_Закончить;

ПРОЦЕДУРА Настроить*(mem: мАт.тПроцедура; UI: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Настроить(mem, UI)
      КОНЕЦ;
   КОНЕЦ Настроить;

ПРОЦЕДУРА Переход_Выполнить*(переход_: ЛИТ; цМетка_: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Переход_Выполнить(переход_, цМетка_)
      КОНЕЦ;
   КОНЕЦ Переход_Выполнить;

ПРОЦЕДУРА Метку_Назначить*(label: ЦЕЛОЕ);
  НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Метку_Назначить(label)
      КОНЕЦ;
  КОНЕЦ Метку_Назначить;

ПРОЦЕДУРА МПУ_Запретить*(long: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.МПУ_Запретить(long)
      КОНЕЦ;
   КОНЕЦ МПУ_Запретить;

ПРОЦЕДУРА Процедуру_Вызвать*(proc: ЦЕЛОЕ; func, float: БУЛЕВО; callconv, ccall, bases, level, parsize, local: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Процедуру_Вызвать(proc, func, float, callconv, ccall, bases, level, parsize, local)
      КОНЕЦ;
   КОНЕЦ Процедуру_Вызвать;

ПРОЦЕДУРА НаСтек_ЦЕЛОЕ*(n: ЦЕЛОЕ);
  НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.НаСтек_ЦЕЛОЕ(n)
      КОНЕЦ;
  КОНЕЦ НаСтек_ЦЕЛОЕ;

ПРОЦЕДУРА НаСтек_КОНСТ*(Number: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.НаСтек_КОНСТ(Number)
      КОНЕЦ;
   КОНЕЦ НаСтек_КОНСТ;

ПРОЦЕДУРА Пролог*(exename: мСтр.тСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Пролог(exename)
      КОНЕЦ;
   КОНЕЦ Пролог;

ПРОЦЕДУРА ЗАПИСЬ_Добавить*(base: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ЗАПИСЬ_Добавить(base)
      КОНЕЦ;
   КОНЕЦ ЗАПИСЬ_Добавить;

ПРОЦЕДУРА Загрузить*(T: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Загрузить(T)
      КОНЕЦ;
   КОНЕЦ Загрузить;

ПРОЦЕДУРА АдресГлобальный*(offset: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.АдресГлобальный(offset)
      КОНЕЦ;
   КОНЕЦ АдресГлобальный;

ПРОЦЕДУРА АдресЛокальный*(offset, bases: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.АдресЛокальный(offset, bases)
      КОНЕЦ;
   КОНЕЦ АдресЛокальный;

ПРОЦЕДУРА ЗАПИСЬ_Создать*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ЗАПИСЬ_Создать
      КОНЕЦ;
   КОНЕЦ ЗАПИСЬ_Создать;

ПРОЦЕДУРА НаСтек_ДЛИНВЕЩ*(x: ДЛИНВЕЩ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.НаСтек_ДЛИНВЕЩ(x)
      КОНЕЦ;
   КОНЕЦ НаСтек_ДЛИНВЕЩ;

ПРОЦЕДУРА ПУСТО_Проверить*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ПУСТО_Проверить
      КОНЕЦ;
   КОНЕЦ ПУСТО_Проверить;

ПРОЦЕДУРА Поле*(offset: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Поле(offset)
      КОНЕЦ;
   КОНЕЦ Поле;

ПРОЦЕДУРА ИМЯ_Открыть*(n: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ИМЯ_Открыть(n)
      КОНЕЦ;
   КОНЕЦ ИМЯ_Открыть;

ПРОЦЕДУРА Отбросить*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Отбросить
      КОНЕЦ;
   КОНЕЦ Отбросить;

ПРОЦЕДУРА Защитить*(T: ЦЕЛОЕ; Check: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Защитить(T, Check)
      КОНЕЦ;
   КОНЕЦ Защитить;

ПРОЦЕДУРА ИМЯ_Сохр*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ИМЯ_Сохр
      КОНЕЦ;
   КОНЕЦ ИМЯ_Сохр;

ПРОЦЕДУРА ИМЯ_Испр*(len, size: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ИМЯ_Испр(len, size)
      КОНЕЦ;
   КОНЕЦ ИМЯ_Испр;

ПРОЦЕДУРА ДвойЗагрузка_Проверить*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ДвойЗагрузка_Проверить
      КОНЕЦ;
   КОНЕЦ ДвойЗагрузка_Проверить;

ПРОЦЕДУРА ifwh*(L: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ifwh(L)
      КОНЕЦ;
   КОНЕЦ ifwh;

ПРОЦЕДУРА Двойная_Загрузка*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Двойная_Загрузка
      КОНЕЦ;
   КОНЕЦ Двойная_Загрузка;

ПРОЦЕДУРА РТЛ_Уст*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.РТЛ_Уст
      КОНЕЦ;
   КОНЕЦ РТЛ_Уст;

ПРОЦЕДУРА Действие_Уст*(Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Действие_Уст(Op)
      КОНЕЦ;
   КОНЕЦ Действие_Уст;

ПРОЦЕДУРА ФункцВстр_Выполнить*(func: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ФункцВстр_Выполнить(func)
      КОНЕЦ;
   КОНЕЦ ФункцВстр_Выполнить;

ПРОЦЕДУРА Дублировать*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Дублировать
      КОНЕЦ;
   КОНЕЦ Дублировать;

ПРОЦЕДУРА МассивДл_Получ*(dim: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.МассивДл_Получ(dim)
      КОНЕЦ;
   КОНЕЦ МассивДл_Получ;

ПРОЦЕДУРА Моно*(Number: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Моно(Number)
      КОНЕЦ
   КОНЕЦ Моно;

ПРОЦЕДУРА СтрМоно*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.СтрМоно
      КОНЕЦ;
   КОНЕЦ СтрМоно;

ПРОЦЕДУРА Адрес*(dim: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Адрес(dim)
      КОНЕЦ
   КОНЕЦ Адрес;

ПРОЦЕДУРА Тип_Отвязать*(n: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Тип_Отвязать(n)
      КОНЕЦ
   КОНЕЦ Тип_Отвязать;

ПРОЦЕДУРА Отрицание*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Отрицание
      КОНЕЦ;
   КОНЕЦ Отрицание;

ПРОЦЕДУРА Строки_Сравнить*(Op, LR: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Строки_Сравнить(Op, LR)
      КОНЕЦ;
   КОНЕЦ Строки_Сравнить;

ПРОЦЕДУРА Целое*(Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Целое(Op)
      КОНЕЦ;
   КОНЕЦ Целое;

ПРОЦЕДУРА Целое_Сравнить*(Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Целое_Сравнить(Op)
      КОНЕЦ;
   КОНЕЦ Целое_Сравнить;

ПРОЦЕДУРА Вещ_Сравнить*(Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Вещ_Сравнить(Op)
      КОНЕЦ;
   КОНЕЦ Вещ_Сравнить;

ПРОЦЕДУРА Включение*(Op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Включение(Op)
      КОНЕЦ
   КОНЕЦ Включение;

ПРОЦЕДУРА Метка_Новая*(): ЦЕЛОЕ;
   ПЕРЕМ
      цВыход: ЦЕЛОЕ;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         цВыход := мАсмИ32.Метка_Новая()
      КОНЕЦ;
      ВЕРНУТЬ цВыход
   КОНЕЦ Метка_Новая;

ПРОЦЕДУРА Ошибку_Указать*(n: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Ошибку_Указать(n)
      КОНЕЦ;
   КОНЕЦ Ошибку_Указать;

ПРОЦЕДУРА Вещ_Вычислить*(op: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Вещ_Вычислить(op)
      КОНЕЦ;
   КОНЕЦ Вещ_Вычислить;

ПРОЦЕДУРА Остаток_Определить*(opmod: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Остаток_Определить(opmod)
      КОНЕЦ;
   КОНЕЦ Остаток_Определить;

ПРОЦЕДУРА НАБОР_Вхождение*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.НАБОР_Вхождение
      КОНЕЦ;
   КОНЕЦ НАБОР_Вхождение;

ПРОЦЕДУРА ЕслиПОКА*(L: ЦЕЛОЕ; orop: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ЕслиПОКА(L, orop)
      КОНЕЦ
   КОНЕЦ ЕслиПОКА;

ПРОЦЕДУРА Целое_Отриц*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Целое_Отриц
      КОНЕЦ;
   КОНЕЦ Целое_Отриц;

ПРОЦЕДУРА НАБОР_Отриц*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.НАБОР_Отриц
      КОНЕЦ;
   КОНЕЦ НАБОР_Отриц;

ПРОЦЕДУРА СПЦ_Уст*(newfpu: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.СПЦ_Уст(newfpu)
      КОНЕЦ
   КОНЕЦ СПЦ_Уст;

ПРОЦЕДУРА Тип_Сохр*(T: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Тип_Сохр(T)
      КОНЕЦ
   КОНЕЦ Тип_Сохр;

ПРОЦЕДУРА ДЛЯ_Начать*(inc: БУЛЕВО; ПЕР LBeg, LEnd: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ДЛЯ_Начать(inc, LBeg, LEnd)
      КОНЕЦ
   КОНЕЦ ДЛЯ_Начать;

ПРОЦЕДУРА ДЛЯ_Выполнять*(step, LBeg, LEnd: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ДЛЯ_Выполнять(step, LBeg, LEnd)
      КОНЕЦ
   КОНЕЦ ДЛЯ_Выполнять;

ПРОЦЕДУРА ВЫБОР_Выполнить*(a, b, LBeg: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ВЫБОР_Выполнить(a, b, LBeg)
      КОНЕЦ
   КОНЕЦ ВЫБОР_Выполнить;

ПРОЦЕДУРА ПроцСобств_Выполнить*(proc: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ПроцСобств_Выполнить(proc)
      КОНЕЦ
   КОНЕЦ ПроцСобств_Выполнить;

ПРОЦЕДУРА ЗАПИСЬ_Направить*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.ЗАПИСЬ_Направить
      КОНЕЦ;
   КОНЕЦ ЗАПИСЬ_Направить;

ПРОЦЕДУРА Контроль*(proc, assrt: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Контроль(proc, assrt)
      КОНЕЦ;
   КОНЕЦ Контроль;

ПРОЦЕДУРА Ассемблировать*(s: мСтр.тСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Ассемблировать(s)
      КОНЕЦ;
   КОНЕЦ Ассемблировать;

ПРОЦЕДУРА Проц_Начать*(Number, Local: ЦЕЛОЕ; Module: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Проц_Начать(Number, Local, Module)
      КОНЕЦ;
   КОНЕЦ Проц_Начать;

ПРОЦЕДУРА Эпилог*(gsize: ЦЕЛОЕ; стрФайлИмя: МАССИВ ИЗ ЛИТ; stk: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Эпилог(gsize, стрФайлИмя, stk)
      КОНЕЦ;
   КОНЕЦ Эпилог;

ПРОЦЕДУРА Строка*(уСтр_: мСтр.туСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Строка(уСтр_)
      КОНЕЦ
   КОНЕЦ Строка;

ПРОЦЕДУРА Модуль_Вызвать*(уСтр_: мСтр.туСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Модуль_Вызвать(уСтр_)
      КОНЕЦ
   КОНЕЦ Модуль_Вызвать;

ПРОЦЕДУРА Покинуть*;
   НАЧАЛО
      ЕСЛИ уАсм.цЦПУ = мКонст.асмИ32 ТОГДА
         мАсмИ32.Покинуть
      КОНЕЦ;
   КОНЕЦ Покинуть;

НАЧАЛО
   НОВ(уАсм);
   уАсм.цЦПУ := мКонст.асмИ32;
   ЕСЛИ мКонст.бВиндоус ТОГДА
      уАсм.цОС := мКонст.цВиндоус;
      уАсм.цМасРазм := мКонст.мас_вин
   КОНЕЦ
КОНЕЦ модАсм.
