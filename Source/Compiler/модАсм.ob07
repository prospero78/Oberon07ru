(*

   Author:  prospero78su
      email:   prospero.78.su@@goooogle.com
      Company: Prospero Soft Ltd.

      Version: 000
      Date:    10.07.2017 13:21:26 Египетское время (зима)

      License: BSD-2

   Copyright (c) 2017, prospero78su

      Разрешается повторное распространение и использование как в виде исходного кода, так и в
      двоичной форме, с изменениями или без, при соблюдении следующих условий:

      1. При повторном распространении исходного кода должно оставаться указанное выше уведомление
      об авторском праве, этот список условий и последующий отказ от гарантий.
      2. При повторном распространении двоичного кода должна сохраняться указанная выше информация
      об авторском праве, этот список условий и последующий отказ от гарантий в документации и/или
      в других материалах, поставляемых при распространении.

      ЭТА ПРОГРАММА ПРЕДОСТАВЛЕНА ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ «КАК ОНА ЕСТЬ»
      БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ
      ИМИ, ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. НИ В КОЕМ
      СЛУЧАЕ НИ ОДИН ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО
      РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО СКАЗАНО ВЫШЕ, НЕ НЕСЁТ ОТВЕТСТВЕННОСТИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ,
      СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ ПОСЛЕДОВАВШИЕ УБЫТКИ, ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ
      ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ
      НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ ИЗ-ЗА ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ
      СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ТАКОЙ ВЛАДЕЛЕЦ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О
      ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.

   Модуль является прокладкой между рулём и сиденьем для разных типов ассемблеров.
   *)

МОДУЛЬ модАсм;

ИМПОРТ мАсмИ32 := модАсмИнтел32,
   мСтр := модСтроки,
   мКонст := модКонстанты,
   mSys := SYSTEM,
   мЗвСущ := модЗвеноСущ;

ТИПЫ
   туАсм = УКАЗАТЕЛЬ НА ЗАПИСЬ
         цТип: ЦЕЛОЕ
      КОНЕЦ;

ПЕРЕМ
   уАсм*: туАсм;


ПРОЦЕДУРА ФайлЛин_Уст*(name: мСтр.тСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.ФайлЛин_Уст(name)
      КОНЕЦ;
   КОНЕЦ ФайлЛин_Уст;

ПРОЦЕДУРА ПроцРтл_Добавить*(idx, proc: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.ПроцРтл_Добавить(idx, proc)
      КОНЕЦ;
   КОНЕЦ ПроцРтл_Добавить;

ПРОЦЕДУРА Проц_Экспортировать*(Number: ЦЕЛОЕ; уЗвеноСущ_: мЗвСущ.туЗвеноСущ; NameLabel: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Проц_Экспортировать(Number, уЗвеноСущ_, NameLabel)
      КОНЕЦ;
   КОНЕЦ Проц_Экспортировать;

ПРОЦЕДУРА Выровнять*(n, m: ЦЕЛОЕ): ЦЕЛОЕ;
   ПЕРЕМ
      цВыход : ЦЕЛОЕ;
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         цВыход := мАсмИ32.Выровнять(n, m)
      КОНЕЦ;
      ВЕРНУТЬ цВыход
   КОНЕЦ Выровнять;

ПРОЦЕДУРА Стек_Ограничить*;
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Стек_Ограничить
      КОНЕЦ;
   КОНЕЦ Стек_Ограничить;

ПРОЦЕДУРА Вызов_Закончить*;
  НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Вызов_Закончить
      КОНЕЦ;
  КОНЕЦ Вызов_Закончить;

ПРОЦЕДУРА Настроить*(mem: мАсмИ32.тПроцедура; UI: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Настроить(mem, UI)
      КОНЕЦ;
   КОНЕЦ Настроить;

ПРОЦЕДУРА Переход_Выполнить*(переход_: ЛИТ; цМетка_: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Переход_Выполнить(переход_, цМетка_)
      КОНЕЦ;
   КОНЕЦ Переход_Выполнить;

ПРОЦЕДУРА Метку_Назначить*(label: ЦЕЛОЕ);
  НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Метку_Назначить(label)
      КОНЕЦ;
  КОНЕЦ Метку_Назначить;

ПРОЦЕДУРА МПУ_Запретить*(long: БУЛЕВО);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.МПУ_Запретить(long)
      КОНЕЦ;
   КОНЕЦ МПУ_Запретить;

ПРОЦЕДУРА Процедуру_Вызвать*(proc: ЦЕЛОЕ; func, float: БУЛЕВО; callconv, ccall, bases, level, parsize, local: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Процедуру_Вызвать(proc, func, float, callconv, ccall, bases, level, parsize, local)
      КОНЕЦ;
   КОНЕЦ Процедуру_Вызвать;

ПРОЦЕДУРА НаСтек_ЦЕЛОЕ*(n: ЦЕЛОЕ);
  НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.НаСтек_ЦЕЛОЕ(n)
      КОНЕЦ;
  КОНЕЦ НаСтек_ЦЕЛОЕ;

ПРОЦЕДУРА Пролог*(exename: мСтр.тСтрока);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Пролог(exename)
      КОНЕЦ;
   КОНЕЦ Пролог;

ПРОЦЕДУРА ЗАПИСЬ_Добавить*(base: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.ЗАПИСЬ_Добавить(base)
      КОНЕЦ;
   КОНЕЦ ЗАПИСЬ_Добавить;

ПРОЦЕДУРА Загрузить*(T: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.Загрузить(T)
      КОНЕЦ;
   КОНЕЦ Загрузить;

(* #ФИКС переименовать *)
ПРОЦЕДУРА АдресГлобальный*(offset: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.АдресГлобальный(offset)
      КОНЕЦ;
   КОНЕЦ АдресГлобальный;

ПРОЦЕДУРА АдресЛокальный*(offset, bases: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.АдресЛокальный(offset, bases)
      КОНЕЦ;
   КОНЕЦ АдресЛокальный;

ПРОЦЕДУРА ifwh*(L: ЦЕЛОЕ);
   НАЧАЛО
      ЕСЛИ уАсм.цТип = мКонст.асмИ32 ТОГДА
         мАсмИ32.ifwh(L)
      КОНЕЦ;
   КОНЕЦ ifwh;

НАЧАЛО
   НОВ(уАсм);
   уАсм.цТип := мКонст.асмИ32;
КОНЕЦ модАсм.
