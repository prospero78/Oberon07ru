(* содержит определение строки и всякие полезняшки для обработки строк
      BSD-2
   *)
МОДУЛЬ модСтроки;

ИМПОРТ мКонст := модКонстанты,
   mSys := SYSTEM,
   мАпи := модАпи,
   мЗвено := модЗвено;

ТИПЫ
   тСтрока* = МАССИВ мКонст.макс_дл_пути ИЗ ЛИТ;

   туСтрока* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мЗвено.тЗвено)
         стр*: тСтрока;
         длина*, номер*: ЦЕЛОЕ
      КОНЕЦ;

ПРОЦЕДУРА уКонстСтр_Получ*(adr: ДЛИНВЕЩ): туСтрока;
    ПЕРЕМ
        уСтрока: туСтрока;
    НАЧАЛО
        mSys.PUT(mSys.ADR(уСтрока), КЦЕЛ(adr))
        ВЕРНУТЬ уСтрока
    КОНЕЦ уКонстСтр_Получ;

ПРОЦЕДУРА Заглав*(лит_: ЛИТ): ЛИТ;
    НАЧАЛО
        ЕСЛИ (лит_ >= "a") & (лит_ <= "z") ТОГДА
             лит_ := ВЛИТ(НЛИТ(лит_) - 32)
        АЕСЛИ (лит_ >= "а") & (лит_ <= "я") ТОГДА
             лит_ := ВЛИТ(НЛИТ(лит_) - 32)
        АЕСЛИ (лит_="ё") ТОГДА
                лит_ := "Ё"
        ИНАЧЕ
        КОНЕЦ;
        ВЕРНУТЬ лит_
    КОНЕЦ Заглав;

ПРОЦЕДУРА Сложить*(стр_лев_, стр_прав_: МАССИВ ИЗ ЛИТ; ПЕР выход_: МАССИВ ИЗ ЛИТ);
   ПЕРЕМ
      счёт_лев, счёт_прав: ЦЕЛОЕ;
   НАЧАЛО
      счёт_лев := 0;
      ПОКА (стр_лев_[счёт_лев] # 0X) & (счёт_лев - 1 < LEN(выход_)) ДЕЛАТЬ
         выход_[счёт_лев] := стр_лев_[счёт_лев];
         ДОБ(счёт_лев)
      КОНЕЦ;
      счёт_прав := 0;
      ПОКА (стр_прав_[счёт_прав] # 0X) & (счёт_прав + счёт_лев - 1 < LEN(выход_)) ДЕЛАТЬ
         выход_[счёт_прав + счёт_лев] := стр_прав_[счёт_прав];
         ДОБ(счёт_прав)
      КОНЕЦ;
      выход_[счёт_прав + счёт_лев] := 0X
   КОНЕЦ Сложить;

ПРОЦЕДУРА Реверс*(ПЕР стр_: тСтрока);
   ПЕРЕМ
      нач, кон: ЦЕЛОЕ;
      литера: ЛИТ;
   НАЧАЛО
      нач := 0;
      кон := ДЛИНСТР(стр_) - 1;
      ПОКА нач < кон ДЕЛАТЬ
         литера := стр_[нач];
         стр_[нач] := стр_[кон];
         стр_[кон] := литера;
         ДОБ(нач);
         ВЫЧ(кон)
      КОНЕЦ
   КОНЕЦ Реверс;

ПРОЦЕДУРА Разделить*(файл_имя: тСтрока; ПЕР путь_, имя_, расшир_: тСтрока);
   ПЕРЕМ
      счёт, j, k: ЦЕЛОЕ;
   НАЧАЛО
      счёт := ДЛИНСТР(файл_имя) - 1;
      j := 0;

      (* =====выделение имени файла с конца до слэша======= *)
      ПОКА (счёт >= 0) & (файл_имя[счёт] # мАпи.Slash) ДЕЛАТЬ
         имя_[j] := файл_имя[счёт];
         ВЫЧ(счёт);
         ДОБ(j)
      КОНЕЦ;
      имя_[j] := 0X;

      (* ======выделение расширения файла====== *)
      Реверс(имя_);
      j := 0;
      k := ДЛИНСТР(имя_) - 1;
      ПОКА (k >= 0) & (имя_[k] # ".") ДЕЛАТЬ
         расшир_[j] := имя_[k];
         ВЫЧ(k);
         ДОБ(j)
      КОНЕЦ;
      ЕСЛИ k >= 0 ТОГДА
         имя_[k] := 0X;
         расшир_[j] := ".";
         ДОБ(j)
      ИНАЧЕ
         j := 0
      КОНЕЦ;
      расшир_[j] := 0X;
      Реверс(расшир_);

      (* =====выделение пути к файлу====== *)
      j := счёт;
      ДЛЯ счёт := 0 ДО j ДЕЛАТЬ
         путь_[счёт] := файл_имя[счёт]
      КОНЕЦ;
      путь_[j + 1] := 0X
   КОНЕЦ Разделить;

ПРОЦЕДУРА Сравнить*(стр1, стр2: МАССИВ ИЗ ЛИТ): БУЛЕВО;
      ПЕРЕМ
            итер: ЦЕЛОЕ;
            конец_стр, совпад_литеры : БУЛЕВО;
      НАЧАЛО
            итер := -1;
            ПОВТОРЯТЬ
                  ДОБ(итер);
                  конец_стр := (стр1[итер] = 0X) ИЛИ (стр2[итер] = 0X);
                  совпад_литеры := Заглав(стр1[итер]) # Заглав(стр2[итер]);
            ПОКАНЕ (совпад_литеры) ИЛИ (конец_стр)
            ВЕРНУТЬ стр1[итер] = стр2[итер]
      КОНЕЦ Сравнить;

КОНЕЦ модСтроки.
