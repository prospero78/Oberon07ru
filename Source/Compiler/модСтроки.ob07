(* содержит определение строки и всякие полезняшки для обработки строк
        BSD-2
        *)
МОДУЛЬ модСтроки;

ИМПОРТ мКонст := модКонстанты,
     mSys := SYSTEM,
     мТипы := модТипы;

ТИПЫ
    тСтрока* = МАССИВ мКонст.макс_дл_пути ИЗ CHAR;

ПРОЦЕДУРА Стр_Реверс*(ПЕРЕМ стр_: тСтрока);
    ПЕРЕМ
        счет, длина: INTEGER;
        симв: CHAR;
    НАЧАЛО
        счет := 0;
        длина := LENGTH(стр_) - 1;
        ПОКА счет < длина ДЕЛАТЬ
            симв := стр_[счет];
            стр_[счет] := стр_[длина];
            стр_[длина] := симв;
            INC(счет);
            DEC(длина)
        КОНЕЦ
    КОНЕЦ Стр_Реверс;

ПРОЦЕДУРА Заглав*(симв_: CHAR): CHAR;
    НАЧАЛО
        ЕСЛИ (симв_ >= "a") & (симв_ <= "z") ТОГДА
             симв_ := CHR(ORD(симв_) - 32)
        АЕСЛИ (симв_ >= "а") & (симв_ <= "я") ТОГДА
             симв_ := CHR(ORD(симв_) - 32)
        ИНАЧЕ
        КОНЕЦ;
        ВЕРНУТЬ симв_
    КОНЕЦ Заглав;

ПРОЦЕДУРА Сложить*(L, R: МАССИВ ИЗ CHAR; ПЕР Res: МАССИВ ИЗ CHAR);
  ПЕРЕМ i, j: INTEGER;
  НАЧАЛО
    i := 0;
    ПОКА (L[i] # 0X) & (i - 1 < LEN(Res)) ДЕЛАТЬ
      Res[i] := L[i];
      INC(i)
    КОНЕЦ;
    j := 0;
    ПОКА (R[j] # 0X) & (j + i - 1 < LEN(Res)) ДЕЛАТЬ
      Res[j + i] := R[j];
      INC(j)
    КОНЕЦ;
    Res[j + i] := 0X
  КОНЕЦ Сложить;

ПРОЦЕДУРА Реверс*(ПЕР str: мТипы.тСтрока);
  ПЕРЕМ a, b: INTEGER; c: CHAR;
  НАЧАЛО
    a := 0;
    b := LENGTH(str) - 1;
    ПОКА a < b ДЕЛАТЬ
      c := str[a];
      str[a] := str[b];
      str[b] := c;
      INC(a);
      DEC(b)
    КОНЕЦ
  КОНЕЦ Реверс;

КОНЕЦ модСтроки.
