МОДУЛЬ X86;

(*
    Copyright 2013 Krotov Anton

    This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.
    *)

ИМПОРТ мУтиль := UTILS,
    sys := SYSTEM, SCAN,
    мКонст := modConstante,
    мСтр := modString,
    мСпис := modList,
    мФайл := modFile,
    мПроц := modProcess,
    мКонс := modConsole,
    мОш := modError,
    мКонстОш := modConstErr;

ТИПЫ

    PROC = ПРОЦЕДУРА (err: БУЛЕВО);

    тАсмУзел* = УКАЗАТЕЛЬ НА ЗАПИСЬ (мСпис.тУзел)
        cmd, clen, varadr, адр, tcmd, codeadr: ЦЕЛОЕ; short: БУЛЕВО
    КОНЕЦ;

    тВещДлин = МАССИВ 2 ИЗ ЦЕЛОЕ;

    tIdx* = МАССИВ мКонст._ADIM ИЗ ЦЕЛОЕ;

    тСекцияИмя = МАССИВ 8 ИЗ СИМВ;

    тСекция = ЗАПИСЬ
        секц_имя: тСекцияИмя;
        размер, адрес, sizealign, OAPfile, резерв6, резерв7, резерв8, attrflags: ЦЕЛОЕ
    КОНЕЦ;

    тЗаголовок = ЗАПИСЬ
        msdos: МАССИВ 180 ИЗ СИМВ;
        typecomp, seccount: sys.CARD16;
        время, резерв1, резерв2: ЦЕЛОЕ;
        PEoptsize, infflags, PEfile, compver: sys.CARD16;
        код_размер, данные_размер, initdatasize, адр_старт,
        адр_код, rdataadr, адр_загр, secalign, filealign,
        oldestver, version, oldestverNT, резерв3,
        файл_размер, headersize, dllcrc: ЦЕЛОЕ;
        UI, резерв4: sys.CARD16;
        стэк_разм, stkalloc, куча_размер, heapalloc, резерв5, structcount: ЦЕЛОЕ;
        structs: МАССИВ 16 ИЗ ЗАПИСЬ adr, size: ЦЕЛОЕ КОНЕЦ;
        секции: МАССИВ 3 ИЗ тСекция
    КОНЕЦ;

    тЗаголовокВин = ЗАПИСЬ
        Machine: sys.CARD16;
        секции_число: sys.CARD16;
        датаВремя_штамп,
        PointerToSymbolTable,
        NumberOfSymbols: ЦЕЛОЕ;
        SizeOfOptionalHeader,
        Characteristics: sys.CARD16;
        text, data, bss: тСекция
    КОНЕЦ;

    тЗаголовокКолибри = ЗАПИСЬ
        menuet01: МАССИВ 8 ИЗ СИМВ;
        ver, start, size, mem, sp, param, path: ЦЕЛОЕ
    КОНЕЦ;

    ETABLE = ЗАПИСЬ
        резерв1, время, reserved2, dllnameoffset, firstnum, adrcount,
        namecount, arradroffset, arrnameptroffset, arrnumoffset: ЦЕЛОЕ;
        arradr, arrnameptr: МАССИВ 10000H ИЗ ЦЕЛОЕ;
        arrnum: МАССИВ 10000H ИЗ sys.CARD16;
        text: МАССИВ 1000000 ИЗ СИМВ;
        textlen, size: ЦЕЛОЕ
    КОНЕЦ;

    тСмещение = ЗАПИСЬ
        Page, Size: ЦЕЛОЕ;
        reloc: МАССИВ 1024 ИЗ sys.CARD16
    КОНЕЦ;

ПЕРЕМ
    асм_спис: мСпис.туСписок;
    старт_узел: тАсмУзел;
    MemErr: PROC;
    dll, con, gui, kos, elf, obj: БУЛЕВО;
    Lcount, reccount, topstk: ЦЕЛОЕ;
    recarray: МАССИВ 2048 ИЗ ЦЕЛОЕ;
    асм_текущ*: тАсмУзел;
    callstk: МАССИВ 1024, 2 ИЗ тАсмУзел;
    файл_выход: мСтр.тСтрока;
    Code: МАССИВ 4000000 ИЗ СИМВ;
    ccount: ЦЕЛОЕ;
    данные_стр: МАССИВ 1000000 ИЗ СИМВ;
    dcount: ЦЕЛОЕ;
    метки: МАССИВ 200000 ИЗ ЦЕЛОЕ;
    rdata: МАССИВ 400H ИЗ ЦЕЛОЕ;
    Header: тЗаголовок;
    etable: ETABLE;
    файл_назв: мСтр.тСтрока;
    LoadAdr: ЦЕЛОЕ;
    Reloc: МАССИВ 200000 ИЗ СИМВ;
    rcount: ЦЕЛОЕ;
    RtlProc: МАССИВ 20 ИЗ ЦЕЛОЕ;
    OutFilePos: ЦЕЛОЕ;
    RelocSection: тСекция;
    felf: мСтр.тСтрока;
    fpu*: ЦЕЛОЕ;
    isfpu: БУЛЕВО;
    maxfpu: ЦЕЛОЕ;
    fpucmd: тАсмУзел;
    kosexp: МАССИВ 65536 ИЗ ЗАПИСЬ Name: SCAN.туУзел;
    Adr, NameLabel: ЦЕЛОЕ END;
    kosexpcount: ЦЕЛОЕ;

ПРОЦЕДУРА setfelf*(name: мСтр.тСтрока);
    НАЧАЛО
      felf := name
    КОНЕЦ setfelf;

ПРОЦЕДУРА AddRtlProc*(idx, proc: ЦЕЛОЕ);
    НАЧАЛО
      RtlProc[idx] := proc
    КОНЕЦ AddRtlProc;

ПРОЦЕДУРА IntToCard16(i: ЦЕЛОЕ): sys.CARD16;
    ПЕРЕМ w: sys.CARD16;
    НАЧАЛО
      sys.GET(sys.ADR(i), w)
      ВЕРНУТЬ w
    КОНЕЦ IntToCard16;

ПРОЦЕДУРА Строка_Копировать(ПЕРЕМ назнач_: МАССИВ ИЗ СИМВ; источник_: МАССИВ ИЗ СИМВ; ПЕРЕМ назн_итер_: ЦЕЛОЕ; ист_итер_: ЦЕЛОЕ);
    НАЧАЛО
      ВЫЧ(назн_итер_);
      ПОВТОРЯТЬ
        ДОБ(назн_итер_);
        назнач_[назн_итер_] := источник_[ист_итер_];
        ДОБ(ист_итер_)
      СНОВА назнач_[назн_итер_] = 0X
    КОНЕЦ Строка_Копировать;

ПРОЦЕДУРА Обменять(ПЕРЕМ пА_, пБ_: ЦЕЛОЕ);
    ПЕРЕМ
        перем: ЦЕЛОЕ;
    НАЧАЛО
      перем := пА_;
      пА_ := пБ_;
      пБ_ := перем
    КОНЕЦ Обменять;

ПРОЦЕДУРА Сортировать(ПЕРЕМ NamePtr, адр_мас_: МАССИВ ИЗ ЦЕЛОЕ; текст_: МАССИВ ИЗ СИМВ; гран_лев_, гран_прав_: ЦЕЛОЕ);
    ПЕРЕМ
        лев, прав: ЦЕЛОЕ;

    ПРОЦЕДУРА Стр_МеньшеРавно(стрА_длин_, стрБ_длин_: ЦЕЛОЕ): БУЛЕВО;
        ПЕРЕМ
            стрА, стрБ: МАССИВ 256 ИЗ СИМВ;
            итерА, итерБ: ЦЕЛОЕ;
        НАЧАЛО
            итерА := 0;
            Строка_Копировать(стрА, текст_, итерА, стрА_длин_);
            итерБ := 0;
            Строка_Копировать(стрБ, текст_, итерБ, стрБ_длин_);
            (* а как это сравнивается???
            ВЕРНУТЬ стрА <= стрБ *)
            ВЕРНУТЬ итерА <= итерБ
        КОНЕЦ Стр_МеньшеРавно;

    НАЧАЛО
        ЕСЛИ гран_лев_ < гран_прав_ ТОГДА
            лев := гран_лев_;
            прав := гран_прав_;
            ПОВТОРЯТЬ
                ПОКА (лев < гран_прав_) & Стр_МеньшеРавно(NamePtr[лев], NamePtr[гран_лев_]) ДЕЛАТЬ
                    ДОБ(лев)
                КОНЕЦ;
                ПОКА (прав > гран_лев_) & Стр_МеньшеРавно(NamePtr[гран_лев_], NamePtr[прав]) ДЕЛАТЬ
                    ВЫЧ(прав)
                КОНЕЦ;
                ЕСЛИ лев < прав ТОГДА
                    Обменять(NamePtr[лев], NamePtr[прав]);
                    Обменять(адр_мас_[лев], адр_мас_[прав])
                КОНЕЦ
                СНОВА лев >= прав;
                ЕСЛИ прав > гран_лев_ ТОГДА
                    Обменять(NamePtr[гран_лев_], NamePtr[прав]);
                    Обменять(адр_мас_[гран_лев_], адр_мас_[прав]);
                    Сортировать(NamePtr, адр_мас_, текст_, гран_лев_, прав - 1)
                КОНЕЦ;
                    Сортировать(NamePtr, адр_мас_, текст_, прав + 1, гран_прав_)
                КОНЕЦ
    КОНЕЦ Сортировать;

ПРОЦЕДУРА PackExport(Name: МАССИВ ИЗ СИМВ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      Сортировать(etable.arrnameptr, etable.arradr, etable.text, 0, etable.namecount - 1);
      ДЛЯ i := 0 ДО etable.namecount - 1 ДЕЛАТЬ
        etable.arrnum[i] := IntToCard16(i)
      КОНЕЦ;
      etable.size := 40 + etable.adrcount * 4 + etable.namecount * 6;
      etable.arradroffset := 40;
      etable.arrnameptroffset := 40 + etable.adrcount * 4;
      etable.arrnumoffset := etable.arrnameptroffset + etable.namecount * 4;
      etable.dllnameoffset := etable.size + etable.textlen;
      Строка_Копировать(etable.text, Name, etable.textlen, 0);
      ДОБ(etable.textlen);
      ДЛЯ i := 0 ДО etable.namecount - 1 ДЕЛАТЬ
        etable.arrnameptr[i] := etable.arrnameptr[i] + etable.size
      КОНЕЦ;
      etable.size := etable.size + etable.textlen
    КОНЕЦ PackExport;

ПРОЦЕДУРА ProcExport*(Number: ЦЕЛОЕ; Name: SCAN.туУзел; NameLabel: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ dll ТОГДА
        etable.arradr[etable.adrcount] := Number;
        ДОБ(etable.adrcount);
        etable.arrnameptr[etable.namecount] := etable.textlen;
        ДОБ(etable.namecount);
        Строка_Копировать(etable.text, Name.имя_узла, etable.textlen, 0);
        ДОБ(etable.textlen)
      АЕСЛИ obj ТОГДА
        kosexp[kosexpcount].Name := Name;
        kosexp[kosexpcount].Adr := Number;
        kosexp[kosexpcount].NameLabel := NameLabel;
        ДОБ(kosexpcount)
      КОНЕЦ
    КОНЕЦ ProcExport;

ПРОЦЕДУРА Выровнять*(n, m: ЦЕЛОЕ): ЦЕЛОЕ;
      ВЕРНУТЬ n + (m - n MOD m) MOD m
    КОНЕЦ Выровнять;

ПРОЦЕДУРА PutReloc(R: тСмещение);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      sys.PUT(sys.ADR(Reloc[rcount]), R.Page);
      ДОБ(rcount, 4);
      sys.PUT(sys.ADR(Reloc[rcount]), R.Size);
      ДОБ(rcount, 4);
      ДЛЯ i := 0 ДО ASR(R.Size - 8, 1) - 1 ДЕЛАТЬ
        sys.PUT(sys.ADR(Reloc[rcount]), R.reloc[i]);
        ДОБ(rcount, 2)
      КОНЕЦ
    КОНЕЦ PutReloc;

ПРОЦЕДУРА Массив_Настроить(ПЕРЕМ адр_: ЦЕЛОЕ; строка_: мСтр.тСтрока);
    ПЕРЕМ
        итер, код, длина: ЦЕЛОЕ;
    НАЧАЛО
        длина := LEN(строка_) - 1;
        итер := 0;
        ПОКА (итер < длина) & (строка_[итер] # 0X) ДЕЛАТЬ
            код := SCAN.Симв2hex(строка_[итер]) * 16 + SCAN.Симв2hex(строка_[итер + 1]);
            sys.PUT(адр_, CHR(код));
            ДОБ(адр_);
            ДОБ(итер, 2)
        КОНЕЦ
    КОНЕЦ Массив_Настроить;

ПРОЦЕДУРА Файл_Записать(файл_, адр_, число_байт_: ЦЕЛОЕ);
    НАЧАЛО
        ЕСЛИ мФайл.Записать(файл_, адр_, число_байт_) # число_байт_ ТОГДА
            мОш.Сообщ(мКонстОш._ош60); мКонс.Стр_Печать(файл_выход)
        КОНЕЦ
    КОНЕЦ Файл_Записать;

ПРОЦЕДУРА Записать(адр_, число_байт_: ЦЕЛОЕ);
    НАЧАЛО
      sys.MOVE(адр_, OutFilePos, число_байт_);
      OutFilePos := OutFilePos + число_байт_
    КОНЕЦ Записать;

ПРОЦЕДУРА Заполнить(колич_: ЦЕЛОЕ; симв_: СИМВ);
    ПЕРЕМ
        итер : ЦЕЛОЕ;
    НАЧАЛО
      ДЛЯ итер := 1 ДО колич_ ДЕЛАТЬ
        Записать(sys.ADR(симв_), 1)
      КОНЕЦ
    КОНЕЦ Заполнить;

ПРОЦЕДУРА SetSection(ПЕРЕМ Section: тСекция; name: тСекцияИмя; size, adr, sizealign, OAPfile, attrflags: ЦЕЛОЕ);
    НАЧАЛО
      Section.секц_имя := name;
      Section.размер := size;
      Section.адрес := adr;
      Section.sizealign := sizealign;
      Section.OAPfile := OAPfile;
      Section.attrflags := attrflags;
    КОНЕЦ SetSection;

ПРОЦЕДУРА WritePE(FName: МАССИВ ИЗ СИМВ; stksize, codesize, datasize, rdatasize, gsize: ЦЕЛОЕ);
    КОНСТ textattr = 60000020H; rdataattr = 40000040H; dataattr = 0C0000040H; relocattr = 42000040H;
    ПЕРЕМ i, F, adr, acodesize, compver, version, stkalloc, heapsize, heapalloc, filesize, filebuf: ЦЕЛОЕ;
        cur: тАсмУзел;
    НАЧАЛО

        compver := 0;
        version := 0;
        stkalloc := stksize;
        heapsize := 100000H;
        heapalloc := 100000H;
        acodesize := Выровнять(codesize, 1000H) + 1000H;
        adr := sys.ADR(rdata);
        filesize := acodesize + Выровнять(rdatasize, 1000H) + Выровнять(datasize, 1000H) + Выровнять(rcount, 1000H);

        Массив_Настроить(adr, "5000000040000000000000003400000000000000000000006200000000000000");
        Массив_Настроить(adr, "0000000000000000000000000000000000000000500000004000000000000000");
        Массив_Настроить(adr, "A4014C6F61644C6962726172794100001F0147657450726F6341646472657373");
        Массив_Настроить(adr, "00006B65726E656C33322E646C6C0000");

        rdata[ 0] := acodesize + 50H;
        rdata[ 1] := acodesize + 40H;
        rdata[ 3] := acodesize + 34H;
        rdata[ 6] := acodesize + 62H;
        rdata[ 7] := acodesize;
        rdata[13] := acodesize + 50H;
        rdata[14] := acodesize + 40H;

        adr := sys.ADR(Header.msdos);
        Массив_Настроить(adr, "4D5A90000300000004000000FFFF0000B8000000000000004000000000000000");
        Массив_Настроить(adr, "00000000000000000000000000000000000000000000000000000000B0000000");
        Массив_Настроить(adr, "0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F");
        Массив_Настроить(adr, "742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000");
        Массив_Настроить(adr, "5DCF9F8719AEF1D419AEF1D419AEF1D497B1E2D413AEF1D4E58EE3D418AEF1D4");
        Массив_Настроить(adr, "5269636819AEF1D4000000000000000050450000");
        Header.typecomp := IntToCard16(014CH);
        ЕСЛИ dll ТОГДА
            Header.seccount := IntToCard16(0004H);
            Header.infflags := IntToCard16(210EH)
        ИНАЧЕ
            Header.seccount := IntToCard16(0003H);
            Header.infflags := IntToCard16(010FH)
        КОНЕЦ;
        Header.время := мКонст._дата;
        Header.PEoptsize := IntToCard16(00E0H);
        Header.PEfile := IntToCard16(010BH);
        Header.compver := IntToCard16(compver);
        Header.код_размер := Выровнять(codesize, 200H);
        Header.данные_размер := Выровнять(datasize + gsize, 200H) + Выровнять(rdatasize, 200H) + Выровнять(rcount, 200H);
        Header.адр_старт := 1000H;
        Header.адр_код := 1000H;
        Header.rdataadr := Header.адр_код + Выровнять(codesize, 1000H);
        Header.адр_загр := LoadAdr;
        Header.secalign := 1000H;
        Header.filealign := 0200H;
        Header.oldestver := 0004H;
        Header.version := version;
        Header.oldestverNT := 0004H;
        Header.файл_размер := Выровнять(codesize, 1000H) + Выровнять(datasize + gsize, 1000H) + Выровнять(rdatasize, 1000H) + Выровнять(rcount, 1000H) + 1000H;
        Header.headersize := 0400H;
        Header.UI := IntToCard16(ORD(con) + 2);
        Header.стэк_разм := stksize;
        Header.stkalloc := stkalloc;
        Header.куча_размер := heapsize;
        Header.heapalloc := heapalloc;
        Header.structcount := 10H;
        ЕСЛИ dll ТОГДА
            Header.structs[0].adr := Header.rdataadr + 0DAH;
            Header.structs[0].size := etable.size
        КОНЕЦ;

        Header.structs[1].adr := Header.rdataadr + 0CH;
        Header.structs[1].size := 28H;
        Header.structs[12].adr := Header.rdataadr;
        Header.structs[12].size := 0CH;

        SetSection(Header.секции[0], ".text", codesize, 1000H, Выровнять(codesize, 200H), 400H,
                textattr);
        SetSection(Header.секции[1], ".rdata", rdatasize, Выровнять(codesize, 1000H) + 1000H,
                Выровнять(rdatasize, 200H), Выровнять(codesize, 200H) + 400H, rdataattr);
        SetSection(Header.секции[2], ".data", datasize + gsize, Выровнять(codesize, 1000H) +
                Выровнять(rdatasize, 1000H) + 1000H, Выровнять(datasize, 200H), Выровнять(codesize, 200H) +
                Выровнять(rdatasize, 200H) + 400H, dataattr);

        ЕСЛИ dll ТОГДА
            SetSection(RelocSection, ".reloc", rcount, Header.секции[2].адрес + Выровнять(datasize +
                    gsize, 1000H), Выровнять(rcount, 200H), Header.секции[2].OAPfile +
                    Выровнять(datasize, 200H), relocattr);
            Header.structs[5].adr := RelocSection.адрес;
            Header.structs[5].size := rcount
        КОНЕЦ;

        F := мФайл.Создать(FName);
        ЕСЛИ F = 0 ТОГДА
            мОш.Сообщ(мКонстОш._ош58); мКонс.Стр_Печать(файл_выход)
        КОНЕЦ;
        OutFilePos := мУтиль.ПамятьНов_Получ(filesize);
        filebuf := OutFilePos;
        мОш.Память(OutFilePos = 0);

        Записать(sys.ADR(Header), sys.SIZE(тЗаголовок));
        ЕСЛИ dll ТОГДА
            Записать(sys.ADR(RelocSection), sys.SIZE(тСекция));
            Заполнить(Выровнять(sys.SIZE(тЗаголовок) + sys.SIZE(тСекция), 200H) - (sys.SIZE(тЗаголовок) +
                    sys.SIZE(тСекция)), 0X)
        ИНАЧЕ
            Заполнить(Выровнять(sys.SIZE(тЗаголовок), 200H) - sys.SIZE(тЗаголовок), 0X)
        КОНЕЦ;

        cur := асм_спис.первый(тАсмУзел);
        ПОКА cur # ПУСТО ДЕЛАТЬ
            Записать(sys.ADR(Code[cur.cmd]), cur.clen);
            cur := cur.следующ(тАсмУзел)
        КОНЕЦ;
        Заполнить(Выровнять(codesize, 200H) - codesize, 0X);
        Записать(sys.ADR(rdata), 0DAH);
        ЕСЛИ dll ТОГДА
            etable.время := Header.время;
            Записать(sys.ADR(etable), 40);
            Записать(sys.ADR(etable.arradr), etable.adrcount * 4);
            Записать(sys.ADR(etable.arrnameptr), etable.namecount * 4);
            Записать(sys.ADR(etable.arrnum), etable.namecount * 2);
            Записать(sys.ADR(etable.text), etable.textlen)
        КОНЕЦ;
        Заполнить(Выровнять(rdatasize, 200H) - rdatasize, 0X);
        Записать(sys.ADR(данные_стр), datasize);
        Заполнить(Выровнять(datasize, 200H) - datasize, 0X);
        ЕСЛИ dll ТОГДА
            Записать(sys.ADR(Reloc), rcount);
            Заполнить(Выровнять(rcount, 200H) - rcount, 0X)
        КОНЕЦ;
        Файл_Записать(F, filebuf, OutFilePos - filebuf);
        мФайл.Закрыть(F)
    КОНЕЦ WritePE;

ПРОЦЕДУРА Узел_Новый;
    ПЕРЕМ
        узел_новый: тАсмУзел;
    НАЧАЛО
        НОВ(узел_новый);
        MemErr(узел_новый = ПУСТО);
        узел_новый.cmd := ccount;
        мСпис.Вставить(асм_спис, узел_новый, асм_текущ);
        асм_текущ := асм_текущ.следующ(тАсмУзел)
    КОНЕЦ Узел_Новый;

ПРОЦЕДУРА Empty(varadr: ЦЕЛОЕ);
    НАЧАЛО
        Узел_Новый;
        асм_текущ.clen := 0;
        асм_текущ.tcmd := мКонст._ECMD;
        асм_текущ.varadr := varadr
    КОНЕЦ Empty;

ПРОЦЕДУРА OutByte(byte: ЦЕЛОЕ);
    НАЧАЛО
      Узел_Новый;
      асм_текущ.clen := 1;
      Code[ccount] := CHR(byte);
      ДОБ(ccount)
    КОНЕЦ OutByte;

ПРОЦЕДУРА OutInt(int: ЦЕЛОЕ);
    НАЧАЛО
      Узел_Новый;
      асм_текущ.clen := 4;
      sys.PUT(sys.ADR(Code[ccount]), int);
      ДОБ(ccount, 4)
    КОНЕЦ OutInt;

ПРОЦЕДУРА PushEAX;
    НАЧАЛО
      OutByte(50H);
      асм_текущ.tcmd := мКонст._PUSHEAX
    КОНЕЦ PushEAX;

ПРОЦЕДУРА PushECX;
    НАЧАЛО
      OutByte(51H);
      асм_текущ.tcmd := мКонст._PUSHECX
    КОНЕЦ PushECX;

ПРОЦЕДУРА PushEDX;
    НАЧАЛО
      OutByte(52H);
      асм_текущ.tcmd := мКонст._PUSHEDX
    КОНЕЦ PushEDX;

ПРОЦЕДУРА PopEAX;
    НАЧАЛО
      OutByte(58H);
      асм_текущ.tcmd := мКонст._POPEAX
    КОНЕЦ PopEAX;

ПРОЦЕДУРА PopECX;
    НАЧАЛО
      OutByte(59H);
      асм_текущ.tcmd := мКонст._POPECX
    КОНЕЦ PopECX;

ПРОЦЕДУРА PopEDX;
    НАЧАЛО
      OutByte(5AH);
      асм_текущ.tcmd := мКонст._POPEDX
    КОНЕЦ PopEDX;

ПРОЦЕДУРА OutCode(cmd: мСтр.тСтрока);
    ПЕРЕМ a, b: ЦЕЛОЕ;
    НАЧАЛО
      Узел_Новый;
      a := sys.ADR(Code[ccount]);
      b := a;
      Массив_Настроить(a, cmd);
      ccount := a - b + ccount;
      асм_текущ.clen := a - b
    КОНЕЦ OutCode;

ПРОЦЕДУРА Del*(last: тАсмУзел);
    НАЧАЛО
      last.следующ := асм_текущ.следующ;
      ЕСЛИ асм_текущ = асм_спис.последний ТОГДА
        асм_спис.последний := last
      КОНЕЦ;
      асм_текущ := last
    КОНЕЦ Del;

ПРОЦЕДУРА МеткаяНовая_Получ*(): ЦЕЛОЕ;
    НАЧАЛО
      ДОБ(Lcount)
      ВЕРНУТЬ Lcount
    КОНЕЦ МеткаяНовая_Получ;

ПРОЦЕДУРА PushCall*(asmline: тАсмУзел);
    НАЧАЛО
      Узел_Новый;
      callstk[topstk][0] := asmline;
      callstk[topstk][1] := асм_текущ;
      ДОБ(topstk)
    КОНЕЦ PushCall;

ПРОЦЕДУРА Param*;
    НАЧАЛО
      асм_текущ := callstk[topstk - 1][0]
    КОНЕЦ Param;

ПРОЦЕДУРА EndCall*;
    НАЧАЛО
      асм_текущ := callstk[topstk - 1][1];
      ВЫЧ(topstk)
    КОНЕЦ EndCall;

ПРОЦЕДУРА Init*(mem: PROC; UI: ЦЕЛОЕ);
    ПЕРЕМ nov: тАсмУзел;
    НАЧАЛО
      dcount := 4;
      dll := UI = 1;
      gui := UI = 2;
      con := UI = 3;
      kos := UI = 4;
      elf := UI = 5;
      obj := UI = 6;
      MemErr := mem;
      Lcount := мКонст._HALT;
      асм_спис := мСпис.Создать();
      MemErr(асм_спис = ПУСТО);
      NEW(nov);
      MemErr(nov = ПУСТО);
      мСпис.Добавить(асм_спис, nov);
      асм_текущ := nov;
    КОНЕЦ Init;

ПРОЦЕДУРА datastr(str: мСтр.тСтрока);
    ПЕРЕМ i, n: ЦЕЛОЕ;
    НАЧАЛО
      i := 0;
      n := LEN(str);
      ПОКА (i < n) & (str[i] # 0X) ДЕЛАТЬ
        данные_стр[dcount] := str[i];
        ДОБ(dcount);
        ДОБ(i)
      КОНЕЦ;
      данные_стр[dcount] := 0X;
      ДОБ(dcount)
    КОНЕЦ datastr;

ПРОЦЕДУРА dataint(n: ЦЕЛОЕ);
    НАЧАЛО
      sys.PUT(sys.ADR(данные_стр[dcount]), n);
      ДОБ(dcount, 4)
    КОНЕЦ dataint;

ПРОЦЕДУРА jmp*(jamp: СИМВ; label: ЦЕЛОЕ);
    ПЕРЕМ n: ЦЕЛОЕ;
    НАЧАЛО
      Узел_Новый;
      ВЫБРАТЬ jamp ИЗ
      |мКонст._JMP, мКонст._CALL:
        n := 5
      |мКонст._JE, мКонст._JLE, мКонст._JGE, мКонст._JG, мКонст._JL, мКонст._JNE:
        Code[ccount] := 0FX;
        ДОБ(ccount);
        n := 6
      ИНАЧЕ
      КОНЕЦ;
      асм_текущ.clen := n;
      Code[ccount] := jamp;
      ДОБ(ccount);
      асм_текущ.codeadr := sys.ADR(Code[ccount]);
      асм_текущ.varadr := sys.ADR(метки[label]);
      асм_текущ.tcmd := мКонст._JCMD;
      асм_текущ.short := ИСТИНА;
      ДОБ(ccount, 4)
    КОНЕЦ jmp;

ПРОЦЕДУРА jmplong(jamp: СИМВ; label: ЦЕЛОЕ);
    НАЧАЛО
      jmp(jamp, label);
      асм_текущ.short := ЛОЖЬ
    КОНЕЦ jmplong;

ПРОЦЕДУРА Label*(label: ЦЕЛОЕ);
    НАЧАЛО
      Узел_Новый;
      асм_текущ.varadr := sys.ADR(метки[label]);
      асм_текущ.tcmd := мКонст._LCMD
    КОНЕЦ Label;

ПРОЦЕДУРА CmdN(Number: ЦЕЛОЕ);
    НАЧАЛО
      Узел_Новый;
      асм_текущ.clen := 4;
      асм_текущ.codeadr := sys.ADR(Code[ccount]);
      асм_текущ.varadr := sys.ADR(метки[Number]);
      асм_текущ.tcmd := мКонст._OCMD;
      ДОБ(ccount, 4)
    КОНЕЦ CmdN;

ПРОЦЕДУРА IntByte(bytecode, intcode: мСтр.тСтрока; n: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ (n <= 127) & (n >= -128) ТОГДА
        OutCode(bytecode);
        OutByte(n)
      ИНАЧЕ
        OutCode(intcode);
        OutInt(n)
      КОНЕЦ
    КОНЕЦ IntByte;

ПРОЦЕДУРА DropFpu*(long: БУЛЕВО);
    НАЧАЛО
      ЕСЛИ long ТОГДА
        OutCode("83EC08DD1C24")
      ИНАЧЕ
        OutCode("83EC04D91C24")
      КОНЕЦ;
      ВЫЧ(fpu)
    КОНЕЦ DropFpu;

ПРОЦЕДУРА AfterRet(func, float: БУЛЕВО; callconv, parsize: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ callconv = мКонст._cdecl ТОГДА
        OutCode("81C4");
        OutInt(parsize)
      КОНЕЦ;
      ЕСЛИ func ТОГДА
        ЕСЛИ float ТОГДА
          OutCode("83EC08DD1C24")
        ИНАЧЕ
          PushEAX
        КОНЕЦ
      КОНЕЦ
    КОНЕЦ AfterRet;

ПРОЦЕДУРА FpuSave(local: ЦЕЛОЕ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ fpu > maxfpu ТОГДА
        maxfpu := fpu
      КОНЕЦ;
      ДЛЯ i := 1 ДО fpu ДЕЛАТЬ
        IntByte("DD5D", "DD9D", -local - i * 8)
      КОНЕЦ
    КОНЕЦ FpuSave;

ПРОЦЕДУРА Incfpu;
    НАЧАЛО
        ЕСЛИ fpu >= мКонст._FREGS ТОГДА
            мУтиль.ОшибПоз_Печать(SCAN.строка_ном, SCAN.позиц_глоб, 97);
            мПроц.Выход(1)
        КОНЕЦ;
        ДОБ(fpu);
        isfpu := ИСТИНА
    КОНЕЦ Incfpu;

ПРОЦЕДУРА FpuLoad(local: ЦЕЛОЕ; float: БУЛЕВО);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ДЛЯ i := fpu ДО 1 ПО -1 ДЕЛАТЬ
        IntByte("DD45", "DD85", -local - i * 8)
      КОНЕЦ;
      ЕСЛИ float ТОГДА
        Incfpu;
        OutCode("DD042483C408")
      КОНЕЦ
    КОНЕЦ FpuLoad;

ПРОЦЕДУРА Call*(proc: ЦЕЛОЕ; func, float: БУЛЕВО; callconv, ccall, bases, level, parsize, local: ЦЕЛОЕ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ ccall # 0 ТОГДА
        ДЛЯ i := level ДО level - bases + ORD(ccall = 1) + 1 ПО -1 ДЕЛАТЬ
          IntByte("FF75", "FFB5", 4 * i + 4)
        КОНЕЦ;
        ЕСЛИ ccall = 1 ТОГДА
          OutByte(55H)
        КОНЕЦ
      КОНЕЦ;
      FpuSave(local);
      jmplong(мКонст._CALL, proc);
      AfterRet(func, float, callconv, parsize);
      FpuLoad(local, func & float)
    КОНЕЦ Call;

ПРОЦЕДУРА CallRTL(Proc: ЦЕЛОЕ);
    НАЧАЛО
      Узел_Новый;
      асм_текущ.clen := 5;
      Code[ccount] := мКонст._CALL;
      ДОБ(ccount);
      асм_текущ.codeadr := sys.ADR(Code[ccount]);
      асм_текущ.varadr := sys.ADR(RtlProc[Proc]);
      асм_текущ.tcmd := мКонст._JCMD;
      ДОБ(ccount, 4)
    КОНЕЦ CallRTL;

ПРОЦЕДУРА PushInt*(n: ЦЕЛОЕ);
    НАЧАЛО
      OutByte(68H);
      CmdN(n)
    КОНЕЦ PushInt;

ПРОЦЕДУРА Prolog*(exename: мСтр.тСтрока);
    НАЧАЛО
      файл_назв := exename;
      метки[мКонст._hInstance] := -dcount;
      dataint(0);
      метки[мКонст._SELFNAME] := -dcount;
      datastr(exename);
      Label(мКонст._START);
      ЕСЛИ dll ТОГДА
        OutCode("558BEC837D0C007507");
        CallRTL(мКонст._close);
        OutCode("EB06837D0C017409B801000000C9C20C00")
      АЕСЛИ obj ТОГДА
        OutCode("558BEC")
      КОНЕЦ;
      старт_узел := асм_спис.последний(тАсмУзел)
    КОНЕЦ Prolog;

ПРОЦЕДУРА AddRec*(base: ЦЕЛОЕ);
    НАЧАЛО
      ДОБ(reccount);
      recarray[reccount] := base
    КОНЕЦ AddRec;

ПРОЦЕДУРА CmpOpt(inv: БУЛЕВО): ЦЕЛОЕ;
    ПЕРЕМ cur: тАсмУзел; c: ЦЕЛОЕ;
    НАЧАЛО
      c := ORD(Code[асм_текущ.предыдущ.предыдущ(тАсмУзел).cmd]);
      ЕСЛИ inv ТОГДА
        ЕСЛИ ODD(c) ТОГДА
          ВЫЧ(c)
        ИНАЧЕ
          ДОБ(c)
        КОНЕЦ
      КОНЕЦ;
      cur := асм_текущ;
      ПОВТОРЯТЬ
        cur.tcmd := 0;
        cur.clen := 0;
        cur := cur.предыдущ(тАсмУзел)
      СНОВА cur.tcmd = мКонст._ICMP1;
      cur.tcmd := 0;
      cur.clen := 0
      ВЕРНУТЬ c - 16
    КОНЕЦ CmpOpt;

ПРОЦЕДУРА ifwh*(L: ЦЕЛОЕ);
    ПЕРЕМ c: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ асм_текущ.предыдущ(тАсмУзел).tcmd = мКонст._ICMP2 ТОГДА
        c := CmpOpt(ИСТИНА);
        OutCode("5A583BC2");
        jmp(CHR(c), L)
      ИНАЧЕ
        PopECX;
        OutCode("85C9");
        jmp(мКонст._JE, L)
      КОНЕЦ
    КОНЕЦ ifwh;

ПРОЦЕДУРА PushConst*(Number: ЦЕЛОЕ);
    НАЧАЛО
      IntByte("6A", "68", Number);
      асм_текущ.предыдущ(тАсмУзел).varadr := Number
    КОНЕЦ PushConst;

ПРОЦЕДУРА IfWhile*(L: ЦЕЛОЕ; orop: БУЛЕВО);
    ПЕРЕМ c, L1: ЦЕЛОЕ;
    НАЧАЛО
      L1 := МеткаяНовая_Получ();
      ЕСЛИ асм_текущ.предыдущ(тАсмУзел).tcmd = мКонст._ICMP2 ТОГДА
        c := CmpOpt(orop);
        OutCode("5A583BC2");
        jmp(CHR(c), L1);
        PushConst(ORD(orop))
      ИНАЧЕ
        PopECX;
        OutCode("85C9");
        ЕСЛИ orop ТОГДА
          jmp(мКонст._JE, L1)
        ИНАЧЕ
          jmp(мКонст._JNE, L1)
        КОНЕЦ;
        PushECX
      КОНЕЦ;
      jmp(мКонст._JMP, L);
      Label(L1)
    КОНЕЦ IfWhile;

ПРОЦЕДУРА newrec*;
        НАЧАЛО
          CallRTL(мКонст._newrec)
        КОНЕЦ newrec;

ПРОЦЕДУРА disprec*;
        НАЧАЛО
          CallRTL(мКонст._disprec)
        КОНЕЦ disprec;

ПРОЦЕДУРА String*(Number, Len: ЦЕЛОЕ; str: мСтр.тСтрока);
    НАЧАЛО
      метки[Number] := -dcount;
      ЕСЛИ Len > 1 ТОГДА
        datastr(str)
      АЕСЛИ Len = 1 ТОГДА
        dataint(ORD(str[0]))
      ИНАЧЕ
        dataint(0)
      КОНЕЦ
    КОНЕЦ String;

ПРОЦЕДУРА InsertFpuInit;
    ПЕРЕМ t: тАсмУзел;
    НАЧАЛО
      ЕСЛИ isfpu ТОГДА
        t := асм_текущ;
        асм_текущ := fpucmd;
        ЕСЛИ maxfpu > 0 ТОГДА
          OutCode("83EC");
          OutByte(maxfpu * 8)
        КОНЕЦ;
        OutCode("DBE3");
        асм_текущ := t
      КОНЕЦ
    КОНЕЦ InsertFpuInit;

ПРОЦЕДУРА ProcBeg*(Number, Local: ЦЕЛОЕ; Module: БУЛЕВО);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ЕСЛИ Module ТОГДА
        OutCode("EB0C");
        Label(Number + 3);
        PushInt(Number + 2);
        jmplong(мКонст._JMP, мКонст._HALT);
        Label(Number + 1)
      ИНАЧЕ
        Label(Number)
      КОНЕЦ;
      OutCode("558BEC");
      ЕСЛИ Local > 12 ТОГДА
        IntByte("83EC", "81EC", Local);
        OutCode("8BD733C08BFCB9");
        OutInt(ASR(Local, 2));
        OutCode("9CFCF3AB8BFA9D")
      ИНАЧЕ
        ДЛЯ i := 4 ДО Local ПО 4 ДЕЛАТЬ
          OutCode("6A00")
        КОНЕЦ
      КОНЕЦ;
      fpucmd := асм_текущ;
      fpu := 0;
      maxfpu := 0;
      isfpu := ЛОЖЬ
    КОНЕЦ ProcBeg;

ПРОЦЕДУРА Leave*;
    НАЧАЛО
      OutByte(0C9H);
      InsertFpuInit
    КОНЕЦ Leave;

ПРОЦЕДУРА ProcEnd*(Number, Param: ЦЕЛОЕ; func, float: БУЛЕВО);
    НАЧАЛО
      ЕСЛИ func & ~float ТОГДА
        PopEAX
      КОНЕЦ;
      OutByte(0C9H);
      ЕСЛИ Param = 0 ТОГДА
        OutByte(0C3H)
      ИНАЧЕ
        OutByte(0C2H);
        OutByte(Param MOD 256);
        OutByte(ASR(Param, 8))
      КОНЕЦ;
      InsertFpuInit
    КОНЕЦ ProcEnd;

ПРОЦЕДУРА Module*(Name: мСтр.тСтрока; Number: ЦЕЛОЕ);
    НАЧАЛО
      String(Number + 2, LENGTH(Name), Name);
      jmplong(мКонст._JMP, Number + 1)
    КОНЕЦ Module;

ПРОЦЕДУРА Asm*(s: мСтр.тСтрока);
    НАЧАЛО
      OutCode(s)
    КОНЕЦ Asm;

ПРОЦЕДУРА GlobalAdr*(offset: ЦЕЛОЕ);
    НАЧАЛО
      OutByte(0BAH);
      OutInt(offset);
      асм_текущ.codeadr := sys.ADR(Code[ccount - 4]);
      асм_текущ.tcmd := мКонст._GCMD;
      PushEDX
    КОНЕЦ GlobalAdr;

ПРОЦЕДУРА Mono*(Number: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      PushInt(Number)
    КОНЕЦ Mono;

ПРОЦЕДУРА StrMono*;
    НАЧАЛО
      PopEDX;
      OutCode("6A02");
      PushEDX
    КОНЕЦ StrMono;

ПРОЦЕДУРА Not*;
    НАЧАЛО
      PopECX;
      OutCode("85C90F94C1");
      PushECX
    КОНЕЦ Not;

ПРОЦЕДУРА NegSet*;
    НАЧАЛО
      OutCode("F71424")
    КОНЕЦ NegSet;

ПРОЦЕДУРА Int*(Op: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      ВЫБРАТЬ Op ИЗ
      |мКонст._опПлюс:  OutCode("011424")
      |мКонст._опМинус: OutCode("291424")
      |мКонст._опУмнож:  OutCode("58F7EA"); PushEAX
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ Int;

ПРОЦЕДУРА Set*(Op: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      OutCode("58");
      ВЫБРАТЬ Op ИЗ
      |мКонст._опПлюс:  OutCode("0B")
      |мКонст._опМинус: OutCode("F7D223")
      |мКонст._опУмнож:  OutCode("23")
      |мКонст._опДел: OutCode("33")
      ИНАЧЕ
      КОНЕЦ;
      OutCode("C2");
      PushEAX
    КОНЕЦ Set;

ПРОЦЕДУРА Setfpu*(newfpu: ЦЕЛОЕ);
    НАЧАЛО
      fpu := newfpu
    КОНЕЦ Setfpu;

ПРОЦЕДУРА PushFlt*(x: ДЛИНВЕЩ);
    ПЕРЕМ f: тВещДлин; L: ЦЕЛОЕ;
    НАЧАЛО
      sys.PUT(sys.ADR(f), x);
      Incfpu;
      ЕСЛИ x = 0.0D0 ТОГДА
        OutCode("D9EE")
      АЕСЛИ x = 1.0D0 ТОГДА
        OutCode("D9E8")
      ИНАЧЕ
        L := МеткаяНовая_Получ();
        метки[L] := -dcount;
        dataint(f[0]);
        dataint(f[1]);
        OutByte(0BAH);
        CmdN(L);
        OutCode("DD02")
      КОНЕЦ
    КОНЕЦ PushFlt;

ПРОЦЕДУРА farith*(op: ЦЕЛОЕ);
    ПЕРЕМ n: ЦЕЛОЕ;
    НАЧАЛО
      OutCode("DE");
      ВЫБРАТЬ op ИЗ
      |мКонст._опПлюс:  n := 0C1H
      |мКонст._опМинус: n := 0E9H
      |мКонст._опУмнож:  n := 0C9H
      |мКонст._опДел: n := 0F9H
      ИНАЧЕ
      КОНЕЦ;
      OutByte(n);
      ВЫЧ(fpu)
    КОНЕЦ farith;

ПРОЦЕДУРА fcmp*(Op: ЦЕЛОЕ);
    ПЕРЕМ n: ЦЕЛОЕ;
    НАЧАЛО
      OutCode("33C9DED9DFE09E0F");
      ВЫБРАТЬ Op ИЗ
      |мКонст._опРавно: n := 94H
      |мКонст._опНеРавно: n := 95H
      |мКонст._опМеньше: n := 97H
      |мКонст._опБольше: n := 92H
      |мКонст._lexLE: n := 93H
      |мКонст._lexGE: n := 96H
      ИНАЧЕ
      КОНЕЦ;
      ВЫЧ(fpu, 2);
      OutByte(n);
      OutByte(0C1H);
      PushECX
    КОНЕЦ fcmp;

ПРОЦЕДУРА fneg*;
    НАЧАЛО
      OutCode("D9E0")
    КОНЕЦ fneg;

ПРОЦЕДУРА OnError*(n: ЦЕЛОЕ);
    НАЧАЛО
      OutByte(68H);
      OutInt(мУтиль.строка * 16 + n);
      jmplong(мКонст._JMP, мУтиль.юнит + 3)
    КОНЕЦ OnError;

ПРОЦЕДУРА idivmod*(opmod: БУЛЕВО);
    НАЧАЛО
      PopECX;
      ЕСЛИ opmod ТОГДА
        OutCode("58E32E538BD833D9C1FB1F8BD0C1FA1F83F9FF750C3D0000008075055B6A00EB1AF7F985DB740685D2740203D15B52EB0A")
      ИНАЧЕ
        OutCode("58E32C538BD833D9C1FB1F8BD0C1FA1F83F9FF750B3D0000008075045B50EB19F7F985DB740585D27401485B50EB0A")
      КОНЕЦ;
      OnError(8)
    КОНЕЦ idivmod;

ПРОЦЕДУРА rset*;
    НАЧАЛО
      CallRTL(мКонст._rset);
      PushEAX
    КОНЕЦ rset;

ПРОЦЕДУРА inset*;
    НАЧАЛО
      CallRTL(мКонст._inset);
      PushEAX
    КОНЕЦ inset;

ПРОЦЕДУРА Dup*;
    НАЧАЛО
      PopEDX;
      PushEDX;
      PushEDX
    КОНЕЦ Dup;

ПРОЦЕДУРА Inclusion*(Op: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      PopEAX;
      ЕСЛИ Op = мКонст._lexLE ТОГДА
        PushEDX
      ИНАЧЕ
        PushEAX
      КОНЕЦ;
      OutCode("0BC25933C8E3046A00EB026A01")
    КОНЕЦ Inclusion;

ПРОЦЕДУРА NegInt*;
    НАЧАЛО
      OutCode("F71C24")
    КОНЕЦ NegInt;

ПРОЦЕДУРА CmpInt*(Op: ЦЕЛОЕ);
    ПЕРЕМ n: ЦЕЛОЕ;
    НАЧАЛО
      OutCode("33C95A583BC20F"); асм_текущ.tcmd := мКонст._ICMP1;
      ВЫБРАТЬ Op ИЗ
      |мКонст._опРавно: n := 94H
      |мКонст._опНеРавно: n := 95H
      |мКонст._опМеньше: n := 9CH
      |мКонст._опБольше: n := 9FH
      |мКонст._lexLE: n := 9EH
      |мКонст._lexGE: n := 9DH
      ИНАЧЕ
      КОНЕЦ;
      OutByte(n);
      OutCode("C1"); асм_текущ.tcmd := мКонст._ICMP2;
      PushECX;
    КОНЕЦ CmpInt;

ПРОЦЕДУРА CallVar*(func, float: БУЛЕВО; callconv, parsize, local: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      OutCode("8B1285D2750A");
      OnError(2);
      FpuSave(local);
      OutCode("FFD2");
      AfterRet(func, float, callconv, parsize);
      FpuLoad(local, func & float)
    КОНЕЦ CallVar;

ПРОЦЕДУРА LocalAdr*(offset, bases: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ bases = 0 ТОГДА
        Empty(offset);
        OutCode("8BD5")
      ИНАЧЕ
        IntByte("8B55", "8B95", 4 * bases + 4)
      КОНЕЦ;
      IntByte("83C2", "81C2", offset);
      PushEDX;
      ЕСЛИ bases = 0 ТОГДА
        Empty(offset)
      КОНЕЦ
    КОНЕЦ LocalAdr;

ПРОЦЕДУРА Field*(offset: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ offset # 0 ТОГДА
        IntByte("830424", "810424", offset)
      КОНЕЦ
    КОНЕЦ Field;

ПРОЦЕДУРА DerefType*(n: ЦЕЛОЕ);
    НАЧАЛО
      IntByte("8B5424", "8B9424", n);
      OutCode("FF72FC")
    КОНЕЦ DerefType;

ПРОЦЕДУРА Guard*(T: ЦЕЛОЕ; Check: БУЛЕВО);
    НАЧАЛО
      ЕСЛИ Check ТОГДА
        PopEAX;
        OutCode("85C074");
        ЕСЛИ T <= 127 ТОГДА
          OutByte(9)
        ИНАЧЕ
          OutByte(12)
        КОНЕЦ;
        PushEAX
      КОНЕЦ;
      PushConst(T);
      PushEAX;
      CallRTL(мКонст._checktype);
      ЕСЛИ Check ТОГДА
        PushEAX
      ИНАЧЕ
        OutCode("85C0750A");
        OnError(3)
      КОНЕЦ
    КОНЕЦ Guard;

ПРОЦЕДУРА StProc*(proc: ЦЕЛОЕ);
    НАЧАЛО
      ВЫБРАТЬ proc ИЗ
      |мКонст._stINC:   PopEDX; OutCode("590111")
      |мКонст._stDEC:   PopEDX; OutCode("592911")
      |мКонст._stINC1:  PopEDX; OutCode("FF02")
      |мКонст._stDEC1:  PopEDX; OutCode("FF0A")
      |мКонст._stINCL:  PopEDX; OutCode("580910")
      |мКонст._stEXCL:  PopEDX; OutCode("582110")
      |мКонст._sysBIT:  PopECX; OutCode("5A585333DB8A18E3050FABD3EB030FB3D388185B")
      |мКонст._stPACK:  OutCode("DB04245A5ADD02D9FDDD1A"); isfpu := ИСТИНА
      |мКонст._stPACK1: OutCode("DB04245A5AD902D9FDD91A"); isfpu := ИСТИНА
      |мКонст._stUNPK:  PopEDX; OutCode("59DD01D9F4DD19DB1A"); isfpu := ИСТИНА
      |мКонст._stUNPK1: PopEDX; OutCode("59D901D9F4D919DB1A"); isfpu := ИСТИНА
      |мКонст._stCOPY:  CallRTL(мКонст._strcopy)
      |мКонст._sysMOVE: CallRTL(мКонст._savearr)
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ StProc;

ПРОЦЕДУРА Assert*(proc, assrt: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      OutCode("85D2751368");
      OutInt(мУтиль.строка * 16 + 1);
      PushInt(мУтиль.юнит + 2);
      ЕСЛИ proc = мКонст._stASSERT ТОГДА
        OutCode("6A026A")
      ИНАЧЕ
        OutCode("6A016A")
      КОНЕЦ;
      OutByte(assrt);
      jmplong(мКонст._JMP, мКонст._ASSRT)
    КОНЕЦ Assert;

ПРОЦЕДУРА StFunc*(func: ЦЕЛОЕ);
    НАЧАЛО
      ВЫБРАТЬ func ИЗ
      |мКонст._stABS:    PopEDX; OutCode("85D27D02F7DA"); PushEDX
      |мКонст._stFABS:   OutCode("D9E1")
      |мКонст._stFLT:    OutCode("DB0424"); PopEAX; Incfpu;
      |мКонст._stFLOOR:  OutCode("83EC06D93C2466812424FFF366810C24FFF7D92C2483C402D9FCDB1C24"); ВЫЧ(fpu)
      |мКонст._stODD:    OutCode("83242401")
      |мКонст._stROR:    PopECX; OutCode("58D3C8"); PushEAX
      |мКонст._stASR:    PopECX; OutCode("58D3F8"); PushEAX
      |мКонст._stLSL:    PopECX; OutCode("58D3E0"); PushEAX
      |мКонст._stLSR:    PopECX; OutCode("58D3E8"); PushEAX
      |мКонст._stORD:    PopEDX; OutCode("85D274036A015A"); PushEDX
      |мКонст._stLENGTH: CallRTL(мКонст._length); PushEAX
      |мКонст._sysBIT:   PopEDX; OutCode("5933C08A010FA3D072046A00EB026A01")
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ StFunc;

ПРОЦЕДУРА Load*(T: ЦЕЛОЕ);
    ПЕРЕМ lastcmd: тАсмУзел; offset: ЦЕЛОЕ;

      ПРОЦЕДУРА del;
      НАЧАЛО
        lastcmd.tcmd := 0;
        offset := lastcmd.varadr;
        lastcmd := lastcmd.предыдущ(тАсмУзел);
        ПОКА lastcmd.tcmd # мКонст._ECMD ДЕЛАТЬ
          lastcmd.clen := 0;
          lastcmd.tcmd := 0;
          lastcmd := lastcmd.предыдущ(тАсмУзел)
        КОНЕЦ;
        lastcmd.tcmd := 0
      КОНЕЦ del;

    НАЧАЛО
  lastcmd := асм_текущ;
  ВЫБРАТЬ T ИЗ
  |мКонст._тЦелое, мКонст._TSET, мКонст._тУказатель, мКонст._TPROC:
    ЕСЛИ lastcmd.tcmd = мКонст._ECMD ТОГДА
      del;
      IntByte("8B55", "8B95", offset);
      PushEDX
    ИНАЧЕ
      PopEDX;
      OutCode("FF32")
    КОНЕЦ
  |мКонст._тСимвол, мКонст._тБулево:
    ЕСЛИ lastcmd.tcmd = мКонст._ECMD ТОГДА
      del;
      OutCode("33D28A");
      IntByte("55", "95", offset);
      PushEDX
    ИНАЧЕ
      PopEDX;
      OutCode("33C98A0A");
      PushECX
    КОНЕЦ
  |мКонст._тДлинВещ:
    ЕСЛИ lastcmd.tcmd = мКонст._ECMD ТОГДА
      del;
      IntByte("DD45", "DD85", offset)
    ИНАЧЕ
      PopEDX;
      OutCode("DD02")
    КОНЕЦ;
    Incfpu
  |мКонст._тВеществ:
    ЕСЛИ lastcmd.tcmd = мКонст._ECMD ТОГДА
      del;
      IntByte("D945", "D985", offset)
    ИНАЧЕ
      PopEDX;
      OutCode("D902")
    КОНЕЦ;
    Incfpu
  |мКонст._TCARD16:
    ЕСЛИ lastcmd.tcmd = мКонст._ECMD ТОГДА
      del;
      OutCode("33D2668B");
      IntByte("55", "95", offset);
      PushEDX
    ИНАЧЕ
      PopEDX;
      OutCode("33C9668B0A");
      PushECX
    КОНЕЦ
  ИНАЧЕ
  КОНЕЦ
    КОНЕЦ Load;

ПРОЦЕДУРА Save*(T: ЦЕЛОЕ);
    НАЧАЛО
      ВЫБРАТЬ T ИЗ
      |мКонст._тЦелое, мКонст._TSET, мКонст._тУказатель, мКонст._TPROC:
        PopEDX;
        OutCode("588910")
      |мКонст._тСимвол, мКонст._тСтрока, мКонст._тБулево:
        PopEDX;
        OutCode("588810")
      |мКонст._TCARD16:
        PopEDX;
        OutCode("58668910")
      |мКонст._тДлинВещ:
        PopEDX;
        OutCode("DD1A");
        ВЫЧ(fpu)
      |мКонст._тВеществ:
        PopEDX;
        OutCode("D91A");
        ВЫЧ(fpu)
      |мКонст._тЗапись:
        CallRTL(мКонст._saverec);
        OutCode("83F800750A");
        OnError(4)
      |мКонст._тМассив:
        CallRTL(мКонст._savearr)
      ИНАЧЕ
      КОНЕЦ
    КОНЕЦ Save;

ПРОЦЕДУРА OpenArray*(A: tIdx; n: ЦЕЛОЕ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      PopEDX;
      ДЛЯ i := n - 1 ДО 0 ПО -1 ДЕЛАТЬ
        PushConst(A[i])
      КОНЕЦ;
      PushEDX
    КОНЕЦ OpenArray;

ПРОЦЕДУРА OpenIdx*(n: ЦЕЛОЕ);
    НАЧАЛО
      OutByte(54H);
      ЕСЛИ n > 1 ТОГДА
        PushConst(n);
        CallRTL(мКонст._arrayidx)
      ИНАЧЕ
        CallRTL(мКонст._arrayidx1)
      КОНЕЦ;
      PopEDX;
      OutCode("85D2750A");
      OnError(5);
      PushEDX;
    КОНЕЦ OpenIdx;

ПРОЦЕДУРА FixIdx*(len, size: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      IntByte("5983FA", "5981FA", len);
      OutCode("720A");
      OnError(5);
      ЕСЛИ size > 1 ТОГДА
        IntByte("6BD2", "69D2", size)
      КОНЕЦ;
      OutCode("03D1");
      PushEDX
    КОНЕЦ FixIdx;

ПРОЦЕДУРА Idx*;
    НАЧАЛО
      PopEDX;
      PopECX;
      OutCode("03D1");
      PushEDX
    КОНЕЦ Idx;

ПРОЦЕДУРА DupLoadCheck*;
    НАЧАЛО
      PopEDX;
      OutCode("528B125285D2750A");
      OnError(6)
    КОНЕЦ DupLoadCheck;

ПРОЦЕДУРА DupLoad*;
    НАЧАЛО
      PopEDX;
      OutCode("528B12");
      PushEDX;
    КОНЕЦ DupLoad;

ПРОЦЕДУРА CheckNIL*;
    НАЧАЛО
      PopEDX;
      OutCode("85D2750A");
      OnError(6);
      PushEDX;
    КОНЕЦ CheckNIL;

ПРОЦЕДУРА ExtArray*(A: tIdx; n, m: ЦЕЛОЕ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      ДЛЯ i := n - 1 ДО 0 ПО -1 ДЕЛАТЬ
        PushConst(A[i])
      КОНЕЦ;
      OutByte(54H);
      PushConst(n);
      PushConst(m);
      CallRTL(мКонст._arrayrot)
    КОНЕЦ ExtArray;

ПРОЦЕДУРА ADR*(dim: ЦЕЛОЕ);
    НАЧАЛО
      ЕСЛИ dim > 0 ТОГДА
        PopEDX;
        OutCode("83C4");
        OutByte(dim * 4);
        PushEDX
      КОНЕЦ
    КОНЕЦ ADR;

ПРОЦЕДУРА Len*(dim: ЦЕЛОЕ);
    НАЧАЛО
      PopEDX;
      ЕСЛИ dim < 0 ТОГДА
        PushConst(-dim)
      АЕСЛИ dim > 1 ТОГДА
        PopEDX;
        OutCode("83C4");
        OutByte((dim - 1) * 4);
        PushEDX
      КОНЕЦ
    КОНЕЦ Len;

ПРОЦЕДУРА For*(inc: БУЛЕВО; ПЕРЕМ LBeg, LEnd: ЦЕЛОЕ);
    НАЧАЛО
      LEnd := МеткаяНовая_Получ();
      LBeg := МеткаяНовая_Получ();
      Label(LBeg);
      OutCode("8B14248B4424043910");
      ЕСЛИ inc ТОГДА
        jmp(мКонст._JG, LEnd)
      ИНАЧЕ
        jmp(мКонст._JL, LEnd)
      КОНЕЦ
    КОНЕЦ For;

ПРОЦЕДУРА NextFor*(step, LBeg, LEnd: ЦЕЛОЕ);
    НАЧАЛО
      OutCode("8B542404");
      ЕСЛИ step = 1 ТОГДА
        OutCode("FF02")
      АЕСЛИ step = -1 ТОГДА
        OutCode("FF0A")
      ИНАЧЕ
        IntByte("8302", "8102", step)
      КОНЕЦ;
      jmp(мКонст._JMP, LBeg);
      Label(LEnd);
      OutCode("83C408")
    КОНЕЦ NextFor;

ПРОЦЕДУРА CaseLabel*(a, b, LBeg: ЦЕЛОЕ);
    ПЕРЕМ L: ЦЕЛОЕ;
    НАЧАЛО
      L := МеткаяНовая_Получ();
      IntByte("83FA", "81FA", a);
      ЕСЛИ a = b ТОГДА
        jmp(мКонст._JNE, L)
      ИНАЧЕ
        jmp(мКонст._JL, L);
        IntByte("83FA", "81FA", b);
        jmp(мКонст._JG, L)
      КОНЕЦ;
      jmp(мКонст._JMP, LBeg);
      Label(L)
    КОНЕЦ CaseLabel;

ПРОЦЕДУРА Drop*;
    НАЧАЛО
      PopEDX
    КОНЕЦ Drop;

ПРОЦЕДУРА strcmp*(Op, LR: ЦЕЛОЕ);
    НАЧАЛО
      ВЫБРАТЬ Op ИЗ
      |мКонст._опРавно: PushConst(0)
      |мКонст._опНеРавно: PushConst(1)
      |мКонст._опМеньше: PushConst(2)
      |мКонст._опБольше: PushConst(3)
      |мКонст._lexLE: PushConst(4)
      |мКонст._lexGE: PushConst(5)
      ИНАЧЕ
      КОНЕЦ;
      ВЫБРАТЬ LR ИЗ
      |-1: CallRTL(мКонст._lstrcmp)
      | 0: CallRTL(мКонст._strcmp)
      | 1: CallRTL(мКонст._rstrcmp)
      ИНАЧЕ
      КОНЕЦ;
      PushEAX
    КОНЕЦ strcmp;

ПРОЦЕДУРА Optimization;
    ПЕРЕМ
        асм_узел: тАсмУзел;
        flag: БУЛЕВО;
    НАЧАЛО
        асм_узел := асм_спис.первый(тАсмУзел);
        ПОКА асм_узел # ПУСТО ДЕЛАТЬ
            flag := ЛОЖЬ;
            ВЫБРАТЬ асм_узел.tcmd ИЗ
                |мКонст._PUSHEAX:
                  flag := асм_узел.следующ(тАсмУзел).tcmd = мКонст._POPEAX
                |мКонст._PUSHECX:
                  flag := асм_узел.следующ(тАсмУзел).tcmd = мКонст._POPECX
                |мКонст._PUSHEDX:
                  flag := асм_узел.следующ(тАсмУзел).tcmd = мКонст._POPEDX
            ИНАЧЕ
            КОНЕЦ;
            ЕСЛИ flag ТОГДА
                асм_узел.clen := 0;
                асм_узел.tcmd := 0;
                асм_узел := асм_узел.следующ(тАсмУзел);
                асм_узел.clen := 0;
                асм_узел.tcmd := 0
            КОНЕЦ;
            асм_узел := асм_узел.следующ(тАсмУзел)
        КОНЕЦ
    КОНЕЦ Optimization;

ПРОЦЕДУРА WriteKOS(FName: МАССИВ ИЗ СИМВ; stk, size, datasize, gsize: ЦЕЛОЕ; obj: БУЛЕВО);
    КОНСТ strsize = 2048;
    ПЕРЕМ Header: тЗаголовокКолибри; F, i, filesize, filebuf, a, sec, adr, size2: ЦЕЛОЕ; cur: тАсмУзел;
        Coff: тЗаголовокВин; sym: МАССИВ 18 * 4 ИЗ СИМВ; FileName: мСтр.тСтрока;
    НАЧАЛО
        F := мФайл.Создать(FName);
        ЕСЛИ F <= 0 ТОГДА
            мОш.Сообщ(мКонстОш._ош58); мКонс.Стр_Печать(файл_выход)
        КОНЕЦ;
        OutFilePos := мУтиль.ПамятьНов_Получ(Выровнять(size, 4) + datasize + 1000H);
        filebuf := OutFilePos;
        мОш.Память(OutFilePos = 0);

        ЕСЛИ ~obj ТОГДА
            Header.menuet01 := "MENUET01";
            Header.ver := 1;
            Header.start := sys.SIZE(тЗаголовокКолибри);
            Header.size := Выровнять(size, 4) + datasize;
            Header.mem := Header.size + stk + gsize + strsize * 2 + 1000H;
            Header.sp := Header.size + gsize + stk;
            Header.param := Header.sp;
            Header.path := Header.param + strsize;

            Записать(sys.ADR(Header), sys.SIZE(тЗаголовокКолибри));

            cur := асм_спис.первый(тАсмУзел);
            ПОКА cur # ПУСТО ДЕЛАТЬ
                Записать(sys.ADR(Code[cur.cmd]), cur.clen);
                cur := cur.следующ(тАсмУзел)
            КОНЕЦ;
            Заполнить(Выровнять(size, 4) - size, 0X);
            Записать(sys.ADR(данные_стр), datasize);
            Файл_Записать(F, filebuf, OutFilePos - filebuf)
        ИНАЧЕ
            size2 := size;
            size := Выровнять(size, 4) - sys.SIZE(тЗаголовокКолибри);
            Coff.Machine := IntToCard16(014CH);
            Coff.секции_число := IntToCard16(3);
            Coff.датаВремя_штамп := мКонст._дата;
            Coff.SizeOfOptionalHeader := IntToCard16(0);
            Coff.Characteristics := IntToCard16(0184H);

            Coff.text.секц_имя := ".flat";
            Coff.text.размер := 0;
            Coff.text.адрес := 0;
            Coff.text.sizealign := size;
            Coff.text.OAPfile := 8CH;
            Coff.text.резерв6 := size + datasize + 8CH;
            Coff.text.резерв7 := 0;
            Coff.text.attrflags := 40300020H;

            Coff.data.секц_имя := ".data";
            Coff.data.размер := 0;
            Coff.data.адрес := 0;
            Coff.data.sizealign := datasize;
            Coff.data.OAPfile := size + 8CH;
            Coff.data.резерв6 := 0;
            Coff.data.резерв7 := 0;
            Coff.data.резерв8 := 0;
            Coff.data.attrflags := 0C0300040H;

            Coff.bss.секц_имя := ".bss";
            Coff.bss.размер := 0;
            Coff.bss.адрес := 0;
            Coff.bss.sizealign := gsize;
            Coff.bss.OAPfile := 0;
            Coff.bss.резерв6 := 0;
            Coff.bss.резерв7 := 0;
            Coff.bss.резерв8 := 0;
            Coff.bss.attrflags := 0C03000C0H;

            size := Выровнять(size2, 4);
            rcount := 0;
            cur := асм_спис.первый(тАсмУзел);
            ПОКА cur # ПУСТО ДЕЛАТЬ
                ЕСЛИ cur.tcmd ВХОДИТ {мКонст._OCMD, мКонст._GCMD} ТОГДА
                    sys.GET(sys.ADR(Code[cur.cmd]), a);
                    ЕСЛИ a < size ТОГДА
                        a := a - sys.SIZE(тЗаголовокКолибри);
                        sec := 1
                    АЕСЛИ a < size + datasize ТОГДА
                        a := a - size;
                        sec := 2
                    ИНАЧЕ
                        a := a - size - datasize;
                        sec := 3
                    КОНЕЦ;
                    sys.PUT(sys.ADR(Code[cur.cmd]), a);
                    sys.PUT(sys.ADR(Reloc[rcount]), cur.адр - sys.SIZE(тЗаголовокКолибри));
                    ДОБ(rcount, 4);
                    sys.PUT(sys.ADR(Reloc[rcount]), sec);
                    ДОБ(rcount, 4);
                    sys.PUT(sys.ADR(Reloc[rcount]), 06X); ДОБ(rcount);
                    sys.PUT(sys.ADR(Reloc[rcount]), 00X); ДОБ(rcount);
                КОНЕЦ;
                Записать(sys.ADR(Code[cur.cmd]), cur.clen);
                cur := cur.следующ(тАсмУзел)
            КОНЕЦ;
            size := size2;
            Заполнить(Выровнять(size, 4) - size2, 0X);
            Записать(sys.ADR(данные_стр), datasize);
            Coff.text.резерв8 := rcount DIV 10;
            Coff.PointerToSymbolTable := Coff.text.резерв6 + rcount;
            Coff.NumberOfSymbols := 4;

            Файл_Записать(F, sys.ADR(Coff), sys.SIZE(тЗаголовокВин));
            Файл_Записать(F, filebuf, OutFilePos - filebuf);
            Файл_Записать(F, sys.ADR(Reloc), rcount);

            adr := sys.ADR(sym);
            Массив_Настроить(adr, "4558504F52545300000000000100000002002E666C617400000000000000010000000300");
            Массив_Настроить(adr, "2E64617461000000000000000200000003002E6273730000000000000000030000000300");
            sys.PUT(sys.ADR(sym) + 8, метки[мКонст._Exports] - sys.SIZE(тЗаголовокКолибри));

            Файл_Записать(F, sys.ADR(sym), LEN(sym));
            i := 4;
            Файл_Записать(F, sys.ADR(i), 4)
        КОНЕЦ;
        мФайл.Закрыть(F)
    КОНЕЦ WriteKOS;

ПРОЦЕДУРА WriteELF(FName: МАССИВ ИЗ СИМВ; code, data, glob: ЦЕЛОЕ);
    ПЕРЕМ
        F, res, delta, filebuf: ЦЕЛОЕ;
        cur: тАсмУзел;
        bytes: МАССИВ 817H + 55FH + 4900 ИЗ СИМВ;

    ПРОЦЕДУРА Add(offset: ЦЕЛОЕ);
        ПЕРЕМ m: ЦЕЛОЕ;
        НАЧАЛО
                sys.GET(sys.ADR(bytes[offset]), m);
                sys.PUT(sys.ADR(bytes[offset]), m + delta)
        КОНЕЦ Add;

    ПРОЦЕДУРА Sub(offset: ЦЕЛОЕ);
        ПЕРЕМ m: ЦЕЛОЕ;
        НАЧАЛО
            sys.GET(sys.ADR(bytes[offset]), m);
            sys.PUT(sys.ADR(bytes[offset]), m - delta)
        КОНЕЦ Sub;

    НАЧАЛО
        F := мФайл.Открыть(felf, 0);
        ЕСЛИ F = 0 ТОГДА
            мОш.Сообщ(мКонстОш._ош49)
        КОНЕЦ;
        ЕСЛИ мФайл.Читать(F, sys.ADR(bytes), 817H + 55FH + 4900) # 817H + 55FH + 4900 ТОГДА
            мОш.Сообщ(мКонстОш._ош79)
        КОНЕЦ;
        мФайл.Закрыть(F);
        bytes[0] := 7FX;

        ВЫЧ(code, 13);

        delta := Выровнять(data, 1000H) - 100000H;
        Add(0020H); Add(00A4H); Add(00A8H); Add(0258H); Add(02B8H); Add(0308H); Add(0494H); Add(049CH);
        Add(04A4H); Add(0679H); Add(0681H); Add(06A4H); Add(06B0H); Add(06BAH); Add(0703H); Add(0762H);
        Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(17C5H); Add(17E5H); Add(17E9H); Add(1811H);
        Add(1839H); Add(1861H); Add(1889H); Add(1A25H); Add(1A95H); Add(1AA5H); Add(1C05H); Add(1C55H);
        Add(1CE5H); Add(1D09H); Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H);

        delta := Выровнять(glob, 1000H) - 3200000H;
        Add(00A8H); Add(17EDH); Add(1C09H); Add(1D25H);

        delta := Выровнять(code, 1000H) - 100000H;
        Add(0020H); Add(0084H); Add(0088H); Add(0098H); Add(009CH); Add(00A0H); Add(00B8H); Add(00BCH);
        Add(00C0H); Add(0118H); Add(011CH); Add(0120H); Add(0258H); Add(0278H); Add(02B8H); Add(0308H);
        Add(048CH); Add(0494H); Add(049CH); Add(04A4H); Add(04ACH); Add(04B4H); Add(04BCH); Add(04C4H);
        Add(04CCH); Add(04D4H); Add(04DCH); Add(04E4H); Add(04ECH); Add(04F4H); Add(04FCH); Add(0504H);
        Add(050CH); Add(0514H); Add(052BH); Add(0544H); Add(054EH); Add(0554H); Add(055EH); Add(056EH);
        Add(057EH); Add(058EH); Add(059EH); Add(05AEH); Add(05BEH); Add(05CEH); Add(05DEH); Add(05EEH);
        Add(05FEH); Add(060EH); Add(061EH); Add(062EH); Add(064CH); Add(0651H); Add(0679H); Add(0681H);
        Add(0686H); Add(068CH); Add(06A4H); Add(06ABH); Add(06B0H); Add(06BAH); Add(06D7H); Add(06EBH);
        Add(0703H); Add(0762H); Add(0774H); Add(0786H); Add(0819H); Add(0823H); Add(0828H); Add(082DH);
        Sub(0845H); Sub(087BH); Add(08DEH); Add(08E8H); Sub(0916H); Add(0C52H); Add(0C8AH); Add(0D0AH);
        Add(1635H); Add(1655H); Add(1659H); Add(167DH); Add(1681H); Add(16A5H); Add(16A9H); Add(16CDH);
        Add(16D1H); Add(16F5H); Add(16F9H); Add(171DH); Add(1721H); Add(1745H); Add(1749H); Add(176DH);
        Add(1771H); Add(1795H); Add(1799H); Add(17BDH); Add(17C1H); Add(17E5H); Add(17E9H); Add(1811H);
        Add(1839H); Add(1861H); Add(1889H); Add(1985H); Add(1995H); Add(19A5H); Add(19B5H); Add(19C5H);
        Add(19D5H); Add(19E5H); Add(19F5H); Add(1A05H); Add(1A15H); Add(1A25H); Add(1A55H); Add(1A65H);
        Add(1A75H); Add(1A95H); Add(1AA5H); Add(1AD5H); Add(1AE5H); Add(1AF5H); Add(1B05H); Add(1B25H);
        Add(1B35H); Add(1B45H); Add(1B55H); Add(1B65H); Add(1B75H); Add(1BB5H); Add(1BC5H); Add(1BE5H);
        Add(1C05H); Add(1C15H); Add(1C55H); Add(1C75H); Add(1CA5H); Add(1CB5H); Add(1CE5H); Add(1D05H);
        Add(1D15H); Add(1D25H); Add(1D35H); Add(1D55H); Add(1D75H); Add(1D89H);

        OutFilePos := мУтиль.ПамятьНов_Получ(code + data + 8000H);
        filebuf := OutFilePos;
        мОш.Память(OutFilePos = 0);

        Записать(sys.ADR(bytes), 817H);
        Заполнить(2DDH, 90X);
        cur := асм_спис.первый(тАсмУзел);
        ПОКА cur # ПУСТО ДЕЛАТЬ
            Записать(sys.ADR(Code[cur.cmd]), cur.clen);
            cur := cur.следующ(тАсмУзел)
        КОНЕЦ;
        Заполнить(Выровнять(code, 1000H) - code, 90X);
        Записать(sys.ADR(bytes[817H]), 55FH);
        Записать(sys.ADR(данные_стр), data);
        Заполнить(Выровнять(data, 1000H) - data, 0X);
        Записать(sys.ADR(bytes[817H + 55FH + 55FH]), 0DC5H);

        F := мФайл.Создать(FName);
        ЕСЛИ F <= 0 ТОГДА
            мОш.Сообщ(мКонстОш._ош58); мКонс.Стр_Печать(файл_выход)
        КОНЕЦ;
        Файл_Записать(F, filebuf, OutFilePos - filebuf);
        мФайл.Закрыть(F)
    КОНЕЦ WriteELF;

ПРОЦЕДУРА FixLabels(FName: МАССИВ ИЗ СИМВ; stk, gsize, glob: ЦЕЛОЕ);
    ПЕРЕМ
        size, asize, i, rdatasize, RCount, n, temp, temp2, temp3: ЦЕЛОЕ;
        cur: тАсмУзел;
        R: тСмещение;
        c: СИМВ;
    НАЧАЛО
        dcount := Выровнять(dcount, 4);
        ЕСЛИ dll ТОГДА
            LoadAdr := 10000000H;
            PackExport(файл_назв)
        АЕСЛИ con ИЛИ gui ТОГДА
            LoadAdr := 400000H
        АЕСЛИ kos ИЛИ obj ТОГДА
            LoadAdr := sys.SIZE(тЗаголовокКолибри)
        АЕСЛИ elf ТОГДА
            LoadAdr := 134514420 + 1024;
            ДОБ(gsize, 1024)
        КОНЕЦ;

        ЕСЛИ dll ИЛИ con ИЛИ gui ТОГДА
            rdatasize := 0DAH + etable.size;
            size := 1000H + LoadAdr;
        АЕСЛИ kos ИЛИ elf ИЛИ obj ТОГДА
            rdatasize := 0;
            size := LoadAdr
        КОНЕЦ;

        Optimization;
        temp2 := size;
        cur := асм_спис.первый(тАсмУзел);
        ПОКА cur # ПУСТО ДЕЛАТЬ
            cur.адр := size;
            ЕСЛИ cur.tcmd = мКонст._LCMD ТОГДА
                sys.PUT(cur.varadr, size)
            КОНЕЦ;
            size := size + cur.clen;
            cur := cur.следующ(тАсмУзел)
        КОНЕЦ;

        size := temp2;
        cur := асм_спис.первый(тАсмУзел);
        ПОКА cur # ПУСТО ДЕЛАТЬ
            cur.адр := size;
            ЕСЛИ cur.tcmd = мКонст._LCMD ТОГДА
                sys.PUT(cur.varadr, size)
            АЕСЛИ (cur.tcmd = мКонст._JCMD) & cur.short ТОГДА
                sys.GET(cur.varadr, i);
                temp3 := i - cur.следующ(тАсмУзел).адр;
                ЕСЛИ (-131 <= temp3) & (temp3 <= 123) ТОГДА
                    sys.GET(cur(тАсмУзел).codeadr - 1, c);
                    ЕСЛИ c = мКонст._JMP ТОГДА
                        sys.PUT(cur(тАсмУзел).codeadr - 1, 0EBX)
                    ИНАЧЕ (*JE, JNE, JLE, JGE, JG, JL*)
                        sys.PUT(cur(тАсмУзел).codeadr - 2, ORD(c) - 16);
                        sys.PUT(cur(тАсмУзел).codeadr - 1, temp3);
                        ВЫЧ(cur(тАсмУзел).codeadr)
                    КОНЕЦ;
                    cur.clen := 2
                КОНЕЦ
            КОНЕЦ;
            size := size + cur.clen;
            cur := cur.следующ(тАсмУзел)
        КОНЕЦ;

        ЕСЛИ dll ИЛИ con ИЛИ gui ТОГДА
            asize := Выровнять(size, 1000H)
        АЕСЛИ kos ИЛИ obj ТОГДА
            asize := Выровнять(size, 4)
        АЕСЛИ elf ТОГДА
            asize := 134514420 + 6508 + Выровнять(size - 13 - LoadAdr, 1000H)
        КОНЕЦ;

        ДЛЯ i := 0 ДО Lcount ДЕЛАТЬ
            ЕСЛИ метки[i] < 0 ТОГДА
                метки[i] := -метки[i] + asize + Выровнять(rdatasize, 1000H)
            КОНЕЦ
        КОНЕЦ;

        temp := dcount;
        ЕСЛИ elf ТОГДА
            asize := asize + Выровнять(dcount, 1000H) + 64 + 1024;
            sys.PUT(sys.ADR(Code[glob + 1]), asize - 1024);
            dcount := 0
        КОНЕЦ;

        ЕСЛИ dll ТОГДА
            asize := asize - LoadAdr + 0DAH;
            ДЛЯ i := 0 ДО etable.namecount - 1 ДЕЛАТЬ
                etable.arradr[i] := метки[etable.arradr[i]] - LoadAdr;
                etable.arrnameptr[i] := etable.arrnameptr[i] + asize
            КОНЕЦ;
            etable.arradroffset := etable.arradroffset + asize;
            etable.arrnameptroffset := etable.arrnameptroffset + asize;
            etable.arrnumoffset := etable.arrnumoffset + asize;
            etable.dllnameoffset := etable.dllnameoffset + asize;
            asize := asize + LoadAdr - 0DAH
        КОНЕЦ;
        ЕСЛИ dll ИЛИ con ИЛИ gui ТОГДА
            метки[мКонст._LoadLibrary] := asize + 4;
            метки[мКонст._GetProcAddress] := asize;
            R.Page := 0;
            R.Size := 0;
            RCount := 0;
        КОНЕЦ;
        cur := асм_спис.первый(тАсмУзел);

        ДЛЯ i := 0 ДО LEN(RtlProc) - 1 ДЕЛАТЬ
            RtlProc[i] := метки[RtlProc[i]]
        КОНЕЦ;

        temp3 := asize + Выровнять(rdatasize, 1000H) + dcount;
        ПОКА cur # ПУСТО ДЕЛАТЬ
            ВЫБРАТЬ cur.tcmd ИЗ
                |мКонст._JCMD:
                    sys.GET(cur.varadr, i);
                    sys.PUT(cur.codeadr, i - cur.следующ(тАсмУзел).адр)
                |мКонст._GCMD:
                    sys.GET(cur.codeadr, i);
                    sys.PUT(cur.codeadr, i + temp3)
                |мКонст._OCMD:
                    sys.MOVE(cur.varadr, cur.codeadr, 4)
            ИНАЧЕ
            КОНЕЦ;
            ЕСЛИ dll & (cur.tcmd ВХОДИТ {мКонст._GCMD, мКонст._OCMD}) ТОГДА
                n := cur.адр - LoadAdr;
                ЕСЛИ ASR(n, 12) = ASR(R.Page, 12) ТОГДА
                    R.reloc[RCount] := IntToCard16(n MOD 1000H + 3000H);
                    ДОБ(RCount);
                    ДОБ(R.Size, 2)
                ИНАЧЕ
                    ЕСЛИ R.Size # 0 ТОГДА
                        PutReloc(R)
                    КОНЕЦ;
                    R.Page := ASR(n, 12) * 1000H;
                    R.Size := 10;
                    R.reloc[0] := IntToCard16(n MOD 1000H + 3000H);
                    RCount := 1
                КОНЕЦ
            КОНЕЦ;
            cur := cur.следующ(тАсмУзел)
        КОНЕЦ;
        ЕСЛИ R.Size # 0 ТОГДА
            PutReloc(R)
        КОНЕЦ;
        ЕСЛИ dll ИЛИ con ИЛИ gui ТОГДА
            WritePE(FName, stk, size - 1000H - LoadAdr, dcount, rdatasize, gsize)
        АЕСЛИ kos ИЛИ obj ТОГДА
            WriteKOS(FName, Выровнять(stk, 4), size, dcount, gsize, obj)
        АЕСЛИ elf ТОГДА
            WriteELF(FName, size - LoadAdr, temp, gsize)
        КОНЕЦ
    КОНЕЦ FixLabels;

ПРОЦЕДУРА OutStringZ(str: МАССИВ ИЗ СИМВ);
    ПЕРЕМ i: ЦЕЛОЕ;
    НАЧАЛО
      Узел_Новый;
      асм_текущ.clen := LENGTH(str);
      ДЛЯ i := 0 ДО асм_текущ.clen - 1 ДЕЛАТЬ
        Code[ccount] := str[i];
        ДОБ(ccount)
      КОНЕЦ;
      Code[ccount] := 0X;
      ДОБ(ccount);
      ДОБ(асм_текущ.clen)
    КОНЕЦ OutStringZ;

ПРОЦЕДУРА Epilog*(gsize: ЦЕЛОЕ; FName: МАССИВ ИЗ СИМВ; stk: ЦЕЛОЕ);
    ПЕРЕМ
        i, glob: ЦЕЛОЕ;
    НАЧАЛО
        glob := 0;
        gsize := Выровнять(gsize, 4) + 4;
        COPY(FName, файл_выход);
        метки[мКонст._RTABLE] := -dcount;
        dataint(recarray[0]);
        ДЛЯ i := 1 ДО reccount ДЕЛАТЬ
            dataint(recarray[i])
        КОНЕЦ;
        асм_текущ := старт_узел;
        ЕСЛИ con ИЛИ gui ИЛИ dll ТОГДА
            PushInt(мКонст._LoadLibrary);
            PushInt(мКонст._GetProcAddress);
            OutCode("5859FF31FF3054")
        АЕСЛИ elf ТОГДА
            OutCode("6800000000");
            glob := асм_текущ.cmd;
        АЕСЛИ kos ИЛИ obj ТОГДА
            OutByte(54H)
        КОНЕЦ;
        GlobalAdr(0);
        PushConst(ASR(gsize, 2));
        PushInt(мКонст._RTABLE);
        PushInt(мКонст._SELFNAME);
        CallRTL(мКонст._init);
        асм_текущ := асм_спис.последний(тАсмУзел);
        ЕСЛИ dll ТОГДА
            OutCode("B801000000C9C20C00")
        КОНЕЦ;
        ЕСЛИ obj ТОГДА
            OutCode("B801000000C9C20400")
        КОНЕЦ;
        OutCode("EB05");
        Label(мКонст._ASSRT);
        CallRTL(мКонст._assrt);
        OutCode("EB09");
        Label(мКонст._HALT);
        OutCode("6A006A00");
        CallRTL(мКонст._assrt);
        OutCode("6A00");
        CallRTL(мКонст._halt);
        OutByte(90H);
        ЕСЛИ obj ТОГДА
            Label(мКонст._Exports);
            CmdN(мКонст._szSTART); CmdN(мКонст._START);
            CmdN(мКонст._szversion); OutInt(stk);
        ДЛЯ i := 0 ДО kosexpcount - 1 ДЕЛАТЬ
            CmdN(kosexp[i].NameLabel); CmdN(kosexp[i].Adr)
        КОНЕЦ;
        OutInt(0);
        Label(мКонст._szSTART); OutStringZ("START");
        Label(мКонст._szversion); OutStringZ("version");
        ДЛЯ i := 0 ДО kosexpcount - 1 ДЕЛАТЬ
            Label(kosexp[i].NameLabel);
            OutStringZ(kosexp[i].Name.имя_узла)
        КОНЕЦ
      КОНЕЦ;
      FixLabels(FName, stk, gsize, glob)
    КОНЕЦ Epilog;

КОНЕЦ X86.
