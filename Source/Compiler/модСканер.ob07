(*
    Copyright 2013 Krotov Anton

  This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.

  *)
МОДУЛЬ модСканер;

ИМПОРТ мУтиль := модУтиль,
    mSys := SYSTEM,
    мКонст := модКонстанты,
    мФайл := модФайл,
    мТипы := модТипы,
    мПам := модПамять,
    мСтр := модСтроки;

КОНСТ

    maxDBL* = 1.69D308;
    
    IDLENGTH = 255;
    STRLENGTH* = 256;

    lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
    lxBY = 3; lxDIV = 6; 
     
    lxMOD = 17;

    lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54; lxNot = 55; lxAnd = 56; lxComma = 57; lxSemi = 58;
    lxStick = 59; lxLRound = 60; lxLSquare = 61; lxLCurly = 62; lxCaret = 63; lxRRound = 64; lxRSquare = 65;
    lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69; lxColon = 70;
    lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

    lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
    lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

ПЕРЕМ

    Lex: мСтр.тСтрока;
    File, ccol, cline, count*, col*, line*, tLex*, vINT*: ЦЕЛОЕ;
    vFLT*: LONGREAL; id*: мТипы.туУзел; ch, vCHX*: СИМВ;
    buf, bufpos: ЦЕЛОЕ; CR, UTF8: BOOLEAN;
    Nodes: МАССИВ 256 ИЗ мТипы.туУзел;
    _START*, _version*: мТипы.туУзел;

ПРОЦЕДУРА Узел_Добав*(Name: мСтр.тСтрока): мТипы.туУзел;
    ПЕРЕМ
      cur, res: мТипы.туУзел;

        ПРОЦЕДУРА Узел_Новый(Right: BOOLEAN);
            НАЧАЛО
            NEW(res);
            мПам.Ошибка(res = ПУСТО);
            res.имя := Name;
            res.tLex := lxIDENT;
            res.левый := ПУСТО;
            res.правый := ПУСТО;
            ЕСЛИ Right ТОГДА
               cur.правый := res
            ИНАЧЕ
               cur.левый := res
            КОНЕЦ
            КОНЕЦ Узел_Новый;

    НАЧАЛО
        res := ПУСТО;
        cur := Nodes[ORD(Name[0])];
        ПОВТОРЯТЬ
            ЕСЛИ Name > cur.имя ТОГДА
               ЕСЛИ cur.правый # ПУСТО ТОГДА
                  cur := cur.правый
               ИНАЧЕ
                  Узел_Новый(ИСТИНА)
               КОНЕЦ
            АЕСЛИ Name < cur.имя ТОГДА
               ЕСЛИ cur.левый # ПУСТО ТОГДА
                  cur := cur.левый
               ИНАЧЕ
                  Узел_Новый(ЛОЖЬ)
               КОНЕЦ
            ИНАЧЕ
               res := cur
            КОНЕЦ
        ПОКАНЕ res # ПУСТО
        ВЕРНУТЬ res
    КОНЕЦ Узел_Добав;

ПРОЦЕДУРА GetLexStr*(ПЕР L: мСтр.тСтрока);
    НАЧАЛО
        L := Lex
    КОНЕЦ GetLexStr;

ПРОЦЕДУРА Сохранить*(scanner: мТипы.туСканер);
    НАЧАЛО
        scanner.файл_ном := File;
        scanner.ccol := ccol;
        scanner.cline := cline;
        scanner.ch := ch;
        scanner.Lex := Lex;
        scanner.счетчик := count;
        scanner.col := col;
        scanner.строка_ном := line;
        scanner.tLex := tLex;
        scanner.vINT := vINT;
        scanner.vFLT := vFLT;
        scanner.vCHX := vCHX;
        scanner.buf := buf;
        scanner.bufpos := bufpos;
        scanner.CR := CR;
        scanner.UTF8 := UTF8
    КОНЕЦ Сохранить;

ПРОЦЕДУРА Вернуть*(scanner: мТипы.туСканер);
    НАЧАЛО
        File := scanner.файл_ном;
        ccol := scanner.ccol;
        cline := scanner.cline;
        ch := scanner.ch;
        Lex := scanner.Lex;
        count := scanner.счетчик;
        col := scanner.col;
        line := scanner.строка_ном;
        tLex := scanner.tLex;
        vINT := scanner.vINT;
        vFLT := scanner.vFLT;
        vCHX := scanner.vCHX;
        buf := scanner.buf;
        bufpos := scanner.bufpos;
        CR := scanner.CR;
        UTF8 := scanner.UTF8
    КОНЕЦ Вернуть;

ПРОЦЕДУРА Next;
    ПЕРЕМ
        cr: BOOLEAN;
    НАЧАЛО
        cr := ЛОЖЬ;
        mSys.GET(bufpos, ch);
        INC(ccol);
        ВЫБОР ch ИЗ
            |0AX: ЕСЛИ ~CR ТОГДА
                    INC(cline)
                    КОНЕЦ;
                    ccol := 0
            |0DX: INC(cline);
                ccol := 0;
                cr := ИСТИНА
            |09X: DEC(ccol);
                ccol := ccol + мКонст.таб - (ccol - 1) MOD мКонст.таб - 1
            |80X..0BFX: ЕСЛИ UTF8 ТОГДА
                            DEC(ccol)
                        КОНЕЦ
        ИНАЧЕ
        КОНЕЦ;
        CR := cr;
        INC(bufpos)
    КОНЕЦ Next;

ПРОЦЕДУРА Файл_Открыть*(FName: МАССИВ ИЗ СИМВ; ПЕР FHandle: ЦЕЛОЕ): BOOLEAN;
    ПЕРЕМ
      n, size: ЦЕЛОЕ; c: СИМВ;
    НАЧАЛО
        File := мФайл.Открыть(FName, 0);
        FHandle := File;
        ЕСЛИ File # 0 ТОГДА
            CR := ЛОЖЬ;
            UTF8 := ЛОЖЬ;
            ccol := 0;
            cline := 1;
            ch := 0X;
            size := мФайл.Размер_Получ(File);
            buf := мПам.Получ(size + 1024);
            mSys.PUT(buf + size, 0X);
            мПам.Ошибка(buf = 0);
            n := мФайл.Читать(File, buf, size);
            мФайл.Закрыть(File);
            bufpos := buf;
            mSys.GET(buf, c);
            ЕСЛИ c = 0EFX ТОГДА
            mSys.GET(buf + 1, c);
            ЕСЛИ c = 0BBX ТОГДА
        mSys.GET(buf + 2, c);
        ЕСЛИ c = 0BFX ТОГДА
            INC(bufpos, 3);
            UTF8 := ИСТИНА
        КОНЕЦ
            КОНЕЦ
            КОНЕЦ;
            Next
        КОНЕЦ
        ВЕРНУТЬ (File # 0) & (n = size)
    КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА Пробел_Проверить(ch: СИМВ): BOOLEAN;
    ВЕРНУТЬ (ch <= 20X) & (ch > 0X)
    КОНЕЦ Пробел_Проверить;

ПРОЦЕДУРА Симв_Проверить(ch: СИМВ): BOOLEAN;
    ПЕРЕМ
        ch_eng: BOOLEAN;
        ch_rus: BOOLEAN;
        
        result: BOOLEAN;
    НАЧАЛО
        ch_eng := (ch >= "A") & (ch <= "Z") ИЛИ (ch >= "a") & (ch <= "z") ИЛИ (ch = "_");
        ch_rus := (ch >= "А") & (ch <= "Я") ИЛИ (ch >= "а") & (ch <= "я");
        result := ch_eng ИЛИ ch_rus;
        ВЕРНУТЬ result
    КОНЕЦ Симв_Проверить;

ПРОЦЕДУРА Цифра_Проверить*(ch: СИМВ): BOOLEAN;
        ВЕРНУТЬ (ch >= "0") & (ch <= "9")
    КОНЕЦ Цифра_Проверить;

ПРОЦЕДУРА Число16_Получ*(ch: СИМВ): BOOLEAN;
        ВЕРНУТЬ (ch >= "A") & (ch <= "F") ИЛИ (ch >= "0") & (ch <= "9")
    КОНЕЦ Число16_Получ;

ПРОЦЕДУРА Симв_Добав(ch: СИМВ);
    НАЧАЛО
        Lex[count] := ch;
        ЕСЛИ ch # 0X ТОГДА
            INC(count)
        КОНЕЦ
    КОНЕЦ Симв_Добав;

ПРОЦЕДУРА СимвСлед_Добав(ch: СИМВ);
    НАЧАЛО
        Симв_Добав(ch);
        Next
    КОНЕЦ СимвСлед_Добав;

ПРОЦЕДУРА Имя_Получ;
    НАЧАЛО
        tLex := lxIDENT;
        ПОКА Симв_Проверить(ch) ИЛИ Цифра_Проверить(ch) ДЕЛАТЬ
            СимвСлед_Добав(ch)
        КОНЕЦ;
        Симв_Добав(0X);
        ЕСЛИ count > IDLENGTH ТОГДА
            tLex := lxERR10
        КОНЕЦ
    КОНЕЦ Имя_Получ;

ПРОЦЕДУРА Число16_в_Целое*(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        Res: ЦЕЛОЕ;
    НАЧАЛО
        Res := ORD(ch);
        ВЫБОР ch ИЗ
            |"0".."9": DEC(Res, ORD("0"))
            |"A".."F": DEC(Res, ORD("A") - 10)
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Число16_в_Целое;

ПРОЦЕДУРА Стр_в_Цел16*(str: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ i, res, n: ЦЕЛОЕ; flag: BOOLEAN;
    НАЧАЛО
        res := 0;
        i := 0;
        n := 0;
        ПОКА str[i] = "0" ДЕЛАТЬ
            INC(i)
        КОНЕЦ;
        flag := ИСТИНА;
        ПОКА flag & (str[i] # "X") & (str[i] # "H") ДЕЛАТЬ
            INC(n);
            ЕСЛИ n > 8 ТОГДА
            tLex := lxERR5;
            flag := ЛОЖЬ
            ИНАЧЕ
            res := LSL(res, 4) + Число16_в_Целое(str[i]);
            INC(i)
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ res
    КОНЕЦ Стр_в_Цел16;

ПРОЦЕДУРА Стр_в_Симв(str: мСтр.тСтрока): СИМВ;
    ПЕРЕМ res: ЦЕЛОЕ;
    НАЧАЛО
        res := Стр_в_Цел16(str);
        ЕСЛИ (res < 0) ИЛИ (res > 0FFH) ТОГДА
            tLex := lxERR6;
            res := 0
        КОНЕЦ
        ВЕРНУТЬ CHR(res)
    КОНЕЦ Стр_в_Симв;

ПРОЦЕДУРА Стр_в_Цел*(str: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ
        i, res: ЦЕЛОЕ;
        flag: BOOLEAN;
    НАЧАЛО
        res := 0;
        i := 0;
        flag := ИСТИНА;
        ПОКА flag & (str[i] # 0X) ДЕЛАТЬ
            ЕСЛИ res > мКонст.целое_макс DIV 10 ТОГДА
                tLex := lxERR5;
                flag := ЛОЖЬ;
                res := 0
            ИНАЧЕ
                res := res * 10;
                ЕСЛИ res > мКонст.целое_макс - (ORD(str[i]) - ORD("0")) ТОГДА
                    tLex := lxERR5;
                    flag := ЛОЖЬ;
                    res := 0
                ИНАЧЕ
                    res := res + (ORD(str[i]) - ORD("0"));
                    INC(i)
                КОНЕЦ
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ res
    КОНЕЦ Стр_в_Цел;

ПРОЦЕДУРА Стр_в_Вещ(str: мСтр.тСтрока): LONGREAL;
    ПЕРЕМ
        i, scale: ЦЕЛОЕ;
        res, m, d: LONGREAL;
        minus, nez: BOOLEAN;

    ПРОЦЕДУРА Error(e: ЦЕЛОЕ; ПЕР cont: BOOLEAN);
        НАЧАЛО
            tLex := e;
            res := 0.0D0;
            cont := ЛОЖЬ
        КОНЕЦ Error;

    ПРОЦЕДУРА Inf(ПЕР cont: BOOLEAN; ПЕР i: ЦЕЛОЕ);
        НАЧАЛО
            ЕСЛИ мУтиль.Бесконеч(res) ТОГДА
              Error(lxERR7, cont)
            КОНЕЦ;
            INC(i)
        КОНЕЦ Inf;

    ПРОЦЕДУРА part1(): BOOLEAN;
        ПЕРЕМ cont: BOOLEAN;
        НАЧАЛО
            res := 0.0D0;
            i := 0;
            d := 1.0D0;
            nez := ЛОЖЬ;
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(str[i]) ДЕЛАТЬ
            nez := nez ИЛИ (str[i] # "0");
            res := res * 10.0D0 + ДЛИН(FLT(ORD(str[i]) - ORD("0")));
            Inf(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ part1;

    ПРОЦЕДУРА part2(): BOOLEAN;
        ПЕРЕМ cont: BOOLEAN;
        НАЧАЛО
            INC(i);
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(str[i]) ДЕЛАТЬ
            nez := nez ИЛИ (str[i] # "0");
            d := d / 10.0D0;
            res := res + ДЛИН(FLT(ORD(str[i]) - ORD("0"))) * d;
            Inf(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ part2;

    ПРОЦЕДУРА part3(): BOOLEAN;
        ПЕРЕМ cont: BOOLEAN;
        НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ str[i] = 0X ТОГДА
              ЕСЛИ res > ДЛИН(мКонст.вещ_макс) ТОГДА
                Error(lxERR7, cont)
              АЕСЛИ nez & ((res = 0.0D0) ИЛИ (res < ДЛИН(мКонст.вещ_мин)) & (tLex = lxREAL)) ТОГДА
                Error(lxERR9, cont)
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ part3;

    ПРОЦЕДУРА part4(): BOOLEAN;
          ПЕРЕМ cont: BOOLEAN;
          НАЧАЛО
            ЕСЛИ str[i] = "D" ТОГДА
              tLex := lxLONGREAL
            КОНЕЦ;
            INC(i);
            m := 10.0D0;
            minus := ЛОЖЬ;
            ЕСЛИ str[i] = "+" ТОГДА
              INC(i)
            АЕСЛИ str[i] = "-" ТОГДА
              minus := ИСТИНА;
              INC(i);
              m := 0.1D0
            КОНЕЦ;
            scale := 0;
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(str[i]) ДЕЛАТЬ
              ЕСЛИ scale > мКонст.целое_макс DIV 10 ТОГДА
                Error(lxERR8, cont)
              ИНАЧЕ
                scale := scale * 10;
                ЕСЛИ scale > мКонст.целое_макс - (ORD(str[i]) - ORD("0")) ТОГДА
                    Error(lxERR8, cont)
                ИНАЧЕ
                    scale := scale + (ORD(str[i]) - ORD("0"));
                    INC(i)
                КОНЕЦ
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ part4;

    ПРОЦЕДУРА part5(): BOOLEAN;
          ПЕРЕМ cont: BOOLEAN; i: ЦЕЛОЕ;
          НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ scale = мКонст.целое_макс ТОГДА
            Error(lxERR8, cont)
            КОНЕЦ;
            i := 1;
            ПОКА cont & (i <= scale) ДЕЛАТЬ
            res := res * m;
            Inf(cont, i)
            КОНЕЦ;
            ЕСЛИ cont & (nez & (res = 0.0D0) ИЛИ (res > 0.0D0) & (res < ДЛИН(мКонст.вещ_мин)) & (tLex = lxREAL)) ТОГДА
            Error(lxERR9, cont)
            АЕСЛИ cont & (tLex = lxREAL) & (res > ДЛИН(мКонст.вещ_макс)) ТОГДА
            Error(lxERR7, cont)
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ part5;

    НАЧАЛО
        ЕСЛИ part1() & part2() & part3() & part4() & part5() ТОГДА КОНЕЦ
        ВЕРНУТЬ res
    КОНЕЦ Стр_в_Вещ;

ПРОЦЕДУРА Число_Получ;
    ПЕРЕМ
        nextchr: СИМВ;
    НАЧАЛО
        tLex := lxINT;
        ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
            СимвСлед_Добав(ch)
        КОНЕЦ;
        ЕСЛИ ch = "H" ТОГДА
            tLex := lxHEX
        АЕСЛИ ch = "X" ТОГДА
            tLex := lxCHX
        КОНЕЦ;
        ЕСЛИ tLex # lxINT ТОГДА
            СимвСлед_Добав(ch)
        ИНАЧЕ
            ПОКА Число16_Получ(ch) ДЕЛАТЬ
                tLex := lxHEX;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            ЕСЛИ tLex = lxHEX ТОГДА
                ЕСЛИ ch = "H" ТОГДА
                    СимвСлед_Добав(ch)
                АЕСЛИ ch = "X" ТОГДА
                    tLex := lxCHX;
                    СимвСлед_Добав(ch)
                ИНАЧЕ
                    tLex := lxERR1
                КОНЕЦ
            АЕСЛИ ch = "." ТОГДА
                mSys.GET(bufpos, nextchr);
                ЕСЛИ nextchr # "." ТОГДА
                    tLex := lxREAL;
                    СимвСлед_Добав(ch);
                    ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                        СимвСлед_Добав(ch)
                    КОНЕЦ;
                    ЕСЛИ (ch = "E") ИЛИ (ch = "D") ТОГДА
                        СимвСлед_Добав(ch);
                        ЕСЛИ (ch = "+") ИЛИ (ch = "-") ТОГДА
                            СимвСлед_Добав(ch)
                        КОНЕЦ;
                        ЕСЛИ ~Цифра_Проверить(ch) ТОГДА
                            tLex := lxERR2
                        ИНАЧЕ
                            ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                                СимвСлед_Добав(ch)
                            КОНЕЦ
                        КОНЕЦ
                    КОНЕЦ
                КОНЕЦ
            КОНЕЦ
        КОНЕЦ;
        Симв_Добав(0X)
    КОНЕЦ Число_Получ;

ПРОЦЕДУРА Разделитель_Получ(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        Res: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБОР ch ИЗ
        |"+": Res := lxPlus
        |"-": Res := lxMinus
        |"*": Res := lxMult
        |"/": Res := lxSlash
        |"~": Res := lxNot
        |"&": Res := lxAnd
        |",": Res := lxComma
        |";": Res := lxSemi
        |"|": Res := lxStick
        |"[": Res := lxLSquare
        |"{": Res := lxLCurly
        |"^": Res := lxCaret
        |"=": Res := lxEQ
        |"#": Res := lxNE
        |")": Res := lxRRound
        |"]": Res := lxRSquare
        |"}": Res := lxRCurly
        |">": Res := lxGT
        |"<": Res := lxLT
        |":": Res := lxColon
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Разделитель_Получ;

ПРОЦЕДУРА Комментарий_Пропустить;
    ПЕРЕМ
        c, level: ЦЕЛОЕ;
        cont: BOOLEAN;
    НАЧАЛО
        c := 1;
        level := 1;
        cont := ИСТИНА;
        ПОКА cont & (level > 0) ДЕЛАТЬ
            Next;
            ВЫБОР ch ИЗ
            |"(": c := 2
            |")": ЕСЛИ c = 3 ТОГДА
                    DEC(level)
                  КОНЕЦ;
                  c := 1
            |"*": ЕСЛИ c = 2 ТОГДА
                    INC(level);
                    c := 1
                  ИНАЧЕ
                    c := 3
                  КОНЕЦ
            |0X : cont := ЛОЖЬ
            ИНАЧЕ
                c := 1
            КОНЕЦ;
        КОНЕЦ;
        ЕСЛИ cont ТОГДА
            Next
        КОНЕЦ
    КОНЕЦ Комментарий_Пропустить;

ПРОЦЕДУРА Лексема_Получ*;
    НАЧАЛО
        ПОКА Пробел_Проверить(ch) ДЕЛАТЬ
            Next
        КОНЕЦ;
        col := ccol;
        line := cline;
        count := 0;
        ВЫБОР ch ИЗ
        |"A".."Z", "a".."z", "_": (* eng *)
            Имя_Получ;
            id := Узел_Добав(Lex);
            tLex := id.tLex;
        |"А".."Я", "а".."я": (* rus *)
            Имя_Получ;
            id := Узел_Добав(Lex);
            tLex := id.tLex;
        |"0".."9":
            Число_Получ;
            ВЫБОР tLex ИЗ
                |lxINT:  vINT := Стр_в_Цел(Lex)
                |lxHEX:  vINT := Стр_в_Цел16(Lex)
                |lxCHX:  vCHX := Стр_в_Симв(Lex)
                |lxREAL: vFLT := Стр_в_Вещ(Lex)
            ИНАЧЕ
            КОНЕЦ
        |22X:
            tLex := lxSTRING;
            Next;
            ПОКА (ch # 22X) & (ch >= 20X) ДЕЛАТЬ
                СимвСлед_Добав(ch)
            КОНЕЦ;
            ЕСЛИ ch = 22X ТОГДА
                Next
            ИНАЧЕ
                tLex := lxERR3
            КОНЕЦ;
            Симв_Добав(0X);
            INC(count);
            ЕСЛИ count > STRLENGTH ТОГДА
                tLex := lxERR11
            КОНЕЦ
        |"/":
            tLex := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "/" ТОГДА
                ПОКА (ch >= 20X) ИЛИ (ch = 9X) ДЕЛАТЬ
                    СимвСлед_Добав(ch)
                КОНЕЦ;
                Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
        |">", "<", ":":
            tLex := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "=" ТОГДА
                ВЫБОР tLex ИЗ
                    |lxLT:  tLex := lxLE
                    |lxGT:  tLex := lxGE
                    |lxColon: tLex := lxAssign
                ИНАЧЕ
                КОНЕЦ;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
        |".":
            tLex := lxDot;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "." ТОГДА
                tLex := lxDbl;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
        |"(":
            tLex := lxLRound;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "*" ТОГДА
                Комментарий_Пропустить;
                Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
        |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            tLex := Разделитель_Получ(ch);
            Симв_Добав(ch);
            СимвСлед_Добав(0X)
        |0X:
            tLex := lxEOF;
            Симв_Добав(0X)
        ИНАЧЕ
            tLex := lxERR4
        КОНЕЦ
    КОНЕЦ Лексема_Получ;

ПРОЦЕДУРА КлючСлово_Добавить(Name: мСтр.тСтрока; key: ЦЕЛОЕ);
    ПЕРЕМ node: мТипы.туУзел;
    НАЧАЛО
        node := Узел_Добав(Name);
        node.tLex := key
    КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
    ПЕРЕМ
      i: ЦЕЛОЕ;
      node: мТипы.туУзел;
    НАЧАЛО
        ДЛЯ i := 0 ДО LEN(Nodes) - 1 ДЕЛАТЬ
            NEW(node);
            мПам.Ошибка(node = ПУСТО);
            mSys.PUT(mSys.ADR(node.имя), i);
            node.левый := ПУСТО;
            node.правый := ПУСТО;
            node.tLex := lxIDENT;
            Nodes[i] := node
        КОНЕЦ;
        _START := Узел_Добав("START");
        _version := Узел_Добав("version");
        КлючСлово_Добавить("MOD", lxMOD);
        
        КлючСлово_Добавить("CASE", мКонст.ксВЫБОР);
        КлючСлово_Добавить("ВЫБОР", мКонст.ксВЫБОР);
        
        КлючСлово_Добавить("IF", мКонст.ксЕСЛИ);
        КлючСлово_Добавить("ЕСЛИ", мКонст.ксЕСЛИ);
        
        КлючСлово_Добавить("TYPE", мКонст.ксТИПЫ);
        КлючСлово_Добавить("ТИПЫ", мКонст.ксТИПЫ);
        
        КлючСлово_Добавить("BEGIN", мКонст.ксНАЧАЛО);
        КлючСлово_Добавить("НАЧАЛО", мКонст.ксНАЧАЛО);
        
        КлючСлово_Добавить("DIV", lxDIV);
        
        КлючСлово_Добавить("IN", мКонст.ксВ);
        КлючСлово_Добавить("В", мКонст.ксВ);
        
        КлючСлово_Добавить("NIL", мКонст.ксПУСТО);
        КлючСлово_Добавить("ПУСТО", мКонст.ксПУСТО);

        
        КлючСлово_Добавить("VAR", мКонст.ксПЕРЕМ);
        КлючСлово_Добавить("ПЕРЕМ", мКонст.ксПЕРЕМ);
        КлючСлово_Добавить("ПЕР", мКонст.ксПЕРЕМ);
        
        КлючСлово_Добавить("ARRAY", мКонст.ксМАССИВ);
        КлючСлово_Добавить("МАССИВ", мКонст.ксМАССИВ);
        
        КлючСлово_Добавить("DO", мКонст.ксДЕЛАТЬ);
        КлючСлово_Добавить("ДЕЛАТЬ", мКонст.ксДЕЛАТЬ);
        
        КлючСлово_Добавить("IS", мКонст.ксЕСТЬ);
        КлючСлово_Добавить("ЕСТЬ", мКонст.ксЕСТЬ);
        
        КлючСлово_Добавить("OF", мКонст.ксИЗ);
        КлючСлово_Добавить("ИЗ", мКонст.ксИЗ);
        
        КлючСлово_Добавить("THEN", мКонст.ксТОГДА);
        КлючСлово_Добавить("ТОГДА", мКонст.ксТОГДА);
        
        КлючСлово_Добавить("WHILE", мКонст.ксПОКА);
        КлючСлово_Добавить("ПОКА", мКонст.ксПОКА);
        
        КлючСлово_Добавить("BY", lxBY);
        
        КлючСлово_Добавить("MODULE", мКонст.ксМОДУЛЬ);
        КлючСлово_Добавить("МОДУЛЬ", мКонст.ксМОДУЛЬ);
        
        КлючСлово_Добавить("IMPORT", мКонст.ксИМПОРТ);
        КлючСлово_Добавить("ИМПОРТ", мКонст.ксИМПОРТ);
        
        КлючСлово_Добавить("CONST", мКонст.ксКОНСТ);
        КлючСлово_Добавить("КОНСТ", мКонст.ксКОНСТ);

        КлючСлово_Добавить("END", мКонст.ксКОНЕЦ);
        КлючСлово_Добавить("КОНЕЦ", мКонст.ксКОНЕЦ);
        
        КлючСлово_Добавить("ELSE", мКонст.ксИНАЧЕ);
        КлючСлово_Добавить("ИНАЧЕ", мКонст.ксИНАЧЕ);
        
        КлючСлово_Добавить("ELSIF", мКонст.ксАЕСЛИ);
        КлючСлово_Добавить("АЕСЛИ", мКонст.ксАЕСЛИ);
        
        КлючСлово_Добавить("POINTER", мКонст.ксУКАЗАТЕЛЬ);
        КлючСлово_Добавить("УКАЗАТЕЛЬ", мКонст.ксУКАЗАТЕЛЬ);
        
        КлючСлово_Добавить("TO", мКонст.ксДО);
        КлючСлово_Добавить("НА", мКонст.ксДО);
        КлючСлово_Добавить("ДО", мКонст.ксДО);
        
        КлючСлово_Добавить("RECORD", мКонст.ксЗАПИСЬ);
        КлючСлово_Добавить("ЗАПИСЬ", мКонст.ксЗАПИСЬ);
        
        КлючСлово_Добавить("RETURN", мКонст.ксВЕРНУТЬ);
        КлючСлово_Добавить("ВЕРНУТЬ", мКонст.ксВЕРНУТЬ);
        
        КлючСлово_Добавить("PROCEDURE", мКонст.ксПРОЦЕДУРА);
        КлючСлово_Добавить("ПРОЦЕДУРА", мКонст.ксПРОЦЕДУРА);
        
        КлючСлово_Добавить("OR", мКонст.lxOR);
        КлючСлово_Добавить("ИЛИ", мКонст.lxOR);
        
        КлючСлово_Добавить("TRUE", мКонст.ксИСТИНА);
        КлючСлово_Добавить("ИСТИНА", мКонст.ксИСТИНА);
        
        КлючСлово_Добавить("FALSE", мКонст.ксЛОЖЬ);
        КлючСлово_Добавить("ЛОЖЬ", мКонст.ксЛОЖЬ);
        
        КлючСлово_Добавить("FOR", мКонст.ксДЛЯ);
        КлючСлово_Добавить("ДЛЯ", мКонст.ксДЛЯ);
        
        КлючСлово_Добавить("UNTIL", мКонст.ксПОКАНЕ);
        КлючСлово_Добавить("ПОКАНЕ", мКонст.ксПОКАНЕ);
        
        КлючСлово_Добавить("REPEAT", мКонст.ксПОВТОР);
        КлючСлово_Добавить("ПОВТОРЯТЬ", мКонст.ксПОВТОР);
        
   КОНЕЦ Настроить;

НАЧАЛО
   Настроить
КОНЕЦ модСканер.
