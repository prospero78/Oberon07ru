(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.

   *)
МОДУЛЬ модСканер;

ИМПОРТ мУтиль := модУтиль,
   mSys := SYSTEM,
   мКонст := модКонстанты,
   мФайл := модФайл,
   мПам := модПамять,
   мСтр := модСтроки,
   мЗнач := модЗначение,
   мЗвСущ := модЗвеноСущ,
   мОш := модОшибки,
   мКо := модОшибкиКонст;

КОНСТ

   lxERR20 = 120;

ТИПЫ
   туСканер* = УКАЗАТЕЛЬ НА ЗАПИСЬ
         цФайлНом*, ccol*, cline*, счётчик*, col*, строка_ном*, цКлСлово*: ЦЕЛОЕ;
         литера* : ЛИТ;
         стрСущн*: мСтр.тСтрока; (* ИСПРАВИТЬ *)
         знач*: мЗнач.тЗначение;
         цБуфер*, цБуфПоз*: ЦЕЛОЕ;
         CR*, бUTF8*: БУЛЕВО
      КОНЕЦ;

ПЕРЕМ

   стрСущность_глоб: мСтр.тСтрока;
   уФайл : мФайл.туФайл;
   значение :мЗнач.тЗначение;
   ccol, cline, счётчик*, цСущность*, vINT*: ЦЕЛОЕ;
   vFLT*: ДЛИНВЕЩ;
   уСущность*: мЗвСущ.туЗвеноСущ;
   литера, vCHX*: ЛИТ;
   CR, бUTF8: БУЛЕВО;
   _START*, _version*: мЗвСущ.туЗвеноСущ;

ПРОЦЕДУРА стрСущность_Получить*(ПЕР сущн_: мСтр.тСтрока);
   НАЧАЛО
      сущн_ := стрСущность_глоб
   КОНЕЦ стрСущность_Получить;

ПРОЦЕДУРА Сканер_Сохранить*(уСканер_: туСканер);
   НАЧАЛО
      уСканер_.цФайлНом := уФайл.цНомер;
      уСканер_.ccol := ccol;
      уСканер_.cline := cline;
      уСканер_.литера := литера;
      уСканер_.стрСущн := стрСущность_глоб;
      уСканер_.счётчик := счётчик;
      уСканер_.col := мОш.уКоорд.цПоз;
      уСканер_.строка_ном := мОш.уКоорд.цСтрока;
      уСканер_.цКлСлово := цСущность;
      уСканер_.знач.целое := vINT;
      уСканер_.знач.вещ := vFLT;
      уСканер_.знач.символ := vCHX;
      уСканер_.цБуфер := уФайл.цБуфер;
      уСканер_.цБуфПоз := уФайл.цБуфПоз;
      уСканер_.CR := CR;
      уСканер_.бUTF8 := бUTF8
   КОНЕЦ Сканер_Сохранить;

ПРОЦЕДУРА Сканер_Откатить*(сканер_: туСканер);
   НАЧАЛО
      уФайл.цНомер := сканер_.цФайлНом;
      ccol := сканер_.ccol;
      cline := сканер_.cline;
      литера := сканер_.литера;
      стрСущность_глоб := сканер_.стрСущн;
      счётчик := сканер_.счётчик;
      мОш.уКоорд.цПоз := сканер_.col;
      мОш.уКоорд.цСтрока := сканер_.строка_ном;
      цСущность := сканер_.цКлСлово;
      vINT := сканер_.знач.целое;
      vFLT := сканер_.знач.вещ;
      vCHX := сканер_.знач.символ;
      уФайл.цБуфер := сканер_.цБуфер;
      уФайл.цБуфПоз := сканер_.цБуфПоз;
      CR := сканер_.CR;
      бUTF8 := сканер_.бUTF8
    КОНЕЦ Сканер_Откатить;

ПРОЦЕДУРА Литера_Пропустить;
    ПЕРЕМ
        cr: БУЛЕВО;
    НАЧАЛО
        cr := ЛОЖЬ;
        mSys.GET(уФайл.цБуфПоз, литера);
        ДОБ(ccol);
        ВЫБОР литера ИЗ
            |0AX: ЕСЛИ ~CR ТОГДА
                    ДОБ(cline)
                    КОНЕЦ;
                    ccol := 0
            |0DX: ДОБ(cline);
                ccol := 0;
                cr := ИСТИНА
            |09X: ВЫЧ(ccol);
                ccol := ccol + мКонст.таб - (ccol - 1) ОСТ мКонст.таб - 1
            |80X..0BFX: ЕСЛИ бUTF8 ТОГДА
                            ВЫЧ(ccol)
                        КОНЕЦ
        ИНАЧЕ
        КОНЕЦ;
        CR := cr;
        ДОБ(уФайл.цБуфПоз)
    КОНЕЦ Литера_Пропустить;

ПРОЦЕДУРА Файл_Открыть*(стрФайлИмя_: МАССИВ ИЗ ЛИТ; ПЕР цФайлНомер: ЦЕЛОЕ): БУЛЕВО;
   ПЕРЕМ
      n: ЦЕЛОЕ;
      литера: ЛИТ;
   НАЧАЛО
      уФайл.цНомер := мФайл.Открыть(стрФайлИмя_, 0);
      цФайлНомер := уФайл.цНомер;
      ЕСЛИ уФайл.цНомер # 0 ТОГДА
         CR := ЛОЖЬ;
         бUTF8 := ЛОЖЬ;
         ccol := 0;
         cline := 1;
         литера := 0X;
         уФайл.цДлина := мФайл.Размер_Получ(уФайл);
         уФайл.цБуфер := мПам.Получ(уФайл.цДлина + 1024);
         mSys.PUT(уФайл.цБуфер + уФайл.цДлина, 0X);
         мПам.Мало(уФайл.цБуфер = 0);
         n := мФайл.Читать(уФайл, уФайл.цДлина);
         мФайл.Закрыть(уФайл);
         уФайл.цБуфПоз := уФайл.цБуфер;
         mSys.GET(уФайл.цБуфер, литера);
         ЕСЛИ литера = 0EFX ТОГДА
            mSys.GET(уФайл.цБуфер + 1, литера);
            ЕСЛИ литера = 0BBX ТОГДА
               mSys.GET(уФайл.цБуфер + 2, литера);
               ЕСЛИ литера = 0BFX ТОГДА
                  ДОБ(уФайл.цБуфПоз, 3);
                  бUTF8 := ИСТИНА
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ;
         Литера_Пропустить
      КОНЕЦ
      ВЕРНУТЬ (уФайл.цНомер # 0) & (n = уФайл.цДлина)
   КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА Пробел_Проверить(лит_: ЛИТ): БУЛЕВО;
    ВЕРНУТЬ (лит_ > 0X) & (лит_ <= 20X)
    КОНЕЦ Пробел_Проверить;

ПРОЦЕДУРА Буква_Проверить(лит_: ЛИТ): БУЛЕВО;
    ПЕРЕМ
        лит_анг: БУЛЕВО;
        лит_рус: БУЛЕВО;
        
        выход: БУЛЕВО;
    НАЧАЛО
        лит_анг := (лит_ >= "A") & (лит_ <= "Z") ИЛИ (лит_ >= "a") & (лит_ <= "z") ИЛИ (лит_ = "_");
        лит_рус := (лит_ >= "А") & (лит_ <= "Я") ИЛИ (лит_ >= "а") & (лит_ <= "я") ИЛИ (лит_ = "ё") ИЛИ (лит_ = "Ё");
        выход := лит_анг ИЛИ лит_рус;
        ВЕРНУТЬ выход
    КОНЕЦ Буква_Проверить;

ПРОЦЕДУРА Цифра_Проверить*(лит_: ЛИТ): БУЛЕВО;
        ВЕРНУТЬ (лит_ >= "0") & (лит_ <= "9")
    КОНЕЦ Цифра_Проверить;

ПРОЦЕДУРА Число16_Получ*(лит_: ЛИТ): БУЛЕВО;
        ВЕРНУТЬ (лит_ >= "0") & (лит_ <= "9") ИЛИ (лит_ >= "A") & (лит_ <= "F")
    КОНЕЦ Число16_Получ;

ПРОЦЕДУРА Литера_Добав(лит_: ЛИТ);
    НАЧАЛО
        стрСущность_глоб[счётчик] := лит_;
        ЕСЛИ лит_ # 0X ТОГДА
            ДОБ(счётчик)
        КОНЕЦ
    КОНЕЦ Литера_Добав;

ПРОЦЕДУРА ЛитераСлед_Добав(лит_: ЛИТ);
    НАЧАЛО
        Литера_Добав(лит_);
        Литера_Пропустить
    КОНЕЦ ЛитераСлед_Добав;

ПРОЦЕДУРА Имя_Получ;
   НАЧАЛО
      цСущность := мКонст.сущИМЯ;
      ПОКА Буква_Проверить(литера) ИЛИ Цифра_Проверить(литера) ДЕЛАТЬ
         ЛитераСлед_Добав(литера)
      КОНЕЦ;
      Литера_Добав(0X);
      ЕСЛИ счётчик > мКонст.сущ_макс_длина ТОГДА
         цСущность := мКо.ошИмяДлинМакс
      КОНЕЦ
   КОНЕЦ Имя_Получ;

ПРОЦЕДУРА Число16_в_Целое*(лит_: ЛИТ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        выход := НЛИТ(лит_);
        ВЫБОР лит_ ИЗ
            |"0".."9": ВЫЧ(выход, НЛИТ("0"))
            |"A".."F": ВЫЧ(выход, НЛИТ("A") - 10)
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Число16_в_Целое;

ПРОЦЕДУРА Стр_в_Цел16*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход, поз: ЦЕЛОЕ;
      flag: БУЛЕВО; (* вот это зачем???? *)
   НАЧАЛО
      выход := 0;
      итер := 0;
      поз := 0;
      ПОКА стр_[итер] = "0" ДЕЛАТЬ
         ДОБ(итер)
      КОНЕЦ;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # "X") & (стр_[итер] # "H") ДЕЛАТЬ
         ДОБ(поз);
         ЕСЛИ поз > 8 ТОГДА
            цСущность := мКо.ошЦелоеПереполн;
            flag := ЛОЖЬ
         ИНАЧЕ
            выход := ЛСЛ(выход, 4) + Число16_в_Целое(стр_[итер]);
            ДОБ(итер)
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Цел16;

ПРОЦЕДУРА Стр_в_лит16(стр_: мСтр.тСтрока): ЛИТ;
   ПЕРЕМ
      выход: ЦЕЛОЕ;
   НАЧАЛО
      выход := Стр_в_Цел16(стр_);
      ЕСЛИ (выход < 0) ИЛИ (выход > 0FFH) ТОГДА
         цСущность := мКо.ошЛитПереполн;
         выход := 0
      КОНЕЦ
         ВЕРНУТЬ ВЛИТ(выход)
   КОНЕЦ Стр_в_лит16;

ПРОЦЕДУРА Стр_в_Цел*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход: ЦЕЛОЕ;
      flag: БУЛЕВО;
   НАЧАЛО
      выход := 0;
      итер := 0;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # 0X) ДЕЛАТЬ
         ЕСЛИ выход > мКонст.целое_макс ДЕЛ 10 ТОГДА
            цСущность := мКо.ошЦелоеПереполн;
            flag := ЛОЖЬ;
            выход := 0
         ИНАЧЕ
            выход := выход * 10;
            ЕСЛИ выход > мКонст.целое_макс - (НЛИТ(стр_[итер]) - НЛИТ("0")) ТОГДА
               цСущность := мКо.ошЦелоеПереполн;
               flag := ЛОЖЬ;
               выход := 0
            ИНАЧЕ
               выход := выход + (НЛИТ(стр_[итер]) - НЛИТ("0"));
               ДОБ(итер)
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Цел;

ПРОЦЕДУРА Стр_в_Вещ(стр_: мСтр.тСтрока): ДЛИНВЕЩ;
   ПЕРЕМ
      i, шкала: ЦЕЛОЕ;
      выход, m, d: ДЛИНВЕЩ;
      бМинус, nez: БУЛЕВО;

   ПРОЦЕДУРА Ошибка(цКлСлово_: ЦЕЛОЕ; ПЕР продолж_: БУЛЕВО);
      НАЧАЛО
         цСущность := цКлСлово_;
         выход := 0.0D0;
         продолж_ := ЛОЖЬ
      КОНЕЦ Ошибка;

   ПРОЦЕДУРА Бесконеч_Проверить(ПЕР продолж_: БУЛЕВО; ПЕР i: ЦЕЛОЕ);
      НАЧАЛО
         ЕСЛИ мУтиль.ЕслиБесконеч(выход) ТОГДА
            Ошибка(мКо.ошВещПереполн, продолж_)
         КОНЕЦ;
         ДОБ(i)
      КОНЕЦ Бесконеч_Проверить;

   ПРОЦЕДУРА Часть1(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         выход := 0.0D0;
         i := 0;
         d := 1.0D0;
         nez := ЛОЖЬ;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            выход := выход * 10.0D0 + УДЛИН(КВЕЩ(НЛИТ(стр_[i]) - НЛИТ("0")));
            Бесконеч_Проверить(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть1;

   ПРОЦЕДУРА Часть2(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ДОБ(i);
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            d := d / 10.0D0;
            выход := выход + УДЛИН(КВЕЩ(НЛИТ(стр_[i]) - НЛИТ("0"))) * d;
            Бесконеч_Проверить(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
        КОНЕЦ Часть2;

   ПРОЦЕДУРА Часть3(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ стр_[i] = 0X ТОГДА
            ЕСЛИ выход > УДЛИН(мКонст.вещ_макс) ТОГДА
               Ошибка(мКо.ошВещПереполн, бПродолж)
            АЕСЛИ nez & ((выход = 0.0D0) ИЛИ (выход < УДЛИН(мКонст.вещ_мин)) & (цСущность = мКонст.сущВЕЩ)) ТОГДА
               Ошибка(мКо.ошВещПереполнМин, бПродолж)
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть3;

   ПРОЦЕДУРА Часть4(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ЕСЛИ стр_[i] = "D" ТОГДА
            цСущность := мКонст.сущДЛИНВЕЩ
         КОНЕЦ;
         ДОБ(i);
         m := 10.0D0;
         бМинус := ЛОЖЬ;
         ЕСЛИ стр_[i] = "+" ТОГДА
            ДОБ(i)
         АЕСЛИ стр_[i] = "-" ТОГДА
            бМинус := ИСТИНА;
            ДОБ(i);
            m := 0.1D0
         КОНЕЦ;
         шкала := 0;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            ЕСЛИ шкала > мКонст.целое_макс ДЕЛ 10 ТОГДА
               Ошибка(мКо.ошВещПереполнПоряд, бПродолж)
            ИНАЧЕ
               шкала := шкала * 10;
               ЕСЛИ шкала > мКонст.целое_макс - (НЛИТ(стр_[i]) - НЛИТ("0")) ТОГДА
                  Ошибка(мКо.ошВещПереполнПоряд, бПродолж)
               ИНАЧЕ
                  шкала := шкала + (НЛИТ(стр_[i]) - НЛИТ("0"));
                  ДОБ(i)
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть4;

   ПРОЦЕДУРА Часть5(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
         i: ЦЕЛОЕ;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ шкала = мКонст.целое_макс ТОГДА
            Ошибка(мКо.ошВещПереполнПоряд, бПродолж)
         КОНЕЦ;
         i := 1;
         ПОКА бПродолж & (i <= шкала) ДЕЛАТЬ
            выход := выход * m;
            Бесконеч_Проверить(бПродолж, i)
         КОНЕЦ;
         ЕСЛИ бПродолж & (nez & (выход = 0.0D0) ИЛИ (выход > 0.0D0) & (выход < УДЛИН(мКонст.вещ_мин)) & (цСущность = мКонст.сущВЕЩ)) ТОГДА
            Ошибка(мКо.ошВещПереполнМин, бПродолж)
         АЕСЛИ бПродолж & (цСущность = мКонст.сущВЕЩ) & (выход > УДЛИН(мКонст.вещ_макс)) ТОГДА
            Ошибка(мКо.ошВещПереполн, бПродолж)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть5;

   НАЧАЛО
      ЕСЛИ Часть1() ТОГДА
         ЕСЛИ Часть2() ТОГДА
            ЕСЛИ Часть3() ТОГДА
               ЕСЛИ Часть4() ТОГДА
                  ЕСЛИ Часть5() ТОГДА
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Вещ;

ПРОЦЕДУРА Число_Получ;
   ПЕРЕМ
      nextchr: ЛИТ;
   НАЧАЛО
      цСущность := мКонст.сущЦЕЛОЕ;
      ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
         ЛитераСлед_Добав(литера)
      КОНЕЦ;
      ЕСЛИ литера = "H" ТОГДА
         цСущность := мКонст.сущ16
      АЕСЛИ литера = "X" ТОГДА
         цСущность := мКонст.lxCHX
      КОНЕЦ;
      ЕСЛИ цСущность # мКонст.сущЦЕЛОЕ ТОГДА
         ЛитераСлед_Добав(литера)
      ИНАЧЕ
         ПОКА Число16_Получ(литера) ДЕЛАТЬ
            цСущность := мКонст.сущ16;
            ЛитераСлед_Добав(литера)
         КОНЕЦ;
         ЕСЛИ цСущность = мКонст.сущ16 ТОГДА
            ЕСЛИ литера = "H" ТОГДА
               ЛитераСлед_Добав(литера)
            АЕСЛИ литера = "X" ТОГДА
               цСущность := мКонст.lxCHX;
               ЛитераСлед_Добав(литера)
            ИНАЧЕ
               цСущность := мКо.ошПропущХ
            КОНЕЦ
         АЕСЛИ литера = "." ТОГДА
            mSys.GET(уФайл.цБуфПоз, nextchr);
            ЕСЛИ nextchr # "." ТОГДА
               цСущность := мКонст.сущВЕЩ;
               ЛитераСлед_Добав(литера);
               ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
                  ЛитераСлед_Добав(литера)
               КОНЕЦ;
               ЕСЛИ (литера = "E") ИЛИ (литера = "D") ТОГДА
                  ЛитераСлед_Добав(литера);
                  ЕСЛИ (литера = "+") ИЛИ (литера = "-") ТОГДА
                        ЛитераСлед_Добав(литера)
                  КОНЕЦ;
                  ЕСЛИ ~Цифра_Проверить(литера) ТОГДА
                     цСущность := мКо.ошПропущЦифра
                  ИНАЧЕ
                     ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
                        ЛитераСлед_Добав(литера)
                     КОНЕЦ
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ;
      Литера_Добав(0X)
   КОНЕЦ Число_Получ;

ПРОЦЕДУРА Разделитель_Получ(симв_: ЛИТ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБОР симв_ ИЗ
        |"+": выход := мКонст.опПлюс
        |"-": выход := мКонст.опМинус
        |"*": выход := мКонст.опУмнож
        |"/": выход := мКонст.опДелен
        |"~": выход := мКонст.опОтриц
        |"&": выход := мКонст.опИ
        |",": выход := мКонст.опЗапятая
        |";": выход := мКонст.опТчкЗпт
        |"|": выход := мКонст.опВыбор
        |"[": выход := мКонст.опСкобкаЛевКв
        |"{": выход := мКонст.опСкобкаЛевФиг
        |"^": выход := мКонст.опСтепень
        |"=": выход := мКонст.опРавно
        |"#": выход := мКонст.опНеРавно
        |")": выход := мКонст.опСкобкаПрКр
        |"]": выход := мКонст.опСкобкаПрКв
        |"}": выход := мКонст.опСкобкаПрФиг
        |">": выход := мКонст.опБольше
        |"<": выход := мКонст.опМеньше
        |":": выход := мКонст.опДвоеточ
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Разделитель_Получ;

ПРОЦЕДУРА Комментарий_Пропустить;
    ПЕРЕМ
        c, level: ЦЕЛОЕ;
        cont: БУЛЕВО;
    НАЧАЛО
        c := 1;
        level := 1;
        cont := ИСТИНА;
        ПОКА cont & (level > 0) ДЕЛАТЬ
            Литера_Пропустить;
            ВЫБОР литера ИЗ
               |"(": c := 2
               |")": ЕСЛИ c = 3 ТОГДА
                       ВЫЧ(level)
                     КОНЕЦ;
                     c := 1
               |"*": ЕСЛИ c = 2 ТОГДА
                       ДОБ(level);
                       c := 1
                     ИНАЧЕ
                       c := 3
                     КОНЕЦ
               |0X : cont := ЛОЖЬ
            ИНАЧЕ
                c := 1
            КОНЕЦ;
        КОНЕЦ;
        ЕСЛИ cont ТОГДА
            Литера_Пропустить
        КОНЕЦ
    КОНЕЦ Комментарий_Пропустить;

ПРОЦЕДУРА Сущность_Распознать*;
   НАЧАЛО
      ПОКА Пробел_Проверить(литера) ДЕЛАТЬ
         Литера_Пропустить
      КОНЕЦ;
      мОш.уКоорд.цПоз := ccol;
      мОш.уКоорд.цСтрока := cline;
      счётчик := 0;
      ВЫБОР литера ИЗ
         |"A".."Z", "a".."z", "_": (* eng *)
            Имя_Получ;
            уСущность := мЗвСущ.Добавить(стрСущность_глоб);
            цСущность := уСущность.цКласс;
         |"А".."Я", "а".."я": (* rus *)
            Имя_Получ;
            уСущность := мЗвСущ.Добавить(стрСущность_глоб);
            цСущность := уСущность.цКласс;
         |"0".."9":
            Число_Получ;
            ВЫБОР цСущность ИЗ
               |мКонст.сущЦЕЛОЕ:  vINT := Стр_в_Цел(стрСущность_глоб)
               |мКонст.сущ16:  vINT := Стр_в_Цел16(стрСущность_глоб)
               |мКонст.lxCHX:  vCHX := Стр_в_лит16(стрСущность_глоб)
               |мКонст.сущВЕЩ: vFLT := Стр_в_Вещ(стрСущность_глоб)
            ИНАЧЕ
            КОНЕЦ
         |22X:
            цСущность := мКонст.сущСТРОКА;
            Литера_Пропустить;
            ПОКА (литера # 22X) & (литера >= 20X) ДЕЛАТЬ
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            ЕСЛИ литера = 22X ТОГДА
               Литера_Пропустить
            ИНАЧЕ
               цСущность := мКо.ошНетЗакрКавыч
            КОНЕЦ;
            Литера_Добав(0X);
            ДОБ(счётчик);
            ЕСЛИ счётчик > мКонст.строка_макс_длина ТОГДА
               цСущность := мКо.ошСтрДлинМакс
            КОНЕЦ
         |"/":
            цСущность := Разделитель_Получ(литера);
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "/" ТОГДА
               ПОКА (литера >= 20X) ИЛИ (литера = 9X) ДЕЛАТЬ
                  ЛитераСлед_Добав(литера)
               КОНЕЦ;
               Сущность_Распознать (* рекурсия *)
            КОНЕЦ;
            Литера_Добав(0X)
         |">", "<", ":":
            цСущность := Разделитель_Получ(литера);
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "=" ТОГДА
               ВЫБОР цСущность ИЗ
                  |мКонст.опМеньше:  цСущность := мКонст.опМеньшеИлиРавно
                  |мКонст.опБольше:  цСущность := мКонст.опБольшеИлиРавно
                  |мКонст.опДвоеточ: цСущность := мКонст.опПрисвоить
               ИНАЧЕ
               КОНЕЦ;
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            Литера_Добав(0X)
         |".":
            цСущность := мКонст.опТочка;
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "." ТОГДА
               цСущность := мКонст.lxDbl;
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            Литера_Добав(0X)
         |"(":
            цСущность := мКонст.опСкобкаЛевКругл;
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "*" ТОГДА
               Комментарий_Пропустить;
               Сущность_Распознать (* рекурсия *)
            КОНЕЦ;
            Литера_Добав(0X)
         |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            цСущность := Разделитель_Получ(литера);
            Литера_Добав(литера);
            ЛитераСлед_Добав(0X)
         |0X:
            цСущность := мКонст.сущКОН;
            Литера_Добав(0X)
         ИНАЧЕ
            цСущность := мКо.ошНедопустимЛит
         КОНЕЦ
   КОНЕЦ Сущность_Распознать;

ПРОЦЕДУРА КлючСлово_Добавить(слово_: мСтр.тСтрока; номер_: ЦЕЛОЕ);
   ПЕРЕМ
      сущ: мЗвСущ.туЗвеноСущ;
   НАЧАЛО
      сущ := мЗвСущ.Добавить(слово_);
      сущ.цКласс := номер_
   КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
   ПЕРЕМ
      i: ЦЕЛОЕ;
      уСущность: мЗвСущ.туЗвеноСущ;
   НАЧАЛО
      ДЛЯ i := 0 ДО мЗвСущ.Сущностей_Всего() - 1 ДЕЛАТЬ
         НОВ(уСущность);
         мПам.Мало(уСущность = ПУСТО);
         mSys.PUT(mSys.ADR(уСущность.стрИмя), i);
         уСущность.левый := ПУСТО;
         уСущность.правый := ПУСТО;
         уСущность.цКласс := мКонст.сущИМЯ;
         мЗвСущ.СущностиПункт_Уст(i, уСущность)
      КОНЕЦ;
         _START := мЗвСущ.Добавить("START");
         _version := мЗвСущ.Добавить("version");
         КлючСлово_Добавить(мКонст.ост_анг, мКонст.ксОСТ);
         КлючСлово_Добавить(мКонст.ост_рус, мКонст.ксОСТ);
        
         КлючСлово_Добавить(мКонст.выбор_анг, мКонст.ксВЫБОР);
         КлючСлово_Добавить(мКонст.выбор_рус, мКонст.ксВЫБОР);
        
         КлючСлово_Добавить(мКонст.если_анг, мКонст.ксЕСЛИ);
         КлючСлово_Добавить(мКонст.если_рус, мКонст.ксЕСЛИ);
         
         КлючСлово_Добавить(мКонст.типы_анг, мКонст.ксТИПЫ);
         КлючСлово_Добавить(мКонст.типы_рус, мКонст.ксТИПЫ);
        
         КлючСлово_Добавить(мКонст.начало_анг, мКонст.ксНАЧАЛО);
         КлючСлово_Добавить(мКонст.начало_рус, мКонст.ксНАЧАЛО);
        
         КлючСлово_Добавить(мКонст.дел_анг, мКонст.ксДЕЛ);
         КлючСлово_Добавить(мКонст.дел_рус, мКонст.ксДЕЛ);
        
         КлючСлово_Добавить(мКонст.в_анг, мКонст.ксВ);
         КлючСлово_Добавить(мКонст.в_рус, мКонст.ксВ);
        
         КлючСлово_Добавить(мКонст.пусто_анг, мКонст.ксПУСТО);
         КлючСлово_Добавить(мКонст.пусто_рус, мКонст.ксПУСТО);

         КлючСлово_Добавить(мКонст.перем_анг, мКонст.ксПЕРЕМ);
         КлючСлово_Добавить(мКонст.перем_рус, мКонст.ксПЕРЕМ);
         КлючСлово_Добавить(мКонст.пер_рус, мКонст.ксПЕРЕМ);
        
         КлючСлово_Добавить(мКонст.массив_анг, мКонст.ксМАССИВ);
         КлючСлово_Добавить(мКонст.массив_рус, мКонст.ксМАССИВ);
        
         КлючСлово_Добавить(мКонст.делать_анг, мКонст.ксДЕЛАТЬ);
         КлючСлово_Добавить(мКонст.делать_рус, мКонст.ксДЕЛАТЬ);
        
         КлючСлово_Добавить(мКонст.есть_анг, мКонст.ксЕСТЬ);
         КлючСлово_Добавить(мКонст.есть_рус, мКонст.ксЕСТЬ);
         
         КлючСлово_Добавить(мКонст.из_анг, мКонст.ксИЗ);
         КлючСлово_Добавить(мКонст.из_рус, мКонст.ксИЗ);
         
         КлючСлово_Добавить(мКонст.тогда_анг, мКонст.ксТОГДА);
         КлючСлово_Добавить(мКонст.тогда_рус, мКонст.ксТОГДА);
         
         КлючСлово_Добавить(мКонст.пока_анг, мКонст.ксПОКА);
         КлючСлово_Добавить(мКонст.пока_рус, мКонст.ксПОКА);
         
         КлючСлово_Добавить(мКонст.по_анг, мКонст.ксПО);
         КлючСлово_Добавить(мКонст.по_рус, мКонст.ксПО);
         
         КлючСлово_Добавить(мКонст.модуль_анг, мКонст.ксМОДУЛЬ);
         КлючСлово_Добавить(мКонст.модуль_рус, мКонст.ксМОДУЛЬ);
         
         КлючСлово_Добавить(мКонст.импорт_анг, мКонст.ксИМПОРТ);
         КлючСлово_Добавить(мКонст.импорт_рус, мКонст.ксИМПОРТ);
         
         КлючСлово_Добавить(мКонст.конст_анг, мКонст.ксКОНСТ);
         КлючСлово_Добавить(мКонст.конст_рус, мКонст.ксКОНСТ);

         КлючСлово_Добавить(мКонст.конец_анг, мКонст.ксКОНЕЦ);
         КлючСлово_Добавить(мКонст.конец_рус, мКонст.ксКОНЕЦ);
         
         КлючСлово_Добавить(мКонст.иначе_анг, мКонст.ксИНАЧЕ);
         КлючСлово_Добавить(мКонст.иначе_рус, мКонст.ксИНАЧЕ);
         
         КлючСлово_Добавить(мКонст.аесли_анг, мКонст.ксАЕСЛИ);
         КлючСлово_Добавить(мКонст.аесли_рус, мКонст.ксАЕСЛИ);
         
         КлючСлово_Добавить(мКонст.указатель_анг, мКонст.ксУКАЗАТЕЛЬ);
         КлючСлово_Добавить(мКонст.указатель_рус, мКонст.ксУКАЗАТЕЛЬ);
         
         КлючСлово_Добавить(мКонст.на_англ, мКонст.ксДО);
         КлючСлово_Добавить(мКонст.на_рус, мКонст.ксДО);
         КлючСлово_Добавить(мКонст.до_рус, мКонст.ксДО);
         
         КлючСлово_Добавить(мКонст.запись_анг, мКонст.ксЗАПИСЬ);
         КлючСлово_Добавить(мКонст.запись_рус, мКонст.ксЗАПИСЬ);
         
         КлючСлово_Добавить(мКонст.вернуть_анг, мКонст.ксВЕРНУТЬ);
         КлючСлово_Добавить(мКонст.вернуть_рус, мКонст.ксВЕРНУТЬ);
         
         КлючСлово_Добавить(мКонст.процедура_анг, мКонст.ксПРОЦЕДУРА);
         КлючСлово_Добавить(мКонст.процедура_рус, мКонст.ксПРОЦЕДУРА);
        
         КлючСлово_Добавить(мКонст.или_анг, мКонст.ксИЛИ);
         КлючСлово_Добавить(мКонст.или_рус, мКонст.ксИЛИ);
         
         КлючСлово_Добавить(мКонст.истина_анг, мКонст.ксИСТИНА);
         КлючСлово_Добавить(мКонст.истина_рус, мКонст.ксИСТИНА);
        
         КлючСлово_Добавить(мКонст.ложь_анг, мКонст.ксЛОЖЬ);
         КлючСлово_Добавить(мКонст.ложь_рус, мКонст.ксЛОЖЬ);
         
         КлючСлово_Добавить(мКонст.для_анг, мКонст.ксДЛЯ);
         КлючСлово_Добавить(мКонст.для_рус, мКонст.ксДЛЯ);
         
         КлючСлово_Добавить(мКонст.покане_англ, мКонст.ксПОКАНЕ);
         КлючСлово_Добавить(мКонст.покане_рус, мКонст.ксПОКАНЕ);
         
         КлючСлово_Добавить(мКонст.повторять_анг, мКонст.ксПОВТОР);
         КлючСлово_Добавить(мКонст.повторять_рус, мКонст.ксПОВТОР);
   КОНЕЦ Настроить;

НАЧАЛО
   НОВ(уФайл);
   Настроить
КОНЕЦ модСканер.
