(*
    Copyright 2013 Krotov Anton

  This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.

  *)
МОДУЛЬ модСканер;

ИМПОРТ мУтиль := модУтиль,
    mSys := SYSTEM,
    мКонст := модКонстанты,
    мФайл := модФайл,
    мТипы := модТипы,
    мПам := модПамять,
    мСтр := модСтроки;

КОНСТ

    maxDBL* = 1.69D308;
    
    IDLENGTH = 255;
    STRLENGTH* = 256;

    lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
    lxDIV = 6; 
     
    lxMOD = 17;
    
    lxLRound = 60; lxCaret = 63;
    lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
    lxLE = 75; lxGE = 76;

    lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
    lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

ПЕРЕМ

    Lex: мСтр.тСтрока;
    File, ccol, cline, count*, col*, line*, tLex*, vINT*: ЦЕЛОЕ;
    vFLT*: ДЛИНВЕЩ; id*: мТипы.туУзел; ch, vCHX*: СИМВ;
    buf, bufpos: ЦЕЛОЕ; CR, UTF8: БУЛЕВО;
    Nodes: МАССИВ 256 ИЗ мТипы.туУзел;
    _START*, _version*: мТипы.туУзел;

ПРОЦЕДУРА Узел_Добав*(Name: мСтр.тСтрока): мТипы.туУзел;
    ПЕРЕМ
      cur, res: мТипы.туУзел;

        ПРОЦЕДУРА Узел_Новый(Right: БУЛЕВО);
            НАЧАЛО
            НОВ(res);
            мПам.Ошибка(res = ПУСТО);
            res.имя := Name;
            res.tLex := lxIDENT;
            res.левый := ПУСТО;
            res.правый := ПУСТО;
            ЕСЛИ Right ТОГДА
               cur.правый := res
            ИНАЧЕ
               cur.левый := res
            КОНЕЦ
            КОНЕЦ Узел_Новый;

    НАЧАЛО
        res := ПУСТО;
        cur := Nodes[ORD(Name[0])];
        ПОВТОРЯТЬ
            ЕСЛИ Name > cur.имя ТОГДА
               ЕСЛИ cur.правый # ПУСТО ТОГДА
                  cur := cur.правый
               ИНАЧЕ
                  Узел_Новый(ИСТИНА)
               КОНЕЦ
            АЕСЛИ Name < cur.имя ТОГДА
               ЕСЛИ cur.левый # ПУСТО ТОГДА
                  cur := cur.левый
               ИНАЧЕ
                  Узел_Новый(ЛОЖЬ)
               КОНЕЦ
            ИНАЧЕ
               res := cur
            КОНЕЦ
        ПОКАНЕ res # ПУСТО
        ВЕРНУТЬ res
    КОНЕЦ Узел_Добав;

ПРОЦЕДУРА GetLexStr*(ПЕР L: мСтр.тСтрока);
    НАЧАЛО
        L := Lex
    КОНЕЦ GetLexStr;

ПРОЦЕДУРА Сохранить*(scanner: мТипы.туСканер);
    НАЧАЛО
        scanner.файл_ном := File;
        scanner.ccol := ccol;
        scanner.cline := cline;
        scanner.ch := ch;
        scanner.Lex := Lex;
        scanner.счетчик := count;
        scanner.col := col;
        scanner.строка_ном := line;
        scanner.tLex := tLex;
        scanner.vINT := vINT;
        scanner.vFLT := vFLT;
        scanner.vCHX := vCHX;
        scanner.buf := buf;
        scanner.bufpos := bufpos;
        scanner.CR := CR;
        scanner.UTF8 := UTF8
    КОНЕЦ Сохранить;

ПРОЦЕДУРА Откатить*(сканер_: мТипы.туСканер);
    НАЧАЛО
        File := сканер_.файл_ном;
        ccol := сканер_.ccol;
        cline := сканер_.cline;
        ch := сканер_.ch;
        Lex := сканер_.Lex;
        count := сканер_.счетчик;
        col := сканер_.col;
        line := сканер_.строка_ном;
        tLex := сканер_.tLex;
        vINT := сканер_.vINT;
        vFLT := сканер_.vFLT;
        vCHX := сканер_.vCHX;
        buf := сканер_.buf;
        bufpos := сканер_.bufpos;
        CR := сканер_.CR;
        UTF8 := сканер_.UTF8
    КОНЕЦ Откатить;

ПРОЦЕДУРА Next;
    ПЕРЕМ
        cr: БУЛЕВО;
    НАЧАЛО
        cr := ЛОЖЬ;
        mSys.GET(bufpos, ch);
        ДОБ(ccol);
        ВЫБОР ch ИЗ
            |0AX: ЕСЛИ ~CR ТОГДА
                    ДОБ(cline)
                    КОНЕЦ;
                    ccol := 0
            |0DX: ДОБ(cline);
                ccol := 0;
                cr := ИСТИНА
            |09X: ВЫЧ(ccol);
                ccol := ccol + мКонст.таб - (ccol - 1) MOD мКонст.таб - 1
            |80X..0BFX: ЕСЛИ UTF8 ТОГДА
                            ВЫЧ(ccol)
                        КОНЕЦ
        ИНАЧЕ
        КОНЕЦ;
        CR := cr;
        ДОБ(bufpos)
    КОНЕЦ Next;

ПРОЦЕДУРА Файл_Открыть*(FName: МАССИВ ИЗ СИМВ; ПЕР FHandle: ЦЕЛОЕ): БУЛЕВО;
    ПЕРЕМ
      n, size: ЦЕЛОЕ; c: СИМВ;
    НАЧАЛО
        File := мФайл.Открыть(FName, 0);
        FHandle := File;
        ЕСЛИ File # 0 ТОГДА
            CR := ЛОЖЬ;
            UTF8 := ЛОЖЬ;
            ccol := 0;
            cline := 1;
            ch := 0X;
            size := мФайл.Размер_Получ(File);
            buf := мПам.Получ(size + 1024);
            mSys.PUT(buf + size, 0X);
            мПам.Ошибка(buf = 0);
            n := мФайл.Читать(File, buf, size);
            мФайл.Закрыть(File);
            bufpos := buf;
            mSys.GET(buf, c);
            ЕСЛИ c = 0EFX ТОГДА
            mSys.GET(buf + 1, c);
            ЕСЛИ c = 0BBX ТОГДА
        mSys.GET(buf + 2, c);
        ЕСЛИ c = 0BFX ТОГДА
            ДОБ(bufpos, 3);
            UTF8 := ИСТИНА
        КОНЕЦ
            КОНЕЦ
            КОНЕЦ;
            Next
        КОНЕЦ
        ВЕРНУТЬ (File # 0) & (n = size)
    КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА Пробел_Проверить(ch: СИМВ): БУЛЕВО;
    ВЕРНУТЬ (ch <= 20X) & (ch > 0X)
    КОНЕЦ Пробел_Проверить;

ПРОЦЕДУРА Симв_Проверить(ch: СИМВ): БУЛЕВО;
    ПЕРЕМ
        ch_eng: БУЛЕВО;
        ch_rus: БУЛЕВО;
        
        result: БУЛЕВО;
    НАЧАЛО
        ch_eng := (ch >= "A") & (ch <= "Z") ИЛИ (ch >= "a") & (ch <= "z") ИЛИ (ch = "_");
        ch_rus := (ch >= "А") & (ch <= "Я") ИЛИ (ch >= "а") & (ch <= "я") ИЛИ (ch = "ё") ИЛИ (ch = "Ё");
        result := ch_eng ИЛИ ch_rus;
        ВЕРНУТЬ result
    КОНЕЦ Симв_Проверить;

ПРОЦЕДУРА Цифра_Проверить*(ch: СИМВ): БУЛЕВО;
        ВЕРНУТЬ (ch >= "0") & (ch <= "9")
    КОНЕЦ Цифра_Проверить;

ПРОЦЕДУРА Число16_Получ*(ch: СИМВ): БУЛЕВО;
        ВЕРНУТЬ (ch >= "A") & (ch <= "F") ИЛИ (ch >= "0") & (ch <= "9")
    КОНЕЦ Число16_Получ;

ПРОЦЕДУРА Симв_Добав(ch: СИМВ);
    НАЧАЛО
        Lex[count] := ch;
        ЕСЛИ ch # 0X ТОГДА
            ДОБ(count)
        КОНЕЦ
    КОНЕЦ Симв_Добав;

ПРОЦЕДУРА СимвСлед_Добав(ch: СИМВ);
    НАЧАЛО
        Симв_Добав(ch);
        Next
    КОНЕЦ СимвСлед_Добав;

ПРОЦЕДУРА Имя_Получ;
    НАЧАЛО
        tLex := lxIDENT;
        ПОКА Симв_Проверить(ch) ИЛИ Цифра_Проверить(ch) ДЕЛАТЬ
            СимвСлед_Добав(ch)
        КОНЕЦ;
        Симв_Добав(0X);
        ЕСЛИ count > IDLENGTH ТОГДА
            tLex := lxERR10
        КОНЕЦ
    КОНЕЦ Имя_Получ;

ПРОЦЕДУРА Число16_в_Целое*(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        Res: ЦЕЛОЕ;
    НАЧАЛО
        Res := ORD(ch);
        ВЫБОР ch ИЗ
            |"0".."9": ВЫЧ(Res, ORD("0"))
            |"A".."F": ВЫЧ(Res, ORD("A") - 10)
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Число16_в_Целое;

ПРОЦЕДУРА Стр_в_Цел16*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ
        итер, выход, поз: ЦЕЛОЕ;
        flag: БУЛЕВО; (* вот это зачем???? *)
    НАЧАЛО
        выход := 0;
        итер := 0;
        поз := 0;
        ПОКА стр_[итер] = "0" ДЕЛАТЬ
            ДОБ(итер)
        КОНЕЦ;
        flag := ИСТИНА;
        ПОКА flag & (стр_[итер] # "X") & (стр_[итер] # "H") ДЕЛАТЬ
            ДОБ(поз);
            ЕСЛИ поз > 8 ТОГДА
                tLex := lxERR5;
                flag := ЛОЖЬ
            ИНАЧЕ
                выход := LSL(выход, 4) + Число16_в_Целое(стр_[итер]);
                ДОБ(итер)
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Стр_в_Цел16;

ПРОЦЕДУРА Стр_в_Симв(стр_: мСтр.тСтрока): СИМВ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        выход := Стр_в_Цел16(стр_);
        ЕСЛИ (выход < 0) ИЛИ (выход > 0FFH) ТОГДА
            tLex := lxERR6;
            выход := 0
        КОНЕЦ
        ВЕРНУТЬ CHR(выход)
    КОНЕЦ Стр_в_Симв;

ПРОЦЕДУРА Стр_в_Цел*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
    ПЕРЕМ
        итер, выход: ЦЕЛОЕ;
        flag: БУЛЕВО;
    НАЧАЛО
        выход := 0;
        итер := 0;
        flag := ИСТИНА;
        ПОКА flag & (стр_[итер] # 0X) ДЕЛАТЬ
            ЕСЛИ выход > мКонст.целое_макс DIV 10 ТОГДА
                tLex := lxERR5;
                flag := ЛОЖЬ;
                выход := 0
            ИНАЧЕ
                выход := выход * 10;
                ЕСЛИ выход > мКонст.целое_макс - (ORD(стр_[итер]) - ORD("0")) ТОГДА
                    tLex := lxERR5;
                    flag := ЛОЖЬ;
                    выход := 0
                ИНАЧЕ
                    выход := выход + (ORD(стр_[итер]) - ORD("0"));
                    ДОБ(итер)
                КОНЕЦ
            КОНЕЦ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Стр_в_Цел;

ПРОЦЕДУРА Стр_в_Вещ(стр_: мСтр.тСтрока): ДЛИНВЕЩ;
    ПЕРЕМ
        i, scale: ЦЕЛОЕ;
        выход, m, d: ДЛИНВЕЩ;
        бМинус, nez: БУЛЕВО;

    ПРОЦЕДУРА Ошибка(e: ЦЕЛОЕ; ПЕР cont: БУЛЕВО);
        НАЧАЛО
            tLex := e;
            выход := 0.0D0;
            cont := ЛОЖЬ
        КОНЕЦ Ошибка;

    ПРОЦЕДУРА Бесконечность(ПЕР cont: БУЛЕВО; ПЕР i: ЦЕЛОЕ);
        НАЧАЛО
            ЕСЛИ мУтиль.ЕслиБесконеч(выход) ТОГДА
              Ошибка(lxERR7, cont)
            КОНЕЦ;
            ДОБ(i)
        КОНЕЦ Бесконечность;

    ПРОЦЕДУРА Часть1(): БУЛЕВО;
        ПЕРЕМ cont: БУЛЕВО;
        НАЧАЛО
            выход := 0.0D0;
            i := 0;
            d := 1.0D0;
            nez := ЛОЖЬ;
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
                nez := nez ИЛИ (стр_[i] # "0");
                выход := выход * 10.0D0 + ДЛИН(FLT(ORD(стр_[i]) - ORD("0")));
                Бесконечность(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ Часть1;

    ПРОЦЕДУРА Часть2(): БУЛЕВО;
        ПЕРЕМ
            cont: БУЛЕВО;
        НАЧАЛО
            ДОБ(i);
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
                nez := nez ИЛИ (стр_[i] # "0");
                d := d / 10.0D0;
                выход := выход + ДЛИН(FLT(ORD(стр_[i]) - ORD("0"))) * d;
                Бесконечность(cont, i)
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ Часть2;

    ПРОЦЕДУРА Часть3(): БУЛЕВО;
        ПЕРЕМ
            cont: БУЛЕВО;
        НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ стр_[i] = 0X ТОГДА
              ЕСЛИ выход > ДЛИН(мКонст.вещ_макс) ТОГДА
                Ошибка(lxERR7, cont)
              АЕСЛИ nez & ((выход = 0.0D0) ИЛИ (выход < ДЛИН(мКонст.вещ_мин)) & (tLex = lxREAL)) ТОГДА
                Ошибка(lxERR9, cont)
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ Часть3;

    ПРОЦЕДУРА Часть4(): БУЛЕВО;
        ПЕРЕМ
            cont: БУЛЕВО;
        НАЧАЛО
            ЕСЛИ стр_[i] = "D" ТОГДА
              tLex := lxLONGREAL
            КОНЕЦ;
            ДОБ(i);
            m := 10.0D0;
            бМинус := ЛОЖЬ;
            ЕСЛИ стр_[i] = "+" ТОГДА
              ДОБ(i)
            АЕСЛИ стр_[i] = "-" ТОГДА
              бМинус := ИСТИНА;
              ДОБ(i);
              m := 0.1D0
            КОНЕЦ;
            scale := 0;
            cont := ИСТИНА;
            ПОКА cont & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
              ЕСЛИ scale > мКонст.целое_макс DIV 10 ТОГДА
                Ошибка(lxERR8, cont)
              ИНАЧЕ
                scale := scale * 10;
                ЕСЛИ scale > мКонст.целое_макс - (ORD(стр_[i]) - ORD("0")) ТОГДА
                    Ошибка(lxERR8, cont)
                ИНАЧЕ
                    scale := scale + (ORD(стр_[i]) - ORD("0"));
                    ДОБ(i)
                КОНЕЦ
              КОНЕЦ
            КОНЕЦ
            ВЕРНУТЬ cont
        КОНЕЦ Часть4;

    ПРОЦЕДУРА Часть5(): БУЛЕВО;
          ПЕРЕМ
            cont: БУЛЕВО; i: ЦЕЛОЕ;
          НАЧАЛО
            cont := ИСТИНА;
            ЕСЛИ scale = мКонст.целое_макс ТОГДА
                Ошибка(lxERR8, cont)
            КОНЕЦ;
            i := 1;
            ПОКА cont & (i <= scale) ДЕЛАТЬ
                выход := выход * m;
                Бесконечность(cont, i)
            КОНЕЦ;
            ЕСЛИ cont & (nez & (выход = 0.0D0) ИЛИ (выход > 0.0D0) & (выход < ДЛИН(мКонст.вещ_мин)) & (tLex = lxREAL)) ТОГДА
                Ошибка(lxERR9, cont)
            АЕСЛИ cont & (tLex = lxREAL) & (выход > ДЛИН(мКонст.вещ_макс)) ТОГДА
                Ошибка(lxERR7, cont)
            КОНЕЦ
            ВЕРНУТЬ cont
          КОНЕЦ Часть5;

    НАЧАЛО
        ЕСЛИ Часть1() & Часть2() & Часть3() & Часть4() & Часть5() ТОГДА
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Стр_в_Вещ;

ПРОЦЕДУРА Число_Получ;
    ПЕРЕМ
        nextchr: СИМВ;
    НАЧАЛО
        tLex := lxINT;
        ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
            СимвСлед_Добав(ch)
        КОНЕЦ;
        ЕСЛИ ch = "H" ТОГДА
            tLex := lxHEX
        АЕСЛИ ch = "X" ТОГДА
            tLex := lxCHX
        КОНЕЦ;
        ЕСЛИ tLex # lxINT ТОГДА
            СимвСлед_Добав(ch)
        ИНАЧЕ
            ПОКА Число16_Получ(ch) ДЕЛАТЬ
                tLex := lxHEX;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            ЕСЛИ tLex = lxHEX ТОГДА
                ЕСЛИ ch = "H" ТОГДА
                    СимвСлед_Добав(ch)
                АЕСЛИ ch = "X" ТОГДА
                    tLex := lxCHX;
                    СимвСлед_Добав(ch)
                ИНАЧЕ
                    tLex := lxERR1
                КОНЕЦ
            АЕСЛИ ch = "." ТОГДА
                mSys.GET(bufpos, nextchr);
                ЕСЛИ nextchr # "." ТОГДА
                    tLex := lxREAL;
                    СимвСлед_Добав(ch);
                    ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                        СимвСлед_Добав(ch)
                    КОНЕЦ;
                    ЕСЛИ (ch = "E") ИЛИ (ch = "D") ТОГДА
                        СимвСлед_Добав(ch);
                        ЕСЛИ (ch = "+") ИЛИ (ch = "-") ТОГДА
                            СимвСлед_Добав(ch)
                        КОНЕЦ;
                        ЕСЛИ ~Цифра_Проверить(ch) ТОГДА
                            tLex := lxERR2
                        ИНАЧЕ
                            ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                                СимвСлед_Добав(ch)
                            КОНЕЦ
                        КОНЕЦ
                    КОНЕЦ
                КОНЕЦ
            КОНЕЦ
        КОНЕЦ;
        Симв_Добав(0X)
    КОНЕЦ Число_Получ;

ПРОЦЕДУРА Разделитель_Получ(симв_: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБОР симв_ ИЗ
        |"+": выход := мКонст.опПлюс
        |"-": выход := мКонст.опМинус
        |"*": выход := мКонст.опУмнож
        |"/": выход := мКонст.опДелен
        |"~": выход := мКонст.опОтриц
        |"&": выход := мКонст.опИ
        |",": выход := мКонст.опЗапятая
        |";": выход := мКонст.опТчкЗпт
        |"|": выход := мКонст.опВыбор
        |"[": выход := мКонст.опСкобкаЛевКв
        |"{": выход := мКонст.опСкобкаЛевФиг
        |"^": выход := lxCaret
        |"=": выход := мКонст.опРавно
        |"#": выход := мКонст.опНеРавно
        |")": выход := мКонст.опСкобкаПрКр
        |"]": выход := мКонст.опСкобкаПрКв
        |"}": выход := lxRCurly
        |">": выход := мКонст.опБольше
        |"<": выход := мКонст.опМеньше
        |":": выход := мКонст.опДвоеточ
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Разделитель_Получ;

ПРОЦЕДУРА Комментарий_Пропустить;
    ПЕРЕМ
        c, level: ЦЕЛОЕ;
        cont: БУЛЕВО;
    НАЧАЛО
        c := 1;
        level := 1;
        cont := ИСТИНА;
        ПОКА cont & (level > 0) ДЕЛАТЬ
            Next;
            ВЫБОР ch ИЗ
            |"(": c := 2
            |")": ЕСЛИ c = 3 ТОГДА
                    ВЫЧ(level)
                  КОНЕЦ;
                  c := 1
            |"*": ЕСЛИ c = 2 ТОГДА
                    ДОБ(level);
                    c := 1
                  ИНАЧЕ
                    c := 3
                  КОНЕЦ
            |0X : cont := ЛОЖЬ
            ИНАЧЕ
                c := 1
            КОНЕЦ;
        КОНЕЦ;
        ЕСЛИ cont ТОГДА
            Next
        КОНЕЦ
    КОНЕЦ Комментарий_Пропустить;

ПРОЦЕДУРА Лексема_Получ*;
    НАЧАЛО
        ПОКА Пробел_Проверить(ch) ДЕЛАТЬ
            Next
        КОНЕЦ;
        col := ccol;
        line := cline;
        count := 0;
        ВЫБОР ch ИЗ
        |"A".."Z", "a".."z", "_": (* eng *)
            Имя_Получ;
            id := Узел_Добав(Lex);
            tLex := id.tLex;
        |"А".."Я", "а".."я": (* rus *)
            Имя_Получ;
            id := Узел_Добав(Lex);
            tLex := id.tLex;
        |"0".."9":
            Число_Получ;
            ВЫБОР tLex ИЗ
                |lxINT:  vINT := Стр_в_Цел(Lex)
                |lxHEX:  vINT := Стр_в_Цел16(Lex)
                |lxCHX:  vCHX := Стр_в_Симв(Lex)
                |lxREAL: vFLT := Стр_в_Вещ(Lex)
            ИНАЧЕ
            КОНЕЦ
        |22X:
            tLex := lxSTRING;
            Next;
            ПОКА (ch # 22X) & (ch >= 20X) ДЕЛАТЬ
                СимвСлед_Добав(ch)
            КОНЕЦ;
            ЕСЛИ ch = 22X ТОГДА
                Next
            ИНАЧЕ
                tLex := lxERR3
            КОНЕЦ;
            Симв_Добав(0X);
            ДОБ(count);
            ЕСЛИ count > STRLENGTH ТОГДА
                tLex := lxERR11
            КОНЕЦ
        |"/":
            tLex := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "/" ТОГДА
                ПОКА (ch >= 20X) ИЛИ (ch = 9X) ДЕЛАТЬ
                    СимвСлед_Добав(ch)
                КОНЕЦ;
                Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
        |">", "<", ":":
            tLex := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "=" ТОГДА
                ВЫБОР tLex ИЗ
                    |мКонст.опМеньше:  tLex := lxLE
                    |мКонст.опБольше:  tLex := lxGE
                    |мКонст.опДвоеточ: tLex := lxAssign
                ИНАЧЕ
                КОНЕЦ;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
        |".":
            tLex := lxDot;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "." ТОГДА
                tLex := lxDbl;
                СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
        |"(":
            tLex := lxLRound;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "*" ТОГДА
                Комментарий_Пропустить;
                Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
        |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            tLex := Разделитель_Получ(ch);
            Симв_Добав(ch);
            СимвСлед_Добав(0X)
        |0X:
            tLex := lxEOF;
            Симв_Добав(0X)
        ИНАЧЕ
            tLex := lxERR4
        КОНЕЦ
    КОНЕЦ Лексема_Получ;

ПРОЦЕДУРА КлючСлово_Добавить(слово_: мСтр.тСтрока; номер_: ЦЕЛОЕ);
    ПЕРЕМ
        узел: мТипы.туУзел;
    НАЧАЛО
        узел := Узел_Добав(слово_);
        узел.tLex := номер_
    КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
    ПЕРЕМ
      i: ЦЕЛОЕ;
      узел: мТипы.туУзел;
    НАЧАЛО
        ДЛЯ i := 0 ДО LEN(Nodes) - 1 ДЕЛАТЬ
            НОВ(узел);
            мПам.Ошибка(узел = ПУСТО);
            mSys.PUT(mSys.ADR(узел.имя), i);
            узел.левый := ПУСТО;
            узел.правый := ПУСТО;
            узел.tLex := lxIDENT;
            Nodes[i] := узел
        КОНЕЦ;
        _START := Узел_Добав("START");
        _version := Узел_Добав("version");
        КлючСлово_Добавить("MOD", lxMOD);
        
        КлючСлово_Добавить("CASE", мКонст.ксВЫБОР);
        КлючСлово_Добавить("ВЫБОР", мКонст.ксВЫБОР);
        
        КлючСлово_Добавить("IF", мКонст.ксЕСЛИ);
        КлючСлово_Добавить("ЕСЛИ", мКонст.ксЕСЛИ);
        
        КлючСлово_Добавить("TYPE", мКонст.ксТИПЫ);
        КлючСлово_Добавить("ТИПЫ", мКонст.ксТИПЫ);
        
        КлючСлово_Добавить("BEGIN", мКонст.ксНАЧАЛО);
        КлючСлово_Добавить("НАЧАЛО", мКонст.ксНАЧАЛО);
        
        КлючСлово_Добавить("DIV", lxDIV);
        
        КлючСлово_Добавить("IN", мКонст.ксВ);
        КлючСлово_Добавить("В", мКонст.ксВ);
        
        КлючСлово_Добавить("NIL", мКонст.ксПУСТО);
        КлючСлово_Добавить("ПУСТО", мКонст.ксПУСТО);

        
        КлючСлово_Добавить("VAR", мКонст.ксПЕРЕМ);
        КлючСлово_Добавить("ПЕРЕМ", мКонст.ксПЕРЕМ);
        КлючСлово_Добавить("ПЕР", мКонст.ксПЕРЕМ);
        
        КлючСлово_Добавить("ARRAY", мКонст.ксМАССИВ);
        КлючСлово_Добавить("МАССИВ", мКонст.ксМАССИВ);
        
        КлючСлово_Добавить("DO", мКонст.ксДЕЛАТЬ);
        КлючСлово_Добавить("ДЕЛАТЬ", мКонст.ксДЕЛАТЬ);
        
        КлючСлово_Добавить("IS", мКонст.ксЕСТЬ);
        КлючСлово_Добавить("ЕСТЬ", мКонст.ксЕСТЬ);
        
        КлючСлово_Добавить("OF", мКонст.ксИЗ);
        КлючСлово_Добавить("ИЗ", мКонст.ксИЗ);
        
        КлючСлово_Добавить("THEN", мКонст.ксТОГДА);
        КлючСлово_Добавить("ТОГДА", мКонст.ксТОГДА);
        
        КлючСлово_Добавить("WHILE", мКонст.ксПОКА);
        КлючСлово_Добавить("ПОКА", мКонст.ксПОКА);
        
        КлючСлово_Добавить("BY", мКонст.lxBY);
        КлючСлово_Добавить("ПО", мКонст.lxBY);
        
        КлючСлово_Добавить("MODULE", мКонст.ксМОДУЛЬ);
        КлючСлово_Добавить("МОДУЛЬ", мКонст.ксМОДУЛЬ);
        
        КлючСлово_Добавить("IMPORT", мКонст.ксИМПОРТ);
        КлючСлово_Добавить("ИМПОРТ", мКонст.ксИМПОРТ);
        
        КлючСлово_Добавить("CONST", мКонст.ксКОНСТ);
        КлючСлово_Добавить("КОНСТ", мКонст.ксКОНСТ);

        КлючСлово_Добавить("END", мКонст.ксКОНЕЦ);
        КлючСлово_Добавить("КОНЕЦ", мКонст.ксКОНЕЦ);
        
        КлючСлово_Добавить("ELSE", мКонст.ксИНАЧЕ);
        КлючСлово_Добавить("ИНАЧЕ", мКонст.ксИНАЧЕ);
        
        КлючСлово_Добавить("ELSIF", мКонст.ксАЕСЛИ);
        КлючСлово_Добавить("АЕСЛИ", мКонст.ксАЕСЛИ);
        
        КлючСлово_Добавить("POINTER", мКонст.ксУКАЗАТЕЛЬ);
        КлючСлово_Добавить("УКАЗАТЕЛЬ", мКонст.ксУКАЗАТЕЛЬ);
        
        КлючСлово_Добавить("TO", мКонст.ксДО);
        КлючСлово_Добавить("НА", мКонст.ксДО);
        КлючСлово_Добавить("ДО", мКонст.ксДО);
        
        КлючСлово_Добавить("RECORD", мКонст.ксЗАПИСЬ);
        КлючСлово_Добавить("ЗАПИСЬ", мКонст.ксЗАПИСЬ);
        
        КлючСлово_Добавить("RETURN", мКонст.ксВЕРНУТЬ);
        КлючСлово_Добавить("ВЕРНУТЬ", мКонст.ксВЕРНУТЬ);
        
        КлючСлово_Добавить("PROCEDURE", мКонст.ксПРОЦЕДУРА);
        КлючСлово_Добавить("ПРОЦЕДУРА", мКонст.ксПРОЦЕДУРА);
        
        КлючСлово_Добавить("OR", мКонст.lxOR);
        КлючСлово_Добавить("ИЛИ", мКонст.lxOR);
        
        КлючСлово_Добавить("TRUE", мКонст.ксИСТИНА);
        КлючСлово_Добавить("ИСТИНА", мКонст.ксИСТИНА);
        
        КлючСлово_Добавить("FALSE", мКонст.ксЛОЖЬ);
        КлючСлово_Добавить("ЛОЖЬ", мКонст.ксЛОЖЬ);
        
        КлючСлово_Добавить("FOR", мКонст.ксДЛЯ);
        КлючСлово_Добавить("ДЛЯ", мКонст.ксДЛЯ);
        
        КлючСлово_Добавить("UNTIL", мКонст.ксПОКАНЕ);
        КлючСлово_Добавить("ПОКАНЕ", мКонст.ксПОКАНЕ);
        
        КлючСлово_Добавить("REPEAT", мКонст.ксПОВТОР);
        КлючСлово_Добавить("ПОВТОРЯТЬ", мКонст.ксПОВТОР);
        
   КОНЕЦ Настроить;

НАЧАЛО
   Настроить
КОНЕЦ модСканер.
