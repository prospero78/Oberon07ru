(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.

   *)
МОДУЛЬ модСканер;

ИМПОРТ мУтиль := модУтиль,
   mSys := SYSTEM,
   мКонст := модКонстанты,
   мФайл := модФайл,
   мПам := модПамять,
   мСтр := модСтроки,
   мЗнач := модЗначение,
   мУзел := модЗвеноКс;

КОНСТ

   maxDBL* = 1.69D308;
   
   IDLENGTH = 255;
   STRLENGTH* = 256;

   lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
   
   lxLRound = 60; lxCaret = 63;
   lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
   lxLE = 75; lxGE = 76;

   lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
   lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

ТИПЫ
   туСканер* = УКАЗАТЕЛЬ НА ЗАПИСЬ
         файл_ном*, ccol*, cline*, счётчик*, col*, строка_ном*, цКлСлово*: ЦЕЛОЕ;
         литера* : ЛИТ;
         стрСущн*: мСтр.тСтрока;
         знач*: мЗнач.тЗначение;
         уУзел*: мУзел.туЗвеноСущ;
         буфер*, буф_поз*: ЦЕЛОЕ;
         CR*, UTF8*: БУЛЕВО
      КОНЕЦ;

ПЕРЕМ

   Lex: мСтр.тСтрока;
   уФайл : мФайл.туФайл;
   значение :мЗнач.тЗначение;
   ccol, cline, счётчик*, col*, цСтрока*, сущность*, vINT*: ЦЕЛОЕ;
   vFLT*: ДЛИНВЕЩ;
   id*: мУзел.туЗвеноСущ;
   литера, vCHX*: ЛИТ;
   CR, UTF8: БУЛЕВО;
   _START*, _version*: мУзел.туЗвеноСущ;

ПРОЦЕДУРА GetLexStr*(ПЕР L: мСтр.тСтрока);
   НАЧАЛО
      L := Lex
   КОНЕЦ GetLexStr;

ПРОЦЕДУРА Сохранить*(уСканер_: туСканер);
   НАЧАЛО
      уСканер_.файл_ном := уФайл.номер;
      уСканер_.ccol := ccol;
      уСканер_.cline := cline;
      уСканер_.литера := литера;
      уСканер_.стрСущн := Lex;
      уСканер_.счётчик := счётчик;
      уСканер_.col := col;
      уСканер_.строка_ном := цСтрока;
      уСканер_.цКлСлово := сущность;
      уСканер_.знач.целое := vINT;
      уСканер_.знач.вещ := vFLT;
      уСканер_.знач.символ := vCHX;
      уСканер_.буфер := уФайл.буфер;
      уСканер_.буф_поз := уФайл.буф_поз;
      уСканер_.CR := CR;
      уСканер_.UTF8 := UTF8
   КОНЕЦ Сохранить;

ПРОЦЕДУРА Откатить*(сканер_: туСканер);
   НАЧАЛО
      уФайл.номер := сканер_.файл_ном;
      ccol := сканер_.ccol;
      cline := сканер_.cline;
      литера := сканер_.литера;
      Lex := сканер_.стрСущн;
      счётчик := сканер_.счётчик;
      col := сканер_.col;
      цСтрока := сканер_.строка_ном;
      сущность := сканер_.цКлСлово;
      vINT := сканер_.знач.целое;
      vFLT := сканер_.знач.вещ;
      vCHX := сканер_.знач.символ;
      уФайл.буфер := сканер_.буфер;
      уФайл.буф_поз := сканер_.буф_поз;
      CR := сканер_.CR;
      UTF8 := сканер_.UTF8
    КОНЕЦ Откатить;

ПРОЦЕДУРА Литера_Пропустить;
    ПЕРЕМ
        cr: БУЛЕВО;
    НАЧАЛО
        cr := ЛОЖЬ;
        mSys.GET(уФайл.буф_поз, литера);
        ДОБ(ccol);
        ВЫБОР литера ИЗ
            |0AX: ЕСЛИ ~CR ТОГДА
                    ДОБ(cline)
                    КОНЕЦ;
                    ccol := 0
            |0DX: ДОБ(cline);
                ccol := 0;
                cr := ИСТИНА
            |09X: ВЫЧ(ccol);
                ccol := ccol + мКонст.таб - (ccol - 1) ОСТ мКонст.таб - 1
            |80X..0BFX: ЕСЛИ UTF8 ТОГДА
                            ВЫЧ(ccol)
                        КОНЕЦ
        ИНАЧЕ
        КОНЕЦ;
        CR := cr;
        ДОБ(уФайл.буф_поз)
    КОНЕЦ Литера_Пропустить;

ПРОЦЕДУРА Файл_Открыть*(FName: МАССИВ ИЗ ЛИТ; ПЕР FHandle: ЦЕЛОЕ): БУЛЕВО;
   ПЕРЕМ
      n, size: ЦЕЛОЕ; c: ЛИТ;
   НАЧАЛО
      уФайл.номер := мФайл.Открыть(FName, 0);
      FHandle := уФайл.номер;
      ЕСЛИ уФайл.номер # 0 ТОГДА
         CR := ЛОЖЬ;
         UTF8 := ЛОЖЬ;
         ccol := 0;
         cline := 1;
         литера := 0X;
         size := мФайл.Размер_Получ(уФайл.номер);
         уФайл.буфер := мПам.Получ(size + 1024);
         mSys.PUT(уФайл.буфер + size, 0X);
         мПам.Мало(уФайл.буфер = 0);
         n := мФайл.Читать(уФайл.номер, уФайл.буфер, size);
         мФайл.Закрыть(уФайл.номер);
         уФайл.буф_поз := уФайл.буфер;
         mSys.GET(уФайл.буфер, c);
         ЕСЛИ c = 0EFX ТОГДА
            mSys.GET(уФайл.буфер + 1, c);
            ЕСЛИ c = 0BBX ТОГДА
               mSys.GET(уФайл.буфер + 2, c);
               ЕСЛИ c = 0BFX ТОГДА
                  ДОБ(уФайл.буф_поз, 3);
                  UTF8 := ИСТИНА
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ;
         Литера_Пропустить
      КОНЕЦ
      ВЕРНУТЬ (уФайл.номер # 0) & (n = size)
   КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА Пробел_Проверить(лит_: ЛИТ): БУЛЕВО;
    ВЕРНУТЬ (лит_ > 0X) & (лит_ <= 20X)
    КОНЕЦ Пробел_Проверить;

ПРОЦЕДУРА Буква_Проверить(лит_: ЛИТ): БУЛЕВО;
    ПЕРЕМ
        лит_анг: БУЛЕВО;
        лит_рус: БУЛЕВО;
        
        выход: БУЛЕВО;
    НАЧАЛО
        лит_анг := (лит_ >= "A") & (лит_ <= "Z") ИЛИ (лит_ >= "a") & (лит_ <= "z") ИЛИ (лит_ = "_");
        лит_рус := (лит_ >= "А") & (лит_ <= "Я") ИЛИ (лит_ >= "а") & (лит_ <= "я") ИЛИ (лит_ = "ё") ИЛИ (лит_ = "Ё");
        выход := лит_анг ИЛИ лит_рус;
        ВЕРНУТЬ выход
    КОНЕЦ Буква_Проверить;

ПРОЦЕДУРА Цифра_Проверить*(лит_: ЛИТ): БУЛЕВО;
        ВЕРНУТЬ (лит_ >= "0") & (лит_ <= "9")
    КОНЕЦ Цифра_Проверить;

ПРОЦЕДУРА Число16_Получ*(лит_: ЛИТ): БУЛЕВО;
        ВЕРНУТЬ (лит_ >= "0") & (лит_ <= "9") ИЛИ (лит_ >= "A") & (лит_ <= "F")
    КОНЕЦ Число16_Получ;

ПРОЦЕДУРА Литера_Добав(лит_: ЛИТ);
    НАЧАЛО
        Lex[счётчик] := лит_;
        ЕСЛИ лит_ # 0X ТОГДА
            ДОБ(счётчик)
        КОНЕЦ
    КОНЕЦ Литера_Добав;

ПРОЦЕДУРА ЛитераСлед_Добав(лит_: ЛИТ);
    НАЧАЛО
        Литера_Добав(лит_);
        Литера_Пропустить
    КОНЕЦ ЛитераСлед_Добав;

ПРОЦЕДУРА Имя_Получ;
   НАЧАЛО
      сущность := lxIDENT;
      ПОКА Буква_Проверить(литера) ИЛИ Цифра_Проверить(литера) ДЕЛАТЬ
         ЛитераСлед_Добав(литера)
      КОНЕЦ;
      Литера_Добав(0X);
      ЕСЛИ счётчик > IDLENGTH ТОГДА
         сущность := lxERR10
      КОНЕЦ
   КОНЕЦ Имя_Получ;

ПРОЦЕДУРА Число16_в_Целое*(лит_: ЛИТ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        выход := НЛИТ(лит_);
        ВЫБОР лит_ ИЗ
            |"0".."9": ВЫЧ(выход, НЛИТ("0"))
            |"A".."F": ВЫЧ(выход, НЛИТ("A") - 10)
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Число16_в_Целое;

ПРОЦЕДУРА Стр_в_Цел16*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход, поз: ЦЕЛОЕ;
      flag: БУЛЕВО; (* вот это зачем???? *)
   НАЧАЛО
      выход := 0;
      итер := 0;
      поз := 0;
      ПОКА стр_[итер] = "0" ДЕЛАТЬ
         ДОБ(итер)
      КОНЕЦ;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # "X") & (стр_[итер] # "H") ДЕЛАТЬ
         ДОБ(поз);
         ЕСЛИ поз > 8 ТОГДА
            сущность := lxERR5;
            flag := ЛОЖЬ
         ИНАЧЕ
            выход := ЛСЛ(выход, 4) + Число16_в_Целое(стр_[итер]);
            ДОБ(итер)
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Цел16;

ПРОЦЕДУРА Стр_в_Симв(стр_: мСтр.тСтрока): ЛИТ;
   ПЕРЕМ
      выход: ЦЕЛОЕ;
   НАЧАЛО
      выход := Стр_в_Цел16(стр_);
      ЕСЛИ (выход < 0) ИЛИ (выход > 0FFH) ТОГДА
         сущность := lxERR6;
         выход := 0
      КОНЕЦ
         ВЕРНУТЬ ВЛИТ(выход)
   КОНЕЦ Стр_в_Симв;

ПРОЦЕДУРА Стр_в_Цел*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход: ЦЕЛОЕ;
      flag: БУЛЕВО;
   НАЧАЛО
      выход := 0;
      итер := 0;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # 0X) ДЕЛАТЬ
         ЕСЛИ выход > мКонст.целое_макс ДЕЛ 10 ТОГДА
            сущность := lxERR5;
            flag := ЛОЖЬ;
            выход := 0
         ИНАЧЕ
            выход := выход * 10;
            ЕСЛИ выход > мКонст.целое_макс - (НЛИТ(стр_[итер]) - НЛИТ("0")) ТОГДА
               сущность := lxERR5;
               flag := ЛОЖЬ;
               выход := 0
            ИНАЧЕ
               выход := выход + (НЛИТ(стр_[итер]) - НЛИТ("0"));
               ДОБ(итер)
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Цел;

ПРОЦЕДУРА Стр_в_Вещ(стр_: мСтр.тСтрока): ДЛИНВЕЩ;
   ПЕРЕМ
      i, шкала: ЦЕЛОЕ;
      выход, m, d: ДЛИНВЕЩ;
      бМинус, nez: БУЛЕВО;

   ПРОЦЕДУРА Ошибка(цКлСлово_: ЦЕЛОЕ; ПЕР продолж_: БУЛЕВО);
      НАЧАЛО
         сущность := цКлСлово_;
         выход := 0.0D0;
         продолж_ := ЛОЖЬ
      КОНЕЦ Ошибка;

   ПРОЦЕДУРА Бесконечность(ПЕР продолж_: БУЛЕВО; ПЕР i: ЦЕЛОЕ);
      НАЧАЛО
         ЕСЛИ мУтиль.ЕслиБесконеч(выход) ТОГДА
            Ошибка(lxERR7, продолж_)
         КОНЕЦ;
         ДОБ(i)
      КОНЕЦ Бесконечность;

   ПРОЦЕДУРА Часть1(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         выход := 0.0D0;
         i := 0;
         d := 1.0D0;
         nez := ЛОЖЬ;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            выход := выход * 10.0D0 + УДЛИН(КВЕЩ(НЛИТ(стр_[i]) - НЛИТ("0")));
            Бесконечность(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть1;

   ПРОЦЕДУРА Часть2(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ДОБ(i);
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            d := d / 10.0D0;
            выход := выход + УДЛИН(КВЕЩ(НЛИТ(стр_[i]) - НЛИТ("0"))) * d;
            Бесконечность(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
        КОНЕЦ Часть2;

   ПРОЦЕДУРА Часть3(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ стр_[i] = 0X ТОГДА
            ЕСЛИ выход > УДЛИН(мКонст.вещ_макс) ТОГДА
               Ошибка(lxERR7, бПродолж)
            АЕСЛИ nez & ((выход = 0.0D0) ИЛИ (выход < УДЛИН(мКонст.вещ_мин)) & (сущность = lxREAL)) ТОГДА
               Ошибка(lxERR9, бПродолж)
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть3;

   ПРОЦЕДУРА Часть4(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ЕСЛИ стр_[i] = "D" ТОГДА
            сущность := lxLONGREAL
         КОНЕЦ;
         ДОБ(i);
         m := 10.0D0;
         бМинус := ЛОЖЬ;
         ЕСЛИ стр_[i] = "+" ТОГДА
            ДОБ(i)
         АЕСЛИ стр_[i] = "-" ТОГДА
            бМинус := ИСТИНА;
            ДОБ(i);
            m := 0.1D0
         КОНЕЦ;
         шкала := 0;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            ЕСЛИ шкала > мКонст.целое_макс ДЕЛ 10 ТОГДА
               Ошибка(lxERR8, бПродолж)
            ИНАЧЕ
               шкала := шкала * 10;
               ЕСЛИ шкала > мКонст.целое_макс - (НЛИТ(стр_[i]) - НЛИТ("0")) ТОГДА
                  Ошибка(lxERR8, бПродолж)
               ИНАЧЕ
                  шкала := шкала + (НЛИТ(стр_[i]) - НЛИТ("0"));
                  ДОБ(i)
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
   КОНЕЦ Часть4;

   ПРОЦЕДУРА Часть5(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
         i: ЦЕЛОЕ;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ шкала = мКонст.целое_макс ТОГДА
            Ошибка(lxERR8, бПродолж)
         КОНЕЦ;
         i := 1;
         ПОКА бПродолж & (i <= шкала) ДЕЛАТЬ
            выход := выход * m;
            Бесконечность(бПродолж, i)
         КОНЕЦ;
         ЕСЛИ бПродолж & (nez & (выход = 0.0D0) ИЛИ (выход > 0.0D0) & (выход < УДЛИН(мКонст.вещ_мин)) & (сущность = lxREAL)) ТОГДА
            Ошибка(lxERR9, бПродолж)
         АЕСЛИ бПродолж & (сущность = lxREAL) & (выход > УДЛИН(мКонст.вещ_макс)) ТОГДА
            Ошибка(lxERR7, бПродолж)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть5;

   НАЧАЛО
      ЕСЛИ Часть1() ТОГДА
         ЕСЛИ Часть2() ТОГДА
            ЕСЛИ Часть3() ТОГДА
               ЕСЛИ Часть4() ТОГДА
                  ЕСЛИ Часть5() ТОГДА
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Вещ;

ПРОЦЕДУРА Число_Получ;
   ПЕРЕМ
      nextchr: ЛИТ;
   НАЧАЛО
      сущность := lxINT;
      ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
         ЛитераСлед_Добав(литера)
      КОНЕЦ;
      ЕСЛИ литера = "H" ТОГДА
         сущность := lxHEX
      АЕСЛИ литера = "X" ТОГДА
         сущность := lxCHX
      КОНЕЦ;
      ЕСЛИ сущность # lxINT ТОГДА
         ЛитераСлед_Добав(литера)
      ИНАЧЕ
         ПОКА Число16_Получ(литера) ДЕЛАТЬ
            сущность := lxHEX;
            ЛитераСлед_Добав(литера)
         КОНЕЦ;
         ЕСЛИ сущность = lxHEX ТОГДА
            ЕСЛИ литера = "H" ТОГДА
               ЛитераСлед_Добав(литера)
            АЕСЛИ литера = "X" ТОГДА
               сущность := lxCHX;
               ЛитераСлед_Добав(литера)
            ИНАЧЕ
               сущность := lxERR1
            КОНЕЦ
         АЕСЛИ литера = "." ТОГДА
            mSys.GET(уФайл.буф_поз, nextchr);
            ЕСЛИ nextchr # "." ТОГДА
               сущность := lxREAL;
               ЛитераСлед_Добав(литера);
               ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
                  ЛитераСлед_Добав(литера)
               КОНЕЦ;
               ЕСЛИ (литера = "E") ИЛИ (литера = "D") ТОГДА
                  ЛитераСлед_Добав(литера);
                  ЕСЛИ (литера = "+") ИЛИ (литера = "-") ТОГДА
                        ЛитераСлед_Добав(литера)
                  КОНЕЦ;
                  ЕСЛИ ~Цифра_Проверить(литера) ТОГДА
                     сущность := lxERR2
                  ИНАЧЕ
                     ПОКА Цифра_Проверить(литера) ДЕЛАТЬ
                        ЛитераСлед_Добав(литера)
                     КОНЕЦ
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ;
      Литера_Добав(0X)
   КОНЕЦ Число_Получ;

ПРОЦЕДУРА Разделитель_Получ(симв_: ЛИТ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБОР симв_ ИЗ
        |"+": выход := мКонст.опПлюс
        |"-": выход := мКонст.опМинус
        |"*": выход := мКонст.опУмнож
        |"/": выход := мКонст.опДелен
        |"~": выход := мКонст.опОтриц
        |"&": выход := мКонст.опИ
        |",": выход := мКонст.опЗапятая
        |";": выход := мКонст.опТчкЗпт
        |"|": выход := мКонст.опВыбор
        |"[": выход := мКонст.опСкобкаЛевКв
        |"{": выход := мКонст.опСкобкаЛевФиг
        |"^": выход := lxCaret
        |"=": выход := мКонст.опРавно
        |"#": выход := мКонст.опНеРавно
        |")": выход := мКонст.опСкобкаПрКр
        |"]": выход := мКонст.опСкобкаПрКв
        |"}": выход := lxRCurly
        |">": выход := мКонст.опБольше
        |"<": выход := мКонст.опМеньше
        |":": выход := мКонст.опДвоеточ
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Разделитель_Получ;

ПРОЦЕДУРА Комментарий_Пропустить;
    ПЕРЕМ
        c, level: ЦЕЛОЕ;
        cont: БУЛЕВО;
    НАЧАЛО
        c := 1;
        level := 1;
        cont := ИСТИНА;
        ПОКА cont & (level > 0) ДЕЛАТЬ
            Литера_Пропустить;
            ВЫБОР литера ИЗ
               |"(": c := 2
               |")": ЕСЛИ c = 3 ТОГДА
                       ВЫЧ(level)
                     КОНЕЦ;
                     c := 1
               |"*": ЕСЛИ c = 2 ТОГДА
                       ДОБ(level);
                       c := 1
                     ИНАЧЕ
                       c := 3
                     КОНЕЦ
               |0X : cont := ЛОЖЬ
            ИНАЧЕ
                c := 1
            КОНЕЦ;
        КОНЕЦ;
        ЕСЛИ cont ТОГДА
            Литера_Пропустить
        КОНЕЦ
    КОНЕЦ Комментарий_Пропустить;

ПРОЦЕДУРА Сущность_Получ*;
   НАЧАЛО
      ПОКА Пробел_Проверить(литера) ДЕЛАТЬ
         Литера_Пропустить
      КОНЕЦ;
      col := ccol;
      цСтрока := cline;
      счётчик := 0;
      ВЫБОР литера ИЗ
         |"A".."Z", "a".."z", "_": (* eng *)
            Имя_Получ;
            id := мУзел.Добавить(Lex);
            сущность := id.цКлСлово;
         |"А".."Я", "а".."я": (* rus *)
            Имя_Получ;
            id := мУзел.Добавить(Lex);
            сущность := id.цКлСлово;
         |"0".."9":
            Число_Получ;
            ВЫБОР сущность ИЗ
               |lxINT:  vINT := Стр_в_Цел(Lex)
               |lxHEX:  vINT := Стр_в_Цел16(Lex)
               |lxCHX:  vCHX := Стр_в_Симв(Lex)
               |lxREAL: vFLT := Стр_в_Вещ(Lex)
            ИНАЧЕ
            КОНЕЦ
         |22X:
            сущность := lxSTRING;
            Литера_Пропустить;
            ПОКА (литера # 22X) & (литера >= 20X) ДЕЛАТЬ
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            ЕСЛИ литера = 22X ТОГДА
               Литера_Пропустить
            ИНАЧЕ
               сущность := lxERR3
            КОНЕЦ;
            Литера_Добав(0X);
            ДОБ(счётчик);
            ЕСЛИ счётчик > STRLENGTH ТОГДА
               сущность := lxERR11
            КОНЕЦ
         |"/":
            сущность := Разделитель_Получ(литера);
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "/" ТОГДА
               ПОКА (литера >= 20X) ИЛИ (литера = 9X) ДЕЛАТЬ
                  ЛитераСлед_Добав(литера)
               КОНЕЦ;
               Сущность_Получ (* рекурсия *)
            КОНЕЦ;
            Литера_Добав(0X)
         |">", "<", ":":
            сущность := Разделитель_Получ(литера);
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "=" ТОГДА
               ВЫБОР сущность ИЗ
                  |мКонст.опМеньше:  сущность := lxLE
                  |мКонст.опБольше:  сущность := lxGE
                  |мКонст.опДвоеточ: сущность := lxAssign
               ИНАЧЕ
               КОНЕЦ;
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            Литера_Добав(0X)
         |".":
            сущность := lxDot;
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "." ТОГДА
               сущность := lxDbl;
               ЛитераСлед_Добав(литера)
            КОНЕЦ;
            Литера_Добав(0X)
         |"(":
            сущность := lxLRound;
            ЛитераСлед_Добав(литера);
            ЕСЛИ литера = "*" ТОГДА
               Комментарий_Пропустить;
               Сущность_Получ (* рекурсия *)
            КОНЕЦ;
            Литера_Добав(0X)
         |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            сущность := Разделитель_Получ(литера);
            Литера_Добав(литера);
            ЛитераСлед_Добав(0X)
         |0X:
            сущность := lxEOF;
            Литера_Добав(0X)
         ИНАЧЕ
            сущность := lxERR4
         КОНЕЦ
   КОНЕЦ Сущность_Получ;

ПРОЦЕДУРА КлючСлово_Добавить(слово_: мСтр.тСтрока; номер_: ЦЕЛОЕ);
   ПЕРЕМ
      узел: мУзел.туЗвеноСущ;
   НАЧАЛО
      узел := мУзел.Добавить(слово_);
      узел.цКлСлово := номер_
   КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
   ПЕРЕМ
      i: ЦЕЛОЕ;
      узел: мУзел.туЗвеноСущ;
   НАЧАЛО
      ДЛЯ i := 0 ДО мУзел.Nodes_LEN() - 1 ДЕЛАТЬ
         НОВ(узел);
         мПам.Мало(узел = ПУСТО);
         mSys.PUT(mSys.ADR(узел.стрИмя), i);
         узел.левый := ПУСТО;
         узел.правый := ПУСТО;
         узел.цКлСлово := lxIDENT;
         мУзел.Nodes_Уст(i, узел)
      КОНЕЦ;
         _START := мУзел.Добавить("START");
         _version := мУзел.Добавить("version");
         КлючСлово_Добавить(мКонст.ост_анг, мКонст.ксОСТ);
         КлючСлово_Добавить(мКонст.ост_рус, мКонст.ксОСТ);
        
         КлючСлово_Добавить(мКонст.выбор_анг, мКонст.ксВЫБОР);
         КлючСлово_Добавить(мКонст.выбор_рус, мКонст.ксВЫБОР);
        
         КлючСлово_Добавить(мКонст.если_анг, мКонст.ксЕСЛИ);
         КлючСлово_Добавить(мКонст.если_рус, мКонст.ксЕСЛИ);
         
         КлючСлово_Добавить(мКонст.типы_анг, мКонст.ксТИПЫ);
         КлючСлово_Добавить(мКонст.типы_рус, мКонст.ксТИПЫ);
        
         КлючСлово_Добавить(мКонст.начало_анг, мКонст.ксНАЧАЛО);
         КлючСлово_Добавить(мКонст.начало_рус, мКонст.ксНАЧАЛО);
        
         КлючСлово_Добавить(мКонст.дел_анг, мКонст.ксДЕЛ);
         КлючСлово_Добавить(мКонст.дел_рус, мКонст.ксДЕЛ);
        
         КлючСлово_Добавить(мКонст.в_анг, мКонст.ксВ);
         КлючСлово_Добавить(мКонст.в_рус, мКонст.ксВ);
        
         КлючСлово_Добавить(мКонст.пусто_анг, мКонст.ксПУСТО);
         КлючСлово_Добавить(мКонст.пусто_рус, мКонст.ксПУСТО);

         КлючСлово_Добавить(мКонст.перем_анг, мКонст.ксПЕРЕМ);
         КлючСлово_Добавить(мКонст.перем_рус, мКонст.ксПЕРЕМ);
         КлючСлово_Добавить(мКонст.пер_рус, мКонст.ксПЕРЕМ);
        
         КлючСлово_Добавить(мКонст.массив_анг, мКонст.ксМАССИВ);
         КлючСлово_Добавить(мКонст.массив_рус, мКонст.ксМАССИВ);
        
         КлючСлово_Добавить(мКонст.делать_анг, мКонст.ксДЕЛАТЬ);
         КлючСлово_Добавить(мКонст.делать_рус, мКонст.ксДЕЛАТЬ);
        
         КлючСлово_Добавить(мКонст.есть_анг, мКонст.ксЕСТЬ);
         КлючСлово_Добавить(мКонст.есть_рус, мКонст.ксЕСТЬ);
         
         КлючСлово_Добавить(мКонст.из_анг, мКонст.ксИЗ);
         КлючСлово_Добавить(мКонст.из_рус, мКонст.ксИЗ);
         
         КлючСлово_Добавить(мКонст.тогда_анг, мКонст.ксТОГДА);
         КлючСлово_Добавить(мКонст.тогда_рус, мКонст.ксТОГДА);
         
         КлючСлово_Добавить(мКонст.пока_анг, мКонст.ксПОКА);
         КлючСлово_Добавить(мКонст.пока_рус, мКонст.ксПОКА);
         
         КлючСлово_Добавить(мКонст.по_анг, мКонст.ксПО);
         КлючСлово_Добавить(мКонст.по_рус, мКонст.ксПО);
         
         КлючСлово_Добавить(мКонст.модуль_анг, мКонст.ксМОДУЛЬ);
         КлючСлово_Добавить(мКонст.модуль_рус, мКонст.ксМОДУЛЬ);
         
         КлючСлово_Добавить(мКонст.импорт_анг, мКонст.ксИМПОРТ);
         КлючСлово_Добавить(мКонст.импорт_рус, мКонст.ксИМПОРТ);
         
         КлючСлово_Добавить(мКонст.конст_анг, мКонст.ксКОНСТ);
         КлючСлово_Добавить(мКонст.конст_рус, мКонст.ксКОНСТ);

         КлючСлово_Добавить(мКонст.конец_анг, мКонст.ксКОНЕЦ);
         КлючСлово_Добавить(мКонст.конец_рус, мКонст.ксКОНЕЦ);
         
         КлючСлово_Добавить(мКонст.иначе_анг, мКонст.ксИНАЧЕ);
         КлючСлово_Добавить(мКонст.иначе_рус, мКонст.ксИНАЧЕ);
         
         КлючСлово_Добавить(мКонст.аесли_анг, мКонст.ксАЕСЛИ);
         КлючСлово_Добавить(мКонст.аесли_рус, мКонст.ксАЕСЛИ);
         
         КлючСлово_Добавить(мКонст.указатель_анг, мКонст.ксУКАЗАТЕЛЬ);
         КлючСлово_Добавить(мКонст.указатель_рус, мКонст.ксУКАЗАТЕЛЬ);
         
         КлючСлово_Добавить(мКонст.на_англ, мКонст.ксДО);
         КлючСлово_Добавить(мКонст.на_рус, мКонст.ксДО);
         КлючСлово_Добавить(мКонст.до_рус, мКонст.ксДО);
         
         КлючСлово_Добавить(мКонст.запись_анг, мКонст.ксЗАПИСЬ);
         КлючСлово_Добавить(мКонст.запись_рус, мКонст.ксЗАПИСЬ);
         
         КлючСлово_Добавить(мКонст.вернуть_анг, мКонст.ксВЕРНУТЬ);
         КлючСлово_Добавить(мКонст.вернуть_рус, мКонст.ксВЕРНУТЬ);
         
         КлючСлово_Добавить(мКонст.процедура_анг, мКонст.ксПРОЦЕДУРА);
         КлючСлово_Добавить(мКонст.процедура_рус, мКонст.ксПРОЦЕДУРА);
        
         КлючСлово_Добавить(мКонст.или_анг, мКонст.ксИЛИ);
         КлючСлово_Добавить(мКонст.или_рус, мКонст.ксИЛИ);
         
         КлючСлово_Добавить(мКонст.истина_анг, мКонст.ксИСТИНА);
         КлючСлово_Добавить(мКонст.истина_рус, мКонст.ксИСТИНА);
        
         КлючСлово_Добавить(мКонст.ложь_анг, мКонст.ксЛОЖЬ);
         КлючСлово_Добавить(мКонст.ложь_рус, мКонст.ксЛОЖЬ);
         
         КлючСлово_Добавить(мКонст.для_анг, мКонст.ксДЛЯ);
         КлючСлово_Добавить(мКонст.для_рус, мКонст.ксДЛЯ);
         
         КлючСлово_Добавить(мКонст.покане_англ, мКонст.ксПОКАНЕ);
         КлючСлово_Добавить(мКонст.покане_рус, мКонст.ксПОКАНЕ);
         
         КлючСлово_Добавить(мКонст.повторять_анг, мКонст.ксПОВТОР);
         КлючСлово_Добавить(мКонст.повторять_рус, мКонст.ксПОВТОР);
   КОНЕЦ Настроить;

НАЧАЛО
   НОВ(уФайл);
   Настроить
КОНЕЦ модСканер.
