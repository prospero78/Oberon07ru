(*
   Copyright 2013 Krotov Anton

   This file is part of Compiler.

   Compiler is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Compiler is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Compiler. If not, see <http://www.gnu.org/licenses/>.

   *)
МОДУЛЬ модСканер;

ИМПОРТ мУтиль := модУтиль,
   mSys := SYSTEM,
   мКонст := модКонстанты,
   мФайл := модФайл,
   мПам := модПамять,
   мСтр := модСтроки,
   мЗнач := модЗначение,
   мУзел := модУзел;

КОНСТ

   maxDBL* = 1.69D308;
   
   IDLENGTH = 255;
   STRLENGTH* = 256;

   lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
   lxDIV = 6; 
   
   lxMOD = 17;
   
   lxLRound = 60; lxCaret = 63;
   lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69;
   lxLE = 75; lxGE = 76;

   lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
   lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;

ТИПЫ
   туСканер* = УКАЗАТЕЛЬ НА ЗАПИСЬ
         файл_ном*, ccol*, cline*, счетчик*, col*, строка_ном*, цКлСлово*: ЦЕЛОЕ;
         ch* : СИМВ;
         Lex*: мСтр.тСтрока;
         знач*: мЗнач.тЗначение;
         id*: мУзел.туУзел;
         buf*, bufpos*: ЦЕЛОЕ;
         CR*, UTF8*: БУЛЕВО
      КОНЕЦ;

ПЕРЕМ

   Lex: мСтр.тСтрока;
   файл : мФайл.туФайл;
   значение :мЗнач.тЗначение;
   ccol, cline, count*, col*, line*, сущность*, vINT*: ЦЕЛОЕ;
   vFLT*: ДЛИНВЕЩ;
   id*: мУзел.туУзел;
   ch, vCHX*: СИМВ;
   CR, UTF8: БУЛЕВО;
   _START*, _version*: мУзел.туУзел;

ПРОЦЕДУРА GetLexStr*(ПЕР L: мСтр.тСтрока);
   НАЧАЛО
      L := Lex
   КОНЕЦ GetLexStr;

ПРОЦЕДУРА Сохранить*(scanner: туСканер);
   НАЧАЛО
      scanner.файл_ном := файл.номер;
      scanner.ccol := ccol;
      scanner.cline := cline;
      scanner.ch := ch;
      scanner.Lex := Lex;
      scanner.счетчик := count;
      scanner.col := col;
      scanner.строка_ном := line;
      scanner.цКлСлово := сущность;
      scanner.знач.целое := vINT;
      scanner.знач.вещ := vFLT;
      scanner.знач.символ := vCHX;
      scanner.buf := файл.буфер;
      scanner.bufpos := файл.буф_поз;
      scanner.CR := CR;
      scanner.UTF8 := UTF8
   КОНЕЦ Сохранить;

ПРОЦЕДУРА Откатить*(сканер_: туСканер);
   НАЧАЛО
      файл.номер := сканер_.файл_ном;
      ccol := сканер_.ccol;
      cline := сканер_.cline;
      ch := сканер_.ch;
      Lex := сканер_.Lex;
      count := сканер_.счетчик;
      col := сканер_.col;
      line := сканер_.строка_ном;
      сущность := сканер_.цКлСлово;
      vINT := сканер_.знач.целое;
      vFLT := сканер_.знач.вещ;
      vCHX := сканер_.знач.символ;
      файл.буфер := сканер_.buf;
      файл.буф_поз := сканер_.bufpos;
      CR := сканер_.CR;
      UTF8 := сканер_.UTF8
    КОНЕЦ Откатить;

ПРОЦЕДУРА Next;
    ПЕРЕМ
        cr: БУЛЕВО;
    НАЧАЛО
        cr := ЛОЖЬ;
        mSys.GET(файл.буф_поз, ch);
        ДОБ(ccol);
        ВЫБОР ch ИЗ
            |0AX: ЕСЛИ ~CR ТОГДА
                    ДОБ(cline)
                    КОНЕЦ;
                    ccol := 0
            |0DX: ДОБ(cline);
                ccol := 0;
                cr := ИСТИНА
            |09X: ВЫЧ(ccol);
                ccol := ccol + мКонст.таб - (ccol - 1) MOD мКонст.таб - 1
            |80X..0BFX: ЕСЛИ UTF8 ТОГДА
                            ВЫЧ(ccol)
                        КОНЕЦ
        ИНАЧЕ
        КОНЕЦ;
        CR := cr;
        ДОБ(файл.буф_поз)
    КОНЕЦ Next;

ПРОЦЕДУРА Файл_Открыть*(FName: МАССИВ ИЗ СИМВ; ПЕР FHandle: ЦЕЛОЕ): БУЛЕВО;
   ПЕРЕМ
      n, size: ЦЕЛОЕ; c: СИМВ;
   НАЧАЛО
      файл.номер := мФайл.Открыть(FName, 0);
      FHandle := файл.номер;
      ЕСЛИ файл.номер # 0 ТОГДА
         CR := ЛОЖЬ;
         UTF8 := ЛОЖЬ;
         ccol := 0;
         cline := 1;
         ch := 0X;
         size := мФайл.Размер_Получ(файл.номер);
         файл.буфер := мПам.Получ(size + 1024);
         mSys.PUT(файл.буфер + size, 0X);
         мПам.Ошибка(файл.буфер = 0);
         n := мФайл.Читать(файл.номер, файл.буфер, size);
         мФайл.Закрыть(файл.номер);
         файл.буф_поз := файл.буфер;
         mSys.GET(файл.буфер, c);
         ЕСЛИ c = 0EFX ТОГДА
            mSys.GET(файл.буфер + 1, c);
            ЕСЛИ c = 0BBX ТОГДА
               mSys.GET(файл.буфер + 2, c);
               ЕСЛИ c = 0BFX ТОГДА
                  ДОБ(файл.буф_поз, 3);
                  UTF8 := ИСТИНА
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ;
         Next
      КОНЕЦ
      ВЕРНУТЬ (файл.номер # 0) & (n = size)
   КОНЕЦ Файл_Открыть;

ПРОЦЕДУРА Пробел_Проверить(ch: СИМВ): БУЛЕВО;
    ВЕРНУТЬ (ch <= 20X) & (ch > 0X)
    КОНЕЦ Пробел_Проверить;

ПРОЦЕДУРА Симв_Проверить(ch: СИМВ): БУЛЕВО;
    ПЕРЕМ
        ch_eng: БУЛЕВО;
        ch_rus: БУЛЕВО;
        
        result: БУЛЕВО;
    НАЧАЛО
        ch_eng := (ch >= "A") & (ch <= "Z") ИЛИ (ch >= "a") & (ch <= "z") ИЛИ (ch = "_");
        ch_rus := (ch >= "А") & (ch <= "Я") ИЛИ (ch >= "а") & (ch <= "я") ИЛИ (ch = "ё") ИЛИ (ch = "Ё");
        result := ch_eng ИЛИ ch_rus;
        ВЕРНУТЬ result
    КОНЕЦ Симв_Проверить;

ПРОЦЕДУРА Цифра_Проверить*(ch: СИМВ): БУЛЕВО;
        ВЕРНУТЬ (ch >= "0") & (ch <= "9")
    КОНЕЦ Цифра_Проверить;

ПРОЦЕДУРА Число16_Получ*(ch: СИМВ): БУЛЕВО;
        ВЕРНУТЬ (ch >= "A") & (ch <= "F") ИЛИ (ch >= "0") & (ch <= "9")
    КОНЕЦ Число16_Получ;

ПРОЦЕДУРА Симв_Добав(ch: СИМВ);
    НАЧАЛО
        Lex[count] := ch;
        ЕСЛИ ch # 0X ТОГДА
            ДОБ(count)
        КОНЕЦ
    КОНЕЦ Симв_Добав;

ПРОЦЕДУРА СимвСлед_Добав(ch: СИМВ);
    НАЧАЛО
        Симв_Добав(ch);
        Next
    КОНЕЦ СимвСлед_Добав;

ПРОЦЕДУРА Имя_Получ;
   НАЧАЛО
      сущность := lxIDENT;
      ПОКА Симв_Проверить(ch) ИЛИ Цифра_Проверить(ch) ДЕЛАТЬ
         СимвСлед_Добав(ch)
      КОНЕЦ;
      Симв_Добав(0X);
      ЕСЛИ count > IDLENGTH ТОГДА
         сущность := lxERR10
      КОНЕЦ
   КОНЕЦ Имя_Получ;

ПРОЦЕДУРА Число16_в_Целое*(ch: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        Res: ЦЕЛОЕ;
    НАЧАЛО
        Res := ORD(ch);
        ВЫБОР ch ИЗ
            |"0".."9": ВЫЧ(Res, ORD("0"))
            |"A".."F": ВЫЧ(Res, ORD("A") - 10)
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ Res
    КОНЕЦ Число16_в_Целое;

ПРОЦЕДУРА Стр_в_Цел16*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход, поз: ЦЕЛОЕ;
      flag: БУЛЕВО; (* вот это зачем???? *)
   НАЧАЛО
      выход := 0;
      итер := 0;
      поз := 0;
      ПОКА стр_[итер] = "0" ДЕЛАТЬ
         ДОБ(итер)
      КОНЕЦ;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # "X") & (стр_[итер] # "H") ДЕЛАТЬ
         ДОБ(поз);
         ЕСЛИ поз > 8 ТОГДА
            сущность := lxERR5;
            flag := ЛОЖЬ
         ИНАЧЕ
            выход := LSL(выход, 4) + Число16_в_Целое(стр_[итер]);
            ДОБ(итер)
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Цел16;

ПРОЦЕДУРА Стр_в_Симв(стр_: мСтр.тСтрока): СИМВ;
   ПЕРЕМ
      выход: ЦЕЛОЕ;
   НАЧАЛО
      выход := Стр_в_Цел16(стр_);
      ЕСЛИ (выход < 0) ИЛИ (выход > 0FFH) ТОГДА
         сущность := lxERR6;
         выход := 0
      КОНЕЦ
         ВЕРНУТЬ CHR(выход)
   КОНЕЦ Стр_в_Симв;

ПРОЦЕДУРА Стр_в_Цел*(стр_: мСтр.тСтрока): ЦЕЛОЕ;
   ПЕРЕМ
      итер, выход: ЦЕЛОЕ;
      flag: БУЛЕВО;
   НАЧАЛО
      выход := 0;
      итер := 0;
      flag := ИСТИНА;
      ПОКА flag & (стр_[итер] # 0X) ДЕЛАТЬ
         ЕСЛИ выход > мКонст.целое_макс DIV 10 ТОГДА
            сущность := lxERR5;
            flag := ЛОЖЬ;
            выход := 0
         ИНАЧЕ
            выход := выход * 10;
            ЕСЛИ выход > мКонст.целое_макс - (ORD(стр_[итер]) - ORD("0")) ТОГДА
               сущность := lxERR5;
               flag := ЛОЖЬ;
               выход := 0
            ИНАЧЕ
               выход := выход + (ORD(стр_[итер]) - ORD("0"));
               ДОБ(итер)
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
    КОНЕЦ Стр_в_Цел;

ПРОЦЕДУРА Стр_в_Вещ(стр_: мСтр.тСтрока): ДЛИНВЕЩ;
   ПЕРЕМ
      i, шкала: ЦЕЛОЕ;
      выход, m, d: ДЛИНВЕЩ;
      бМинус, nez: БУЛЕВО;

   ПРОЦЕДУРА Ошибка(цКлСлово_: ЦЕЛОЕ; ПЕР продолж_: БУЛЕВО);
      НАЧАЛО
         сущность := цКлСлово_;
         выход := 0.0D0;
         продолж_ := ЛОЖЬ
      КОНЕЦ Ошибка;

   ПРОЦЕДУРА Бесконечность(ПЕР продолж_: БУЛЕВО; ПЕР i: ЦЕЛОЕ);
      НАЧАЛО
         ЕСЛИ мУтиль.ЕслиБесконеч(выход) ТОГДА
            Ошибка(lxERR7, продолж_)
         КОНЕЦ;
         ДОБ(i)
      КОНЕЦ Бесконечность;

   ПРОЦЕДУРА Часть1(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         выход := 0.0D0;
         i := 0;
         d := 1.0D0;
         nez := ЛОЖЬ;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            выход := выход * 10.0D0 + ДЛИН(FLT(ORD(стр_[i]) - ORD("0")));
            Бесконечность(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть1;

   ПРОЦЕДУРА Часть2(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ДОБ(i);
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            nez := nez ИЛИ (стр_[i] # "0");
            d := d / 10.0D0;
            выход := выход + ДЛИН(FLT(ORD(стр_[i]) - ORD("0"))) * d;
            Бесконечность(бПродолж, i)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
        КОНЕЦ Часть2;

   ПРОЦЕДУРА Часть3(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ стр_[i] = 0X ТОГДА
            ЕСЛИ выход > ДЛИН(мКонст.вещ_макс) ТОГДА
               Ошибка(lxERR7, бПродолж)
            АЕСЛИ nez & ((выход = 0.0D0) ИЛИ (выход < ДЛИН(мКонст.вещ_мин)) & (сущность = lxREAL)) ТОГДА
               Ошибка(lxERR9, бПродолж)
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть3;

   ПРОЦЕДУРА Часть4(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
      НАЧАЛО
         ЕСЛИ стр_[i] = "D" ТОГДА
            сущность := lxLONGREAL
         КОНЕЦ;
         ДОБ(i);
         m := 10.0D0;
         бМинус := ЛОЖЬ;
         ЕСЛИ стр_[i] = "+" ТОГДА
            ДОБ(i)
         АЕСЛИ стр_[i] = "-" ТОГДА
            бМинус := ИСТИНА;
            ДОБ(i);
            m := 0.1D0
         КОНЕЦ;
         шкала := 0;
         бПродолж := ИСТИНА;
         ПОКА бПродолж & Цифра_Проверить(стр_[i]) ДЕЛАТЬ
            ЕСЛИ шкала > мКонст.целое_макс DIV 10 ТОГДА
               Ошибка(lxERR8, бПродолж)
            ИНАЧЕ
               шкала := шкала * 10;
               ЕСЛИ шкала > мКонст.целое_макс - (ORD(стр_[i]) - ORD("0")) ТОГДА
                  Ошибка(lxERR8, бПродолж)
               ИНАЧЕ
                  шкала := шкала + (ORD(стр_[i]) - ORD("0"));
                  ДОБ(i)
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
         ВЕРНУТЬ бПродолж
   КОНЕЦ Часть4;

   ПРОЦЕДУРА Часть5(): БУЛЕВО;
      ПЕРЕМ
         бПродолж: БУЛЕВО;
         i: ЦЕЛОЕ;
      НАЧАЛО
         бПродолж := ИСТИНА;
         ЕСЛИ шкала = мКонст.целое_макс ТОГДА
            Ошибка(lxERR8, бПродолж)
         КОНЕЦ;
         i := 1;
         ПОКА бПродолж & (i <= шкала) ДЕЛАТЬ
            выход := выход * m;
            Бесконечность(бПродолж, i)
         КОНЕЦ;
         ЕСЛИ бПродолж & (nez & (выход = 0.0D0) ИЛИ (выход > 0.0D0) & (выход < ДЛИН(мКонст.вещ_мин)) & (сущность = lxREAL)) ТОГДА
            Ошибка(lxERR9, бПродолж)
         АЕСЛИ бПродолж & (сущность = lxREAL) & (выход > ДЛИН(мКонст.вещ_макс)) ТОГДА
            Ошибка(lxERR7, бПродолж)
         КОНЕЦ
         ВЕРНУТЬ бПродолж
      КОНЕЦ Часть5;

   НАЧАЛО
      ЕСЛИ Часть1() ТОГДА
         ЕСЛИ Часть2() ТОГДА
            ЕСЛИ Часть3() ТОГДА
               ЕСЛИ Часть4() ТОГДА
                  ЕСЛИ Часть5() ТОГДА
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ
      ВЕРНУТЬ выход
   КОНЕЦ Стр_в_Вещ;

ПРОЦЕДУРА Число_Получ;
   ПЕРЕМ
      nextchr: СИМВ;
   НАЧАЛО
      сущность := lxINT;
      ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
         СимвСлед_Добав(ch)
      КОНЕЦ;
      ЕСЛИ ch = "H" ТОГДА
         сущность := lxHEX
      АЕСЛИ ch = "X" ТОГДА
         сущность := lxCHX
      КОНЕЦ;
      ЕСЛИ сущность # lxINT ТОГДА
         СимвСлед_Добав(ch)
      ИНАЧЕ
         ПОКА Число16_Получ(ch) ДЕЛАТЬ
            сущность := lxHEX;
            СимвСлед_Добав(ch)
         КОНЕЦ;
         ЕСЛИ сущность = lxHEX ТОГДА
            ЕСЛИ ch = "H" ТОГДА
               СимвСлед_Добав(ch)
            АЕСЛИ ch = "X" ТОГДА
               сущность := lxCHX;
               СимвСлед_Добав(ch)
            ИНАЧЕ
               сущность := lxERR1
            КОНЕЦ
         АЕСЛИ ch = "." ТОГДА
            mSys.GET(файл.буф_поз, nextchr);
            ЕСЛИ nextchr # "." ТОГДА
               сущность := lxREAL;
               СимвСлед_Добав(ch);
               ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                  СимвСлед_Добав(ch)
               КОНЕЦ;
               ЕСЛИ (ch = "E") ИЛИ (ch = "D") ТОГДА
                  СимвСлед_Добав(ch);
                  ЕСЛИ (ch = "+") ИЛИ (ch = "-") ТОГДА
                        СимвСлед_Добав(ch)
                  КОНЕЦ;
                  ЕСЛИ ~Цифра_Проверить(ch) ТОГДА
                     сущность := lxERR2
                  ИНАЧЕ
                     ПОКА Цифра_Проверить(ch) ДЕЛАТЬ
                        СимвСлед_Добав(ch)
                     КОНЕЦ
                  КОНЕЦ
               КОНЕЦ
            КОНЕЦ
         КОНЕЦ
      КОНЕЦ;
      Симв_Добав(0X)
   КОНЕЦ Число_Получ;

ПРОЦЕДУРА Разделитель_Получ(симв_: СИМВ): ЦЕЛОЕ;
    ПЕРЕМ
        выход: ЦЕЛОЕ;
    НАЧАЛО
        ВЫБОР симв_ ИЗ
        |"+": выход := мКонст.опПлюс
        |"-": выход := мКонст.опМинус
        |"*": выход := мКонст.опУмнож
        |"/": выход := мКонст.опДелен
        |"~": выход := мКонст.опОтриц
        |"&": выход := мКонст.опИ
        |",": выход := мКонст.опЗапятая
        |";": выход := мКонст.опТчкЗпт
        |"|": выход := мКонст.опВыбор
        |"[": выход := мКонст.опСкобкаЛевКв
        |"{": выход := мКонст.опСкобкаЛевФиг
        |"^": выход := lxCaret
        |"=": выход := мКонст.опРавно
        |"#": выход := мКонст.опНеРавно
        |")": выход := мКонст.опСкобкаПрКр
        |"]": выход := мКонст.опСкобкаПрКв
        |"}": выход := lxRCurly
        |">": выход := мКонст.опБольше
        |"<": выход := мКонст.опМеньше
        |":": выход := мКонст.опДвоеточ
        ИНАЧЕ
        КОНЕЦ
        ВЕРНУТЬ выход
    КОНЕЦ Разделитель_Получ;

ПРОЦЕДУРА Комментарий_Пропустить;
    ПЕРЕМ
        c, level: ЦЕЛОЕ;
        cont: БУЛЕВО;
    НАЧАЛО
        c := 1;
        level := 1;
        cont := ИСТИНА;
        ПОКА cont & (level > 0) ДЕЛАТЬ
            Next;
            ВЫБОР ch ИЗ
            |"(": c := 2
            |")": ЕСЛИ c = 3 ТОГДА
                    ВЫЧ(level)
                  КОНЕЦ;
                  c := 1
            |"*": ЕСЛИ c = 2 ТОГДА
                    ДОБ(level);
                    c := 1
                  ИНАЧЕ
                    c := 3
                  КОНЕЦ
            |0X : cont := ЛОЖЬ
            ИНАЧЕ
                c := 1
            КОНЕЦ;
        КОНЕЦ;
        ЕСЛИ cont ТОГДА
            Next
        КОНЕЦ
    КОНЕЦ Комментарий_Пропустить;

ПРОЦЕДУРА Лексема_Получ*;
   НАЧАЛО
      ПОКА Пробел_Проверить(ch) ДЕЛАТЬ
         Next
      КОНЕЦ;
      col := ccol;
      line := cline;
      count := 0;
      ВЫБОР ch ИЗ
         |"A".."Z", "a".."z", "_": (* eng *)
            Имя_Получ;
            id := мУзел.Добавить(Lex);
            сущность := id.цКлСлово;
         |"А".."Я", "а".."я": (* rus *)
            Имя_Получ;
            id := мУзел.Добавить(Lex);
            сущность := id.цКлСлово;
         |"0".."9":
            Число_Получ;
            ВЫБОР сущность ИЗ
               |lxINT:  vINT := Стр_в_Цел(Lex)
               |lxHEX:  vINT := Стр_в_Цел16(Lex)
               |lxCHX:  vCHX := Стр_в_Симв(Lex)
               |lxREAL: vFLT := Стр_в_Вещ(Lex)
            ИНАЧЕ
            КОНЕЦ
         |22X:
            сущность := lxSTRING;
            Next;
            ПОКА (ch # 22X) & (ch >= 20X) ДЕЛАТЬ
               СимвСлед_Добав(ch)
            КОНЕЦ;
            ЕСЛИ ch = 22X ТОГДА
               Next
            ИНАЧЕ
               сущность := lxERR3
            КОНЕЦ;
            Симв_Добав(0X);
            ДОБ(count);
            ЕСЛИ count > STRLENGTH ТОГДА
               сущность := lxERR11
            КОНЕЦ
         |"/":
            сущность := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "/" ТОГДА
               ПОКА (ch >= 20X) ИЛИ (ch = 9X) ДЕЛАТЬ
                  СимвСлед_Добав(ch)
               КОНЕЦ;
               Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
        |">", "<", ":":
            сущность := Разделитель_Получ(ch);
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "=" ТОГДА
               ВЫБОР сущность ИЗ
                  |мКонст.опМеньше:  сущность := lxLE
                  |мКонст.опБольше:  сущность := lxGE
                  |мКонст.опДвоеточ: сущность := lxAssign
               ИНАЧЕ
               КОНЕЦ;
               СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
         |".":
            сущность := lxDot;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "." ТОГДА
               сущность := lxDbl;
               СимвСлед_Добав(ch)
            КОНЕЦ;
            Симв_Добав(0X)
         |"(":
            сущность := lxLRound;
            СимвСлед_Добав(ch);
            ЕСЛИ ch = "*" ТОГДА
               Комментарий_Пропустить;
               Лексема_Получ
            КОНЕЦ;
            Симв_Добав(0X)
         |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            сущность := Разделитель_Получ(ch);
            Симв_Добав(ch);
            СимвСлед_Добав(0X)
         |0X:
            сущность := lxEOF;
            Симв_Добав(0X)
         ИНАЧЕ
            сущность := lxERR4
         КОНЕЦ
   КОНЕЦ Лексема_Получ;

ПРОЦЕДУРА КлючСлово_Добавить(слово_: мСтр.тСтрока; номер_: ЦЕЛОЕ);
   ПЕРЕМ
      узел: мУзел.туУзел;
   НАЧАЛО
      узел := мУзел.Добавить(слово_);
      узел.цКлСлово := номер_
   КОНЕЦ КлючСлово_Добавить;

ПРОЦЕДУРА Настроить;
   ПЕРЕМ
      i: ЦЕЛОЕ;
      узел: мУзел.туУзел;
   НАЧАЛО
      ДЛЯ i := 0 ДО мУзел.Nodes_LEN() - 1 ДЕЛАТЬ
         НОВ(узел);
         мПам.Ошибка(узел = ПУСТО);
         mSys.PUT(mSys.ADR(узел.имя_стр), i);
         узел.левый := ПУСТО;
         узел.правый := ПУСТО;
         узел.цКлСлово := lxIDENT;
         мУзел.Nodes_Уст(i, узел)
      КОНЕЦ;
         _START := мУзел.Добавить("START");
         _version := мУзел.Добавить("version");
         КлючСлово_Добавить("MOD", lxMOD);
        
         КлючСлово_Добавить("CASE", мКонст.ксВЫБОР);
         КлючСлово_Добавить("ВЫБОР", мКонст.ксВЫБОР);
        
         КлючСлово_Добавить("IF", мКонст.ксЕСЛИ);
         КлючСлово_Добавить("ЕСЛИ", мКонст.ксЕСЛИ);
         
         КлючСлово_Добавить("TYPE", мКонст.ксТИПЫ);
         КлючСлово_Добавить("ТИПЫ", мКонст.ксТИПЫ);
        
         КлючСлово_Добавить("BEGIN", мКонст.ксНАЧАЛО);
         КлючСлово_Добавить("НАЧАЛО", мКонст.ксНАЧАЛО);
        
         КлючСлово_Добавить("DIV", lxDIV);
        
         КлючСлово_Добавить("IN", мКонст.ксВ);
         КлючСлово_Добавить("В", мКонст.ксВ);
        
         КлючСлово_Добавить("NIL", мКонст.ксПУСТО);
         КлючСлово_Добавить("ПУСТО", мКонст.ксПУСТО);

        
         КлючСлово_Добавить("VAR", мКонст.ксПЕРЕМ);
         КлючСлово_Добавить("ПЕРЕМ", мКонст.ксПЕРЕМ);
         КлючСлово_Добавить("ПЕР", мКонст.ксПЕРЕМ);
        
         КлючСлово_Добавить("ARRAY", мКонст.ксМАССИВ);
         КлючСлово_Добавить("МАССИВ", мКонст.ксМАССИВ);
        
         КлючСлово_Добавить("DO", мКонст.ксДЕЛАТЬ);
         КлючСлово_Добавить("ДЕЛАТЬ", мКонст.ксДЕЛАТЬ);
        
         КлючСлово_Добавить("IS", мКонст.ксЕСТЬ);
         КлючСлово_Добавить("ЕСТЬ", мКонст.ксЕСТЬ);
         
         КлючСлово_Добавить("OF", мКонст.ксИЗ);
         КлючСлово_Добавить("ИЗ", мКонст.ксИЗ);
         
         КлючСлово_Добавить("THEN", мКонст.ксТОГДА);
         КлючСлово_Добавить("ТОГДА", мКонст.ксТОГДА);
         
         КлючСлово_Добавить("WHILE", мКонст.ксПОКА);
         КлючСлово_Добавить("ПОКА", мКонст.ксПОКА);
         
         КлючСлово_Добавить("BY", мКонст.lxBY);
         КлючСлово_Добавить("ПО", мКонст.lxBY);
         
         КлючСлово_Добавить("MODULE", мКонст.ксМОДУЛЬ);
         КлючСлово_Добавить("МОДУЛЬ", мКонст.ксМОДУЛЬ);
         
         КлючСлово_Добавить("IMPORT", мКонст.ксИМПОРТ);
         КлючСлово_Добавить("ИМПОРТ", мКонст.ксИМПОРТ);
         
         КлючСлово_Добавить("CONST", мКонст.ксКОНСТ);
         КлючСлово_Добавить("КОНСТ", мКонст.ксКОНСТ);

         КлючСлово_Добавить("END", мКонст.ксКОНЕЦ);
         КлючСлово_Добавить("КОНЕЦ", мКонст.ксКОНЕЦ);
         
         КлючСлово_Добавить("ELSE", мКонст.ксИНАЧЕ);
         КлючСлово_Добавить("ИНАЧЕ", мКонст.ксИНАЧЕ);
         
         КлючСлово_Добавить("ELSIF", мКонст.ксАЕСЛИ);
         КлючСлово_Добавить("АЕСЛИ", мКонст.ксАЕСЛИ);
         
         КлючСлово_Добавить("POINTER", мКонст.ксУКАЗАТЕЛЬ);
         КлючСлово_Добавить("УКАЗАТЕЛЬ", мКонст.ксУКАЗАТЕЛЬ);
         
         КлючСлово_Добавить("TO", мКонст.ксДО);
         КлючСлово_Добавить("НА", мКонст.ксДО);
         КлючСлово_Добавить("ДО", мКонст.ксДО);
         
         КлючСлово_Добавить("RECORD", мКонст.ксЗАПИСЬ);
         КлючСлово_Добавить("ЗАПИСЬ", мКонст.ксЗАПИСЬ);
         
         КлючСлово_Добавить("RETURN", мКонст.ксВЕРНУТЬ);
         КлючСлово_Добавить("ВЕРНУТЬ", мКонст.ксВЕРНУТЬ);
         
         КлючСлово_Добавить("PROCEDURE", мКонст.ксПРОЦЕДУРА);
         КлючСлово_Добавить("ПРОЦЕДУРА", мКонст.ксПРОЦЕДУРА);
        
         КлючСлово_Добавить("OR", мКонст.lxOR);
         КлючСлово_Добавить("ИЛИ", мКонст.lxOR);
         
         КлючСлово_Добавить("TRUE", мКонст.ксИСТИНА);
         КлючСлово_Добавить("ИСТИНА", мКонст.ксИСТИНА);
        
         КлючСлово_Добавить("FALSE", мКонст.ксЛОЖЬ);
         КлючСлово_Добавить("ЛОЖЬ", мКонст.ксЛОЖЬ);
         
         КлючСлово_Добавить("FOR", мКонст.ксДЛЯ);
         КлючСлово_Добавить("ДЛЯ", мКонст.ксДЛЯ);
         
         КлючСлово_Добавить("UNTIL", мКонст.ксПОКАНЕ);
         КлючСлово_Добавить("ПОКАНЕ", мКонст.ксПОКАНЕ);
         
         КлючСлово_Добавить("REPEAT", мКонст.ксПОВТОР);
         КлючСлово_Добавить("ПОВТОРЯТЬ", мКонст.ксПОВТОР);
   КОНЕЦ Настроить;

НАЧАЛО
   НОВ(файл);
   Настроить
КОНЕЦ модСканер.
