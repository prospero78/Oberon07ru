(*
    Copyright 2013 Krotov Anton

This file is part of Compiler.

    Compiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Compiler. If not, see <http://www.gnu.org/licenses/>.

*)

лндскэ ЛНДяЙЮМЕП;

хлонпр ЛсРХКЭ := ЛНДсРХКЭ,
    mSys := SYSTEM,
    ЛйНМЯР := ЛНДйНМЯРЮМРШ,
    ЛтЮИК := ЛНДтЮИК,
    ЛрХОШ := ЛНДрХОШ;

йнмяр

    maxDBL* = 1.69D308;
    
    IDLENGTH = 255;
    STRLENGTH* = 256;

    lxEOF = 0; lxINT = -1; lxREAL = -2; lxSTRING = -3; lxIDENT = -4; lxHEX = -5; lxCHX = -6; lxLONGREAL = -7;
    lxBY = 3; lxDIV = 6; 
     
    lxMOD = 17;

    lxPlus = 51; lxMinus = 52; lxMult = 53; lxSlash = 54; lxNot = 55; lxAnd = 56; lxComma = 57; lxSemi = 58;
    lxStick = 59; lxLRound = 60; lxLSquare = 61; lxLCurly = 62; lxCaret = 63; lxRRound = 64; lxRSquare = 65;
    lxRCurly = 66; lxDot = 67; lxDbl = 68; lxAssign = 69; lxColon = 70;
    lxEQ = 71; lxNE = 72; lxLT = 73; lxGT = 74; lxLE = 75; lxGE = 76;

    lxERR0 = 100; lxERR1 = 101; lxERR2 = 102; lxERR3 = 103; lxERR4 = 104; lxERR5 = 105; lxERR6 = 106;
    lxERR7 = 107; lxERR8 = 108; lxERR9 = 109; lxERR10 = 110; lxERR11 = 111; lxERR20 = 120;


оепел

    Lex: ЛрХОШ.РяРПНЙЮ;
    File, ccol, cline, count*, col*, line*, tLex*, vINT*: INTEGER;
    vFLT*: LONGREAL; id*: ЛрХОШ.РСсГЕК; ch, vCHX*: CHAR;
    buf, bufpos: INTEGER; CR, UTF8: BOOLEAN;
    Nodes: люяяхб 256 хг ЛрХОШ.РСсГЕК;
    _START*, _version*: ЛрХОШ.РСсГЕК;

опнжедспю сГЕК_дНАЮБ*(Name: ЛрХОШ.РяРПНЙЮ): ЛрХОШ.РСсГЕК;
    оепел
      cur, res: ЛрХОШ.РСсГЕК;

        опнжедспю сГЕК_мНБШИ(Right: BOOLEAN);
            мювюкн
            NEW(res);
            ЛсРХКЭ.MemErr(res = осярн);
            res.ХЛЪ := Name;
            res.tLex := lxIDENT;
            res.КЕБШИ := осярн;
            res.ОПЮБШИ := осярн;
            еякх Right рнцдю
               cur.ОПЮБШИ := res
            хмюве
               cur.КЕБШИ := res
            йнмеж
            йнмеж сГЕК_мНБШИ;

    мювюкн
        res := осярн;
        cur := Nodes[ORD(Name[0])];
        онбрнпърэ
            еякх Name > cur.ХЛЪ рнцдю
               еякх cur.ОПЮБШИ # осярн рнцдю
                  cur := cur.ОПЮБШИ
               хмюве
                  сГЕК_мНБШИ(хярхмю)
               йнмеж
            юеякх Name < cur.ХЛЪ рнцдю
               еякх cur.КЕБШИ # осярн рнцдю
                  cur := cur.КЕБШИ
               хмюве
                  сГЕК_мНБШИ(кнфэ)
               йнмеж
            хмюве
               res := cur
            йнмеж
        онйюме res # осярн
        бепмсрэ res
    йнмеж сГЕК_дНАЮБ;

опнжедспю GetLexStr*(оеп L: ЛрХОШ.РяРПНЙЮ);
    мювюкн
        L := Lex
    йнмеж GetLexStr;

опнжедспю Backup*(scanner: ЛрХОШ.РСяЙЮМЕП);
    мювюкн
        scanner.ТЮИК_МНЛ := File;
        scanner.ccol := ccol;
        scanner.cline := cline;
        scanner.ch := ch;
        scanner.Lex := Lex;
        scanner.ЯВЕРВХЙ := count;
        scanner.col := col;
        scanner.ЯРПНЙЮ_МНЛ := line;
        scanner.tLex := tLex;
        scanner.vINT := vINT;
        scanner.vFLT := vFLT;
        scanner.vCHX := vCHX;
        scanner.buf := buf;
        scanner.bufpos := bufpos;
        scanner.CR := CR;
        scanner.UTF8 := UTF8
    йнмеж Backup;

опнжедспю Recover*(scanner: ЛрХОШ.РСяЙЮМЕП);
    мювюкн
        File := scanner.ТЮИК_МНЛ;
        ccol := scanner.ccol;
        cline := scanner.cline;
        ch := scanner.ch;
        Lex := scanner.Lex;
        count := scanner.ЯВЕРВХЙ;
        col := scanner.col;
        line := scanner.ЯРПНЙЮ_МНЛ;
        tLex := scanner.tLex;
        vINT := scanner.vINT;
        vFLT := scanner.vFLT;
        vCHX := scanner.vCHX;
        buf := scanner.buf;
        bufpos := scanner.bufpos;
        CR := scanner.CR;
        UTF8 := scanner.UTF8
    йнмеж Recover;

опнжедспю Next;
    оепел
        cr: BOOLEAN;
    мювюкн
        cr := кнфэ;
        mSys.GET(bufpos, ch);
        INC(ccol);
        бшанп ch хг
            |0AX: еякх ~CR рнцдю
                    INC(cline)
                    йнмеж;
                    ccol := 0
            |0DX: INC(cline);
                ccol := 0;
                cr := хярхмю
            |09X: DEC(ccol);
                ccol := ccol + ЛйНМЯР.РЮА - (ccol - 1) MOD ЛйНМЯР.РЮА - 1
            |80X..0BFX: еякх UTF8 рнцдю
                            DEC(ccol)
                        йнмеж
        хмюве
        йнмеж;
        CR := cr;
        INC(bufpos)
    йнмеж Next;

опнжедспю тЮИК_нРЙПШРЭ*(FName: люяяхб хг CHAR; оеп FHandle: INTEGER): BOOLEAN;
    оепел
      n, size: INTEGER; c: CHAR;
    мювюкн
        File := ЛсРХКЭ.тЮИК_нРЙПШРЭ(FName, 0);
        FHandle := File;
        еякх File # 0 рнцдю
            CR := кнфэ;
            UTF8 := кнфэ;
            ccol := 0;
            cline := 1;
            ch := 0X;
            size := ЛсРХКЭ.тЮИКпЮГЛЕП_оНКСВ(File);
            buf := ЛсРХКЭ.оЮЛЪРЭ_оНКСВ(size + 1024);
            mSys.PUT(buf + size, 0X);
            ЛсРХКЭ.MemErr(buf = 0);
            n := ЛсРХКЭ.тЮИК_вХРЮРЭ(File, buf, size);
            ЛтЮИК.тЮИК_гЮЙПШРЭ(File);
            bufpos := buf;
            mSys.GET(buf, c);
            еякх c = 0EFX рнцдю
            mSys.GET(buf + 1, c);
            еякх c = 0BBX рнцдю
        mSys.GET(buf + 2, c);
        еякх c = 0BFX рнцдю
            INC(bufpos, 3);
            UTF8 := хярхмю
        йнмеж
            йнмеж
            йнмеж;
            Next
        йнмеж
        бепмсрэ (File # 0) & (n = size)
    йнмеж тЮИК_нРЙПШРЭ;

опнжедспю Space(ch: CHAR): BOOLEAN;
    бепмсрэ (ch <= 20X) & (ch > 0X)
    йнмеж Space;

опнжедспю Letter(ch: CHAR): BOOLEAN;
    оепел
        ch_eng: BOOLEAN;
        ch_rus: BOOLEAN;
        
        result: BOOLEAN;
    мювюкн
        ch_eng := (ch >= "A") & (ch <= "Z") хкх (ch >= "a") & (ch <= "z") хкх (ch = "_");
        ch_rus := (ch >= "ю") & (ch <= "ъ") хкх (ch >= "Ю") & (ch <= "Ъ");
        result := ch_eng хкх ch_rus;
        бепмсрэ result
    йнмеж Letter;

опнжедспю Digit*(ch: CHAR): BOOLEAN;
        бепмсрэ (ch >= "0") & (ch <= "9")
    йнмеж Digit;

опнжедспю HexDigit*(ch: CHAR): BOOLEAN;
        бепмсрэ (ch >= "A") & (ch <= "F") хкх (ch >= "0") & (ch <= "9")
    йнмеж HexDigit;

опнжедспю PutChar(ch: CHAR);
    мювюкн
        Lex[count] := ch;
        еякх ch # 0X рнцдю
            INC(count)
        йнмеж
    йнмеж PutChar;

опнжедспю PutNext(ch: CHAR);
    мювюкн
        PutChar(ch);
        Next
    йнмеж PutNext;

опнжедспю Ident;
    мювюкн
        tLex := lxIDENT;
        онйю Letter(ch) хкх Digit(ch) декюрэ
            PutNext(ch)
        йнмеж;
        PutChar(0X);
        еякх count > IDLENGTH рнцдю
            tLex := lxERR10
        йнмеж
    йнмеж Ident;

опнжедспю hex*(ch: CHAR): INTEGER;
    оепел Res: INTEGER;
    мювюкн
        Res := ORD(ch);
        бшанп ch хг
        |"0".."9": DEC(Res, ORD("0"))
        |"A".."F": DEC(Res, ORD("A") - 10)
        хмюве
        йнмеж
        бепмсрэ Res
    йнмеж hex;

опнжедспю StrToInt16(str: ЛрХОШ.РяРПНЙЮ): INTEGER;
    оепел i, res, n: INTEGER; flag: BOOLEAN;
    мювюкн
        res := 0;
        i := 0;
        n := 0;
        онйю str[i] = "0" декюрэ
            INC(i)
        йнмеж;
        flag := хярхмю;
        онйю flag & (str[i] # "X") & (str[i] # "H") декюрэ
            INC(n);
            еякх n > 8 рнцдю
            tLex := lxERR5;
            flag := кнфэ
            хмюве
            res := LSL(res, 4) + hex(str[i]);
            INC(i)
            йнмеж
        йнмеж
        бепмсрэ res
    йнмеж StrToInt16;

опнжедспю StrToChx(str: ЛрХОШ.РяРПНЙЮ): CHAR;
    оепел res: INTEGER;
    мювюкн
        res := StrToInt16(str);
        еякх (res < 0) хкх (res > 0FFH) рнцдю
            tLex := lxERR6;
            res := 0
        йнмеж
        бепмсрэ CHR(res)
    йнмеж StrToChx;

опнжедспю StrToInt*(str: ЛрХОШ.РяРПНЙЮ): INTEGER;
    оепел
        i, res: INTEGER;
        flag: BOOLEAN;
    мювюкн
        res := 0;
        i := 0;
        flag := хярхмю;
        онйю flag & (str[i] # 0X) декюрэ
            еякх res > ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ DIV 10 рнцдю
                tLex := lxERR5;
                flag := кнфэ;
                res := 0
            хмюве
                res := res * 10;
                еякх res > ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ - (ORD(str[i]) - ORD("0")) рнцдю
                    tLex := lxERR5;
                    flag := кнфэ;
                    res := 0
                хмюве
                    res := res + (ORD(str[i]) - ORD("0"));
                    INC(i)
                йнмеж
            йнмеж
        йнмеж
        бепмсрэ res
    йнмеж StrToInt;

опнжедспю StrToFloat(str: ЛрХОШ.РяРПНЙЮ): LONGREAL;
    оепел
        i, scale: INTEGER; res, m, d: LONGREAL; minus, nez: BOOLEAN;

        опнжедспю Error(e: INTEGER; оеп cont: BOOLEAN);
          мювюкн
            tLex := e;
            res := 0.0D0;
            cont := кнфэ
          йнмеж Error;

        опнжедспю Inf(оеп cont: BOOLEAN; оеп i: INTEGER);
          мювюкн
            еякх ЛсРХКЭ.IsInf(res) рнцдю
              Error(lxERR7, cont)
            йнмеж;
            INC(i)
          йнмеж Inf;

        опнжедспю part1(): BOOLEAN;
          оепел cont: BOOLEAN;
          мювюкн
            res := 0.0D0;
            i := 0;
            d := 1.0D0;
            nez := кнфэ;
            cont := хярхмю;
            онйю cont & Digit(str[i]) декюрэ
            nez := nez хкх (str[i] # "0");
            res := res * 10.0D0 + LONG(FLT(ORD(str[i]) - ORD("0")));
            Inf(cont, i)
            йнмеж
            бепмсрэ cont
          йнмеж part1;

        опнжедспю part2(): BOOLEAN;
          оепел cont: BOOLEAN;
          мювюкн
            INC(i);
            cont := хярхмю;
            онйю cont & Digit(str[i]) декюрэ
            nez := nez хкх (str[i] # "0");
            d := d / 10.0D0;
            res := res + LONG(FLT(ORD(str[i]) - ORD("0"))) * d;
            Inf(cont, i)
            йнмеж
            бепмсрэ cont
          йнмеж part2;

        опнжедспю part3(): BOOLEAN;
          оепел cont: BOOLEAN;
          мювюкн
            cont := хярхмю;
            еякх str[i] = 0X рнцдю
              еякх res > LONG(ЛйНМЯР.БЕЫ_ЛЮЙЯ) рнцдю
                Error(lxERR7, cont)
              юеякх nez & ((res = 0.0D0) хкх (res < LONG(ЛйНМЯР.БЕЫ_ЛХМ)) & (tLex = lxREAL)) рнцдю
                Error(lxERR9, cont)
              йнмеж
            йнмеж
            бепмсрэ cont
          йнмеж part3;

        опнжедспю part4(): BOOLEAN;
          оепел cont: BOOLEAN;
          мювюкн
            еякх str[i] = "D" рнцдю
              tLex := lxLONGREAL
            йнмеж;
            INC(i);
            m := 10.0D0;
            minus := кнфэ;
            еякх str[i] = "+" рнцдю
              INC(i)
            юеякх str[i] = "-" рнцдю
              minus := хярхмю;
              INC(i);
              m := 0.1D0
            йнмеж;
            scale := 0;
            cont := хярхмю;
            онйю cont & Digit(str[i]) декюрэ
              еякх scale > ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ DIV 10 рнцдю
                Error(lxERR8, cont)
              хмюве
                scale := scale * 10;
                еякх scale > ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ - (ORD(str[i]) - ORD("0")) рнцдю
                    Error(lxERR8, cont)
                хмюве
                    scale := scale + (ORD(str[i]) - ORD("0"));
                    INC(i)
                йнмеж
              йнмеж
            йнмеж
            бепмсрэ cont
        йнмеж part4;

        опнжедспю part5(): BOOLEAN;
          оепел cont: BOOLEAN; i: INTEGER;
          мювюкн
            cont := хярхмю;
            еякх scale = ЛйНМЯР.ЖЕКНЕ_ЛЮЙЯ рнцдю
            Error(lxERR8, cont)
            йнмеж;
            i := 1;
            онйю cont & (i <= scale) декюрэ
            res := res * m;
            Inf(cont, i)
            йнмеж;
            еякх cont & (nez & (res = 0.0D0) хкх (res > 0.0D0) & (res < LONG(ЛйНМЯР.БЕЫ_ЛХМ)) & (tLex = lxREAL)) рнцдю
            Error(lxERR9, cont)
            юеякх cont & (tLex = lxREAL) & (res > LONG(ЛйНМЯР.БЕЫ_ЛЮЙЯ)) рнцдю
            Error(lxERR7, cont)
            йнмеж
            бепмсрэ cont
          йнмеж part5;

    мювюкн
        еякх part1() & part2() & part3() & part4() & part5() рнцдю йнмеж
        бепмсрэ res
    йнмеж StrToFloat;

опнжедспю Number;
    оепел nextchr: CHAR;
    мювюкн
        tLex := lxINT;
        онйю Digit(ch) декюрэ
            PutNext(ch)
        йнмеж;
        еякх ch = "H" рнцдю
            tLex := lxHEX
        юеякх ch = "X" рнцдю
            tLex := lxCHX
        йнмеж;
        еякх tLex # lxINT рнцдю
            PutNext(ch)
        хмюве
            онйю HexDigit(ch) декюрэ
            tLex := lxHEX;
            PutNext(ch)
            йнмеж;
            еякх tLex = lxHEX рнцдю
            еякх ch = "H" рнцдю
        PutNext(ch)
            юеякх ch = "X" рнцдю
        tLex := lxCHX;
        PutNext(ch)
            хмюве
        tLex := lxERR1
            йнмеж
            юеякх ch = "." рнцдю
            mSys.GET(bufpos, nextchr);
            еякх nextchr # "." рнцдю
        tLex := lxREAL;
        PutNext(ch);
        онйю Digit(ch) декюрэ
            PutNext(ch)
        йнмеж;
        еякх (ch = "E") хкх (ch = "D") рнцдю
            PutNext(ch);
            еякх (ch = "+") хкх (ch = "-") рнцдю
            PutNext(ch)
            йнмеж;
            еякх ~Digit(ch) рнцдю
            tLex := lxERR2
            хмюве
            онйю Digit(ch) декюрэ
            PutNext(ch)
            йнмеж
            йнмеж
        йнмеж
            йнмеж
            йнмеж
        йнмеж;
        PutChar(0X)
    йнмеж Number;

опнжедспю Delim(ch: CHAR): INTEGER;
    оепел Res: INTEGER;
    мювюкн
        бшанп ch хг
        |"+": Res := lxPlus
        |"-": Res := lxMinus
        |"*": Res := lxMult
        |"/": Res := lxSlash
        |"~": Res := lxNot
        |"&": Res := lxAnd
        |",": Res := lxComma
        |";": Res := lxSemi
        |"|": Res := lxStick
        |"[": Res := lxLSquare
        |"{": Res := lxLCurly
        |"^": Res := lxCaret
        |"=": Res := lxEQ
        |"#": Res := lxNE
        |")": Res := lxRRound
        |"]": Res := lxRSquare
        |"}": Res := lxRCurly
        |">": Res := lxGT
        |"<": Res := lxLT
        |":": Res := lxColon
        хмюве
        йнмеж
        бепмсрэ Res
    йнмеж Delim;

опнжедспю Comment;
    оепел c, level: INTEGER; cont: BOOLEAN;
    мювюкн
        c := 1;
        level := 1;
        cont := хярхмю;
        онйю cont & (level > 0) декюрэ
            Next;
            бшанп ch хг
            |"(": c := 2
            |")": еякх c = 3 рнцдю DEC(level) йнмеж; c := 1
            |"*": еякх c = 2 рнцдю INC(level); c := 1 хмюве c := 3 йнмеж
            |0X : cont := кнфэ
            хмюве
            c := 1
            йнмеж;
        йнмеж;
        еякх cont рнцдю
            Next
        йнмеж
    йнмеж Comment;

опнжедспю GetLex*;
    мювюкн
        онйю Space(ch) декюрэ
            Next
        йнмеж;
        col := ccol;
        line := cline;
        count := 0;
        бшанп ch хг
        |"A".."Z", "a".."z", "_": (* eng *)
            Ident;
            id := сГЕК_дНАЮБ(Lex);
            tLex := id.tLex;
        |"ю".."ъ", "Ю".."Ъ": (* rus *)
            Ident;
            id := сГЕК_дНАЮБ(Lex);
            tLex := id.tLex;
        |"0".."9":
            Number;
            бшанп tLex хг
            |lxINT:  vINT := StrToInt(Lex)
            |lxHEX:  vINT := StrToInt16(Lex)
            |lxCHX:  vCHX := StrToChx(Lex)
            |lxREAL: vFLT := StrToFloat(Lex)
            хмюве
            йнмеж
        |22X:
            tLex := lxSTRING;
            Next;
            онйю (ch # 22X) & (ch >= 20X) декюрэ
            PutNext(ch)
            йнмеж;
            еякх ch = 22X рнцдю
            Next
            хмюве
            tLex := lxERR3
            йнмеж;
            PutChar(0X);
            INC(count);
            еякх count > STRLENGTH рнцдю
            tLex := lxERR11
            йнмеж
        |"/":
            tLex := Delim(ch);
            PutNext(ch);
            еякх ch = "/" рнцдю
            онйю (ch >= 20X) хкх (ch = 9X) декюрэ
        PutNext(ch)
            йнмеж;
            GetLex
            йнмеж;
            PutChar(0X)
        |">", "<", ":":
            tLex := Delim(ch);
            PutNext(ch);
            еякх ch = "=" рнцдю
            бшанп tLex хг
            |lxLT:  tLex := lxLE
            |lxGT:  tLex := lxGE
            |lxColon: tLex := lxAssign
            хмюве
            йнмеж;
            PutNext(ch)
            йнмеж;
            PutChar(0X)
        |".":
            tLex := lxDot;
            PutNext(ch);
            еякх ch = "." рнцдю
            tLex := lxDbl;
            PutNext(ch)
            йнмеж;
            PutChar(0X)
        |"(":
            tLex := lxLRound;
            PutNext(ch);
            еякх ch = "*" рнцдю
            Comment;
            GetLex
            йнмеж;
            PutChar(0X)
        |"+", "-", "*", "~", "&", ",", ";", "|", "[", "{", "^", "=", "#", ")", "]", "}":
            tLex := Delim(ch);
            PutChar(ch);
            PutNext(0X)
        |0X:
            tLex := lxEOF;
            PutChar(0X)
        хмюве
            tLex := lxERR4
        йнмеж
    йнмеж GetLex;

опнжедспю AddNodeKey(Name: ЛрХОШ.РяРПНЙЮ; key: INTEGER);
    оепел node: ЛрХОШ.РСсГЕК;
    мювюкн
        node := сГЕК_дНАЮБ(Name);
        node.tLex := key
    йнмеж AddNodeKey;

опнжедспю мЮЯРПНХРЭ;
    оепел
      i: INTEGER;
      node: ЛрХОШ.РСсГЕК;
    мювюкн
        дкъ i := 0 дн LEN(Nodes) - 1 декюрэ
            NEW(node);
            ЛсРХКЭ.MemErr(node = осярн);
            mSys.PUT(mSys.ADR(node.ХЛЪ), i);
            node.КЕБШИ := осярн;
            node.ОПЮБШИ := осярн;
            node.tLex := lxIDENT;
            Nodes[i] := node
        йнмеж;
        _START := сГЕК_дНАЮБ("START");
        _version := сГЕК_дНАЮБ("version");
        AddNodeKey("MOD", lxMOD);
        
        AddNodeKey("CASE", ЛйНМЯР.ЙЯбшанп);
        AddNodeKey("бшанп", ЛйНМЯР.ЙЯбшанп);
        
        AddNodeKey("IF", ЛйНМЯР.ЙЯеякх);
        AddNodeKey("еякх", ЛйНМЯР.ЙЯеякх);
        
        AddNodeKey("TYPE", ЛйНМЯР.ЙЯрхош);
        AddNodeKey("рхош", ЛйНМЯР.ЙЯрхош);
        
        AddNodeKey("BEGIN", ЛйНМЯР.ЙЯмювюкн);
        AddNodeKey("мювюкн", ЛйНМЯР.ЙЯмювюкн);
        
        AddNodeKey("DIV", lxDIV);
        
        AddNodeKey("IN", ЛйНМЯР.ЙЯб);
        AddNodeKey("б", ЛйНМЯР.ЙЯб);
        
        AddNodeKey("NIL", ЛйНМЯР.ЙЯосярн);
        AddNodeKey("осярн", ЛйНМЯР.ЙЯосярн);

        
        AddNodeKey("VAR", ЛйНМЯР.ЙЯоепел);
        AddNodeKey("оепел", ЛйНМЯР.ЙЯоепел);
        AddNodeKey("оеп", ЛйНМЯР.ЙЯоепел);
        
        AddNodeKey("ARRAY", ЛйНМЯР.ЙЯлюяяхб);
        AddNodeKey("люяяхб", ЛйНМЯР.ЙЯлюяяхб);
        
        AddNodeKey("DO", ЛйНМЯР.ЙЯдекюрэ);
        AddNodeKey("декюрэ", ЛйНМЯР.ЙЯдекюрэ);
        
        AddNodeKey("IS", ЛйНМЯР.ЙЯеярэ);
        AddNodeKey("еярэ", ЛйНМЯР.ЙЯеярэ);
        
        AddNodeKey("OF", ЛйНМЯР.ЙЯхг);
        AddNodeKey("хг", ЛйНМЯР.ЙЯхг);
        
        AddNodeKey("THEN", ЛйНМЯР.ЙЯрнцдю);
        AddNodeKey("рнцдю", ЛйНМЯР.ЙЯрнцдю);
        
        AddNodeKey("WHILE", ЛйНМЯР.ЙЯонйю);
        AddNodeKey("онйю", ЛйНМЯР.ЙЯонйю);
        
        AddNodeKey("BY", lxBY);
        
        AddNodeKey("MODULE", ЛйНМЯР.ЙЯлндскэ);
        AddNodeKey("лндскэ", ЛйНМЯР.ЙЯлндскэ);
        
        AddNodeKey("IMPORT", ЛйНМЯР.ЙЯхлонпр);
        AddNodeKey("хлонпр", ЛйНМЯР.ЙЯхлонпр);
        
        AddNodeKey("CONST", ЛйНМЯР.ЙЯйнмяр);
        AddNodeKey("йнмяр", ЛйНМЯР.ЙЯйнмяр);

        AddNodeKey("END", ЛйНМЯР.ЙЯйнмеж);
        AddNodeKey("йнмеж", ЛйНМЯР.ЙЯйнмеж);
        
        AddNodeKey("ELSE", ЛйНМЯР.ЙЯхмюве);
        AddNodeKey("хмюве", ЛйНМЯР.ЙЯхмюве);
        
        AddNodeKey("ELSIF", ЛйНМЯР.ЙЯюеякх);
        AddNodeKey("юеякх", ЛйНМЯР.ЙЯюеякх);
        
        AddNodeKey("POINTER", ЛйНМЯР.ЙЯсйюгюрекэ);
        AddNodeKey("сйюгюрекэ", ЛйНМЯР.ЙЯсйюгюрекэ);
        
        AddNodeKey("TO", ЛйНМЯР.ЙЯдн);
        AddNodeKey("мю", ЛйНМЯР.ЙЯдн);
        AddNodeKey("дн", ЛйНМЯР.ЙЯдн);
        
        AddNodeKey("RECORD", ЛйНМЯР.ЙЯгюохяэ);
        AddNodeKey("гюохяэ", ЛйНМЯР.ЙЯгюохяэ);
        
        AddNodeKey("RETURN", ЛйНМЯР.ЙЯбепмсрэ);
        AddNodeKey("бепмсрэ", ЛйНМЯР.ЙЯбепмсрэ);
        
        AddNodeKey("PROCEDURE", ЛйНМЯР.ЙЯопнжедспю);
        AddNodeKey("опнжедспю", ЛйНМЯР.ЙЯопнжедспю);
        
        AddNodeKey("OR", ЛйНМЯР.lxOR);
        AddNodeKey("хкх", ЛйНМЯР.lxOR);
        
        AddNodeKey("TRUE", ЛйНМЯР.ЙЯхярхмю);
        AddNodeKey("хярхмю", ЛйНМЯР.ЙЯхярхмю);
        
        AddNodeKey("FALSE", ЛйНМЯР.ЙЯкнфэ);
        AddNodeKey("кнфэ", ЛйНМЯР.ЙЯкнфэ);
        
        AddNodeKey("FOR", ЛйНМЯР.ЙЯдкъ);
        AddNodeKey("дкъ", ЛйНМЯР.ЙЯдкъ);
        
        AddNodeKey("UNTIL", ЛйНМЯР.ЙЯонйюме);
        AddNodeKey("онйюме", ЛйНМЯР.ЙЯонйюме);
        
        AddNodeKey("REPEAT", ЛйНМЯР.ЙЯонбрнп);
        AddNodeKey("онбрнпърэ", ЛйНМЯР.ЙЯонбрнп);
        
   йнмеж мЮЯРПНХРЭ;

мювюкн
   мЮЯРПНХРЭ
йнмеж ЛНДяЙЮМЕП.
